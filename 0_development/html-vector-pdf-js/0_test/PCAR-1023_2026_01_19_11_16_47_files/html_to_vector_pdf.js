(function(global2, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("core-js/modules/es.promise.js"), require("core-js/modules/es.string.match.js"), require("core-js/modules/es.string.replace.js"), require("core-js/modules/es.string.starts-with.js"), require("core-js/modules/es.array.iterator.js"), require("core-js/modules/web.dom-collections.iterator.js"), require("core-js/modules/es.array.reduce.js"), require("core-js/modules/es.string.ends-with.js"), require("core-js/modules/es.string.split.js"), require("core-js/modules/es.string.trim.js"), require("core-js/modules/es.array.index-of.js"), require("core-js/modules/es.string.includes.js"), require("core-js/modules/es.array.reverse.js"), require("core-js/modules/es.regexp.to-string.js")) : typeof define === "function" && define.amd ? define(["exports", "core-js/modules/es.promise.js", "core-js/modules/es.string.match.js", "core-js/modules/es.string.replace.js", "core-js/modules/es.string.starts-with.js", "core-js/modules/es.array.iterator.js", "core-js/modules/web.dom-collections.iterator.js", "core-js/modules/es.array.reduce.js", "core-js/modules/es.string.ends-with.js", "core-js/modules/es.string.split.js", "core-js/modules/es.string.trim.js", "core-js/modules/es.array.index-of.js", "core-js/modules/es.string.includes.js", "core-js/modules/es.array.reverse.js", "core-js/modules/es.regexp.to-string.js"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.html_to_vector_pdf = {}));
})(this, (function(exports2) {
  "use strict";var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  const DEFAULT_EXCLUDE_SELECTORS = [
    ".FooterLayerMain_body_fl_001",
    ".cls_footer_layer",
    ".body_fl_001",
    '[style*="display:none"]',
    '[style*="display: none"]',
    "iframe",
    "script",
    "style",
    "#pdf-download-btn",
    "#html-to-vector-pdf-btn",
    ".build-status"
  ];
  const DEFAULT_CONFIG = {
    filename: "document.pdf",
    pageSize: "a4",
    orientation: "portrait",
    margins: { top: 10, right: 10, bottom: 10, left: 10 },
    excludeSelectors: DEFAULT_EXCLUDE_SELECTORS,
    callbacks: {},
    performance: {
      yieldEveryNodes: 250,
      yieldEveryMs: 16,
      yieldStrategy: "raf",
      /**** AMENDMENT [start] "Add renderReadyTimeout default" ****/
      renderReadyTimeout: 1e4
      /**** AMENDMENT [end] "Add renderReadyTimeout default" ****/
    },
    errors: {
      failOnAssetError: false
    },
    text: {
      scale: 1
    },
    render: {
      rasterScale: 2
    },
    pagination: {
      pageBreakBeforeSelectors: [".pagebreak_bf_processed", ".pagebreak_bf", '[data-pdf-page-break-before="true"]']
    },
    debugOverlay: {
      enabled: false,
      strokeColorRgb: [255, 0, 0],
      lineWidthMm: 0.15
    },
    debug: false,
    ui: {
      showLoader: true
    }
  };
  const nowMs = () => typeof performance !== "undefined" ? performance.now() : Date.now();
  const yieldOnce = async (strategy) => {
    if (typeof window === "undefined") return;
    if (strategy === "raf" && typeof window.requestAnimationFrame === "function") {
      await new Promise((resolve) => window.requestAnimationFrame(() => resolve()));
      return;
    }
    await new Promise((resolve) => window.setTimeout(() => resolve(), 0));
  };
  const createYieldController = (cfg) => {
    const yieldEveryNodes = Math.max(1, (cfg == null ? void 0 : cfg.yieldEveryNodes) ?? 250);
    const yieldEveryMs = Math.max(0, (cfg == null ? void 0 : cfg.yieldEveryMs) ?? 16);
    const strategy = (cfg == null ? void 0 : cfg.strategy) ?? "raf";
    let lastYieldAt = nowMs();
    return async (tick) => {
      const t2 = typeof tick === "number" ? tick : 0;
      if (t2 > 0 && t2 % yieldEveryNodes !== 0) return;
      const elapsed = nowMs() - lastYieldAt;
      if (elapsed < yieldEveryMs) return;
      lastYieldAt = nowMs();
      await yieldOnce(strategy);
    };
  };
  const SCREEN_DPI = 96;
  const FALLBACK_PX_TO_MM = 25.4 / SCREEN_DPI;
  let cachedPxToMm = null;
  const getPxToMm = () => {
    if (cachedPxToMm) return cachedPxToMm;
    if (typeof document === "undefined") return FALLBACK_PX_TO_MM;
    const body = document.body;
    if (!body) return FALLBACK_PX_TO_MM;
    const probe = document.createElement("div");
    probe.style.position = "absolute";
    probe.style.left = "-10000px";
    probe.style.top = "0";
    probe.style.width = "100mm";
    probe.style.height = "1px";
    probe.style.visibility = "hidden";
    body.appendChild(probe);
    const rect = probe.getBoundingClientRect();
    probe.remove();
    if (!rect.width || rect.width <= 0) return FALLBACK_PX_TO_MM;
    cachedPxToMm = 100 / rect.width;
    return cachedPxToMm;
  };
  const px2pt = (px) => parseFloat(String(px)) * 0.75;
  const parsePx = (value) => {
    if (!value) return 0;
    const num = parseFloat(value);
    return Number.isFinite(num) ? num : 0;
  };
  const parseLineHeightPx = (lineHeight2, fontSizePx) => {
    const lh = (lineHeight2 || "").trim().toLowerCase();
    if (!lh || lh === "normal") return fontSizePx * 1.2;
    if (lh.endsWith("px")) return parsePx(lh);
    const num = parseFloat(lh);
    if (!Number.isFinite(num)) return fontSizePx * 1.2;
    return num * fontSizePx;
  };
  const pickTextAlign = (el, computedTextAlign) => {
    const attr = (el.getAttribute("align") || "").toLowerCase();
    if (attr === "right" || attr === "center" || attr === "left") return attr;
    const raw = (computedTextAlign || "").toLowerCase();
    if (raw === "right" || raw === "end") return "right";
    if (raw === "center") return "center";
    return "left";
  };
  const wrapTextToWidth = (doc, text2, maxWidthMm) => {
    const cleaned = text2.replace(/\s+/g, " ").trim();
    if (!cleaned) return [];
    if (maxWidthMm <= 0) return [cleaned];
    const tokens = cleaned.split(/(\s+|-)/).filter((t2) => t2.length > 0);
    const lines = [];
    let line = "";
    const pushLine = () => {
      const out = line.trim();
      if (out) lines.push(out);
      line = "";
    };
    for (const token of tokens) {
      const candidate = line ? `${line}${token}` : token;
      const width = doc.getTextWidth(candidate);
      if (width <= maxWidthMm) {
        line = candidate;
        continue;
      }
      if (!line) {
        let chunk = "";
        for (const ch of token) {
          const next = chunk + ch;
          if (doc.getTextWidth(next) <= maxWidthMm) {
            chunk = next;
          } else {
            if (chunk) lines.push(chunk);
            chunk = ch;
          }
        }
        if (chunk) lines.push(chunk);
        line = "";
        continue;
      }
      pushLine();
      line = token;
    }
    pushLine();
    return lines;
  };
  const buildTextStyleKey = (style) => {
    return [style.fontSize, style.fontWeight, style.fontStyle, style.color].join("|");
  };
  const createLayoutIdGetter = () => {
    const layoutIdByElement = /* @__PURE__ */ new WeakMap();
    let nextLayoutId = 1;
    return (el) => {
      const existing = layoutIdByElement.get(el);
      if (existing) return existing;
      const id = nextLayoutId++;
      layoutIdByElement.set(el, id);
      return id;
    };
  };
  const createCellHasMixedTextStyles = () => {
    const hasMixedTextStylesByCell = /* @__PURE__ */ new WeakMap();
    return (cell) => {
      const cached = hasMixedTextStylesByCell.get(cell);
      if (typeof cached === "boolean") return cached;
      const cellStyleKey = buildTextStyleKey(window.getComputedStyle(cell));
      const textWalker = document.createTreeWalker(cell, NodeFilter.SHOW_TEXT);
      let n2 = textWalker.nextNode();
      while (n2) {
        const t2 = n2;
        if (/\S/.test(t2.textContent || "") && t2.parentElement) {
          const key = buildTextStyleKey(window.getComputedStyle(t2.parentElement));
          if (key !== cellStyleKey) {
            hasMixedTextStylesByCell.set(cell, true);
            return true;
          }
        }
        n2 = textWalker.nextNode();
      }
      hasMixedTextStylesByCell.set(cell, false);
      return false;
    };
  };
  const createShouldExclude = (excludeSelectors) => {
    return (el) => {
      if (!el) return false;
      for (const sel of excludeSelectors) {
        try {
          if (el.matches && el.matches(sel)) return true;
          if (el.closest && el.closest(sel)) return true;
        } catch {
        }
      }
      return false;
    };
  };
  const createIsPageBreakBefore = (pageBreakBeforeSelectors) => {
    const selectors = pageBreakBeforeSelectors || [];
    return (el) => {
      for (const sel of selectors) {
        try {
          if (el.matches(sel)) return true;
        } catch {
        }
      }
      return false;
    };
  };
  const parseColor$1 = (c2) => {
    if (!c2 || c2 === "transparent" || c2 === "rgba(0, 0, 0, 0)") return [255, 255, 255];
    if (c2.startsWith("#")) {
      const r2 = parseInt(c2.slice(1, 3), 16);
      const g2 = parseInt(c2.slice(3, 5), 16);
      const b2 = parseInt(c2.slice(5, 7), 16);
      return isNaN(r2) ? [0, 0, 0] : [r2, g2, b2];
    }
    const m2 = c2.match(/\d+/g);
    if (c2.startsWith("rgba") && m2 && m2[3] === "0") return [255, 255, 255];
    return m2 && m2.length >= 3 ? [parseInt(m2[0]), parseInt(m2[1]), parseInt(m2[2])] : [0, 0, 0];
  };
  const isTransparent$1 = (c2) => {
    if (!c2 || c2 === "transparent" || c2 === "rgba(0, 0, 0, 0)") return true;
    if (c2.startsWith("rgba")) {
      const m2 = c2.match(/\d+/g);
      if (m2 && m2[3] === "0") return true;
    }
    return false;
  };
  const svgToDataUrl = (svgSrc, width, height, rasterScale) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "anonymous";
      img.onload = () => {
        const scale = Number.isFinite(rasterScale) && rasterScale > 0 ? rasterScale : 2;
        const canvas = document.createElement("canvas");
        canvas.width = Math.max(1, Math.round(width * scale));
        canvas.height = Math.max(1, Math.round(height * scale));
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          reject(new Error("Could not get canvas context"));
          return;
        }
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        resolve(canvas.toDataURL("image/png"));
      };
      img.onerror = () => reject(new Error("Failed to load SVG image"));
      img.src = svgSrc;
    });
  };
  const isSvgImage = (src) => {
    return src.startsWith("data:image/svg") || src.endsWith(".svg");
  };
  class HtmlToVectorPdfError extends Error {
    constructor(code, message, meta, cause) {
      super(message);
      this.name = "HtmlToVectorPdfError";
      this.code = code;
      this.meta = meta;
      this.cause = cause;
    }
  }
  const asHtmlToVectorPdfError = (err, fallback) => {
    if (err instanceof HtmlToVectorPdfError) return err;
    if (err instanceof Error) return new HtmlToVectorPdfError(fallback.code, fallback.message, fallback.meta, err);
    return new HtmlToVectorPdfError(fallback.code, fallback.message, fallback.meta, err);
  };
  const waitForImageReady = (img) => {
    if (img.complete && img.naturalWidth > 0 && img.naturalHeight > 0) return Promise.resolve();
    return new Promise((resolve, reject) => {
      const onLoad = () => cleanup(resolve);
      const onError = () => cleanup(() => reject(new Error("Failed to load image")));
      const cleanup = (done) => {
        img.removeEventListener("load", onLoad);
        img.removeEventListener("error", onError);
        done();
      };
      img.addEventListener("load", onLoad, { once: true });
      img.addEventListener("error", onError, { once: true });
    });
  };
  const rasterizeImageElementToPngDataUrl = async (img, targetWidthPx, targetHeightPx, rasterScale) => {
    await waitForImageReady(img);
    const scale = Number.isFinite(rasterScale) && rasterScale > 0 ? rasterScale : 2;
    const canvasW = Math.max(1, Math.round(targetWidthPx * scale));
    const canvasH = Math.max(1, Math.round(targetHeightPx * scale));
    const canvas = document.createElement("canvas");
    canvas.width = canvasW;
    canvas.height = canvasH;
    const ctx = canvas.getContext("2d");
    if (!ctx) throw new Error("Could not get canvas context");
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(0, 0, canvasW, canvasH);
    ctx.drawImage(img, 0, 0, canvasW, canvasH);
    return canvas.toDataURL("image/png");
  };
  const imageRasterizeError = (imageSrc, cause) => {
    return new HtmlToVectorPdfError("ASSET_LOAD_FAILED", "Failed to rasterize image", { imageSrc }, cause);
  };
  let cachedCtx = null;
  const cachedMetrics = /* @__PURE__ */ new Map();
  const cachedBaselineOffsets = /* @__PURE__ */ new Map();
  const getCanvasContext = () => {
    if (cachedCtx) return cachedCtx;
    if (typeof document === "undefined") return null;
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d");
    if (!ctx) return null;
    cachedCtx = ctx;
    return cachedCtx;
  };
  const buildCanvasFont = (style) => {
    const fontStyle2 = style.fontStyle && style.fontStyle !== "normal" ? style.fontStyle : "";
    const fontVariant2 = style.fontVariant && style.fontVariant !== "normal" ? style.fontVariant : "";
    const fontWeight2 = style.fontWeight && style.fontWeight !== "normal" ? style.fontWeight : "";
    const fontStretch = style.fontStretch && style.fontStretch !== "normal" ? style.fontStretch : "";
    const fontSize2 = style.fontSize || "16px";
    const fontFamily2 = style.fontFamily || "sans-serif";
    return [fontStyle2, fontVariant2, fontWeight2, fontStretch, fontSize2, fontFamily2].filter(Boolean).join(" ");
  };
  const buildBaselineCacheKey = (style, lineBoxHeightPx) => {
    const font = buildCanvasFont(style);
    const lineBox = Number.isFinite(lineBoxHeightPx) && lineBoxHeightPx > 0 ? Math.round(lineBoxHeightPx * 100) / 100 : 0;
    return `${font}|lh:${lineBox}`;
  };
  const getFontMetricsPx = (style) => {
    const ctx = getCanvasContext();
    if (!ctx) return null;
    const font = buildCanvasFont(style);
    const cacheKey = font;
    if (cachedMetrics.has(cacheKey)) return cachedMetrics.get(cacheKey) ?? null;
    ctx.font = font;
    const m2 = ctx.measureText("Mg");
    const ascent = m2.actualBoundingBoxAscent;
    const descent = m2.actualBoundingBoxDescent;
    const out = typeof ascent === "number" && typeof descent === "number" && Number.isFinite(ascent) && Number.isFinite(descent) ? { ascent, descent } : null;
    cachedMetrics.set(cacheKey, out);
    return out;
  };
  const tryComputeBaselineOffsetViaDomPx = (style, lineBoxHeightPx) => {
    if (typeof document === "undefined") return null;
    const body = document.body;
    if (!body) return null;
    const container = document.createElement("span");
    container.style.position = "absolute";
    container.style.left = "-10000px";
    container.style.top = "0";
    container.style.padding = "0";
    container.style.margin = "0";
    container.style.border = "0";
    container.style.whiteSpace = "nowrap";
    container.style.display = "inline-block";
    container.style.lineHeight = Number.isFinite(lineBoxHeightPx) && lineBoxHeightPx > 0 ? `${lineBoxHeightPx}px` : style.lineHeight || "normal";
    container.style.fontFamily = style.fontFamily;
    container.style.fontSize = style.fontSize;
    container.style.fontWeight = style.fontWeight;
    container.style.fontStyle = style.fontStyle;
    container.style.fontVariant = style.fontVariant;
    container.style.fontStretch = style.fontStretch;
    const text2 = document.createElement("span");
    text2.textContent = "Mg";
    const baselineProbe = document.createElement("span");
    baselineProbe.style.display = "inline-block";
    baselineProbe.style.width = "0";
    baselineProbe.style.height = "0";
    baselineProbe.style.verticalAlign = "baseline";
    container.appendChild(text2);
    container.appendChild(baselineProbe);
    body.appendChild(container);
    const containerRect = container.getBoundingClientRect();
    const probeRect = baselineProbe.getBoundingClientRect();
    container.remove();
    if (!containerRect.height || !Number.isFinite(containerRect.top) || !Number.isFinite(probeRect.top)) return null;
    return probeRect.top - containerRect.top;
  };
  const computeAlphabeticBaselineOffsetPx = (style, lineBoxHeightPx) => {
    const cacheKey = buildBaselineCacheKey(style, lineBoxHeightPx);
    const cached = cachedBaselineOffsets.get(cacheKey);
    if (cached !== void 0) return cached;
    const viaDom = tryComputeBaselineOffsetViaDomPx(style, lineBoxHeightPx);
    if (viaDom !== null && Number.isFinite(viaDom) && viaDom > 0) {
      cachedBaselineOffsets.set(cacheKey, viaDom);
      return viaDom;
    }
    const metrics = getFontMetricsPx(style);
    if (metrics) {
      const lineBox = Number.isFinite(lineBoxHeightPx) && lineBoxHeightPx > 0 ? lineBoxHeightPx : metrics.ascent + metrics.descent;
      const leading = Math.max(0, lineBox - (metrics.ascent + metrics.descent));
      const viaCanvas = leading / 2 + metrics.ascent;
      cachedBaselineOffsets.set(cacheKey, viaCanvas);
      return viaCanvas;
    }
    const fontSizePx = parseFloat(style.fontSize || "0") || 0;
    cachedBaselineOffsets.set(cacheKey, fontSizePx);
    return fontSizePx;
  };
  const parseElementNode = (ctx, el, imagePromises) => {
    const style = window.getComputedStyle(el);
    const rect = el.getBoundingClientRect();
    if (style.display === "none" || style.opacity === "0" || rect.width <= 0 || rect.height <= 0) return;
    const x2 = ctx.cfg.margins.left + ctx.px2mm(rect.left - ctx.rootRect.left);
    const y2 = ctx.px2mm(rect.top - ctx.rootRect.top);
    const w2 = ctx.px2mm(rect.width);
    const h2 = ctx.px2mm(rect.height);
    if (ctx.cfg.debugOverlay.enabled && (el.tagName === "TD" || el.tagName === "TH")) {
      const paddingL = parsePx(style.paddingLeft);
      const paddingR = parsePx(style.paddingRight);
      const paddingT = parsePx(style.paddingTop);
      const paddingB = parsePx(style.paddingBottom);
      const contentLeftPx = rect.left + paddingL;
      const contentRightPx = rect.right - paddingR;
      const contentTopPx = rect.top + paddingT;
      const contentBottomPx = rect.bottom - paddingB;
      const contentX = ctx.cfg.margins.left + ctx.px2mm(contentLeftPx - ctx.rootRect.left);
      const contentY = ctx.px2mm(contentTopPx - ctx.rootRect.top);
      const contentW = ctx.px2mm(Math.max(0, contentRightPx - contentLeftPx));
      const contentH = ctx.px2mm(Math.max(0, contentBottomPx - contentTopPx));
      ctx.items.push({
        type: "debugRect",
        x: contentX,
        y: contentY,
        w: contentW,
        h: contentH,
        style,
        zIndex: 12
      });
    }
    if (!isTransparent$1(style.backgroundColor)) {
      ctx.items.push({ type: "background", x: x2, y: y2, w: w2, h: h2, style, zIndex: 0 });
    }
    const bt2 = parseFloat(style.borderTopWidth);
    const br = parseFloat(style.borderRightWidth);
    const bb = parseFloat(style.borderBottomWidth);
    const bl = parseFloat(style.borderLeftWidth);
    if (bt2 > 0 || br > 0 || bb > 0 || bl > 0) {
      const borderColors = {
        t: parseColor$1(style.borderTopColor),
        r: parseColor$1(style.borderRightColor),
        b: parseColor$1(style.borderBottomColor),
        l: parseColor$1(style.borderLeftColor)
      };
      const borderStyles = {
        t: style.borderTopStyle || "solid",
        r: style.borderRightStyle || "solid",
        b: style.borderBottomStyle || "solid",
        l: style.borderLeftStyle || "solid"
      };
      if (borderStyles.b === "double" || borderStyles.t === "double") {
        console.log("[Border Debug]", {
          element: el.tagName,
          borderBottomStyle: borderStyles.b,
          borderBottomWidth: bb,
          borderTopStyle: borderStyles.t,
          borderTopWidth: bt2
        });
      }
      ctx.items.push({
        type: "border",
        x: x2,
        y: y2,
        w: w2,
        h: h2,
        style,
        zIndex: 10,
        borderSides: { t: bt2, r: br, b: bb, l: bl },
        borderColors,
        borderStyles
      });
    }
    if (el.tagName === "INPUT" && el.type !== "hidden" && el.type !== "checkbox" && el.type !== "radio" && el.type !== "file" && el.type !== "button" && el.type !== "submit" || el.tagName === "TEXTAREA" || el.tagName === "SELECT") {
      let valueText = "";
      if (el.tagName === "SELECT") {
        const selectEl = el;
        if (selectEl.selectedIndex >= 0) {
          valueText = selectEl.options[selectEl.selectedIndex].text;
        }
      } else {
        valueText = el.value;
      }
      if (valueText && /\S/.test(valueText)) {
        const tt2 = (style.textTransform || "none").toLowerCase();
        if (tt2 === "uppercase") {
          valueText = valueText.toUpperCase();
        } else if (tt2 === "lowercase") {
          valueText = valueText.toLowerCase();
        } else if (tt2 === "capitalize") {
          valueText = valueText.replace(/\b[a-z]/gi, (l2) => l2.toUpperCase());
        }
        const paddingL = parsePx(style.paddingLeft);
        const paddingR = parsePx(style.paddingRight);
        const paddingT = parsePx(style.paddingTop);
        const contentLeftPx = rect.left + paddingL;
        const contentRightPx = rect.right - paddingR;
        const contentWidthPx = Math.max(0, contentRightPx - contentLeftPx);
        const textAlign2 = style.textAlign || "left";
        const fontSizePx = parseFloat(style.fontSize);
        const lineHeightPx = parseLineHeightPx(style.lineHeight, fontSizePx);
        const lineHeightMm = ctx.px2mm(lineHeightPx) * ctx.cfg.text.scale;
        const contentHeightPx = rect.height - paddingT - parsePx(style.paddingBottom);
        let yOffsetPx = paddingT;
        if (el.tagName === "INPUT" && contentHeightPx > fontSizePx) {
          yOffsetPx += (contentHeightPx - fontSizePx) / 2;
        }
        const baselineOffsetPx = computeAlphabeticBaselineOffsetPx(style, fontSizePx);
        const baselineOffset = ctx.px2mm(baselineOffsetPx) * ctx.cfg.text.scale;
        const xLeftMm = ctx.cfg.margins.left + ctx.px2mm(contentLeftPx - ctx.rootRect.left);
        const xRightMm = ctx.cfg.margins.left + ctx.px2mm(contentRightPx - ctx.rootRect.left);
        const textX = textAlign2 === "right" ? xRightMm : textAlign2 === "center" ? (xLeftMm + xRightMm) / 2 : xLeftMm;
        const textY = ctx.px2mm(rect.top + yOffsetPx - ctx.rootRect.top) + baselineOffset;
        ctx.items.push({
          type: "text",
          x: textX,
          y: textY,
          w: ctx.px2mm(contentWidthPx),
          h: ctx.px2mm(contentHeightPx),
          style,
          text: valueText,
          textAlign: textAlign2,
          maxWidthMm: ctx.px2mm(contentWidthPx),
          lineHeightMm,
          noWrap: el.tagName !== "TEXTAREA",
          zIndex: 20
        });
      }
    }
    if (el.tagName === "CANVAS") {
      try {
        const canvas = el;
        const dataUrl = canvas.toDataURL("image/png");
        ctx.items.push({
          type: "image",
          x: x2,
          y: y2,
          w: w2,
          h: h2,
          style,
          imageSrc: dataUrl,
          imageFormat: "PNG",
          zIndex: 5
        });
      } catch (e2) {
        if (ctx.cfg.debug) console.warn("[html_to_vector_pdf] Canvas export failed", e2);
      }
    }
    if (el.tagName === "IMG") {
      const imgEl = el;
      const imgSrc = imgEl.src;
      const rasterScale = ctx.cfg.render.rasterScale;
      const imgItem = {
        type: "image",
        x: x2,
        y: y2,
        w: w2,
        h: h2,
        style,
        imageSrc: imgSrc,
        imageFormat: "PNG",
        zIndex: 5
      };
      const dataUrlTypeMatch = imgSrc.match(/^data:image\/(png|jpeg|jpg);/i);
      if (dataUrlTypeMatch) {
        const t2 = dataUrlTypeMatch[1].toLowerCase();
        imgItem.imageFormat = t2 === "png" ? "PNG" : "JPEG";
        ctx.items.push(imgItem);
        return;
      }
      if (isSvgImage(imgSrc)) {
        const promise2 = svgToDataUrl(imgSrc, rect.width, rect.height, rasterScale).then((dataUrl) => {
          imgItem.imageSrc = dataUrl;
          imgItem.imageFormat = "PNG";
        }).catch((err) => {
          var _a2, _b2;
          const e2 = new HtmlToVectorPdfError("ASSET_LOAD_FAILED", "SVG conversion failed", { imageSrc: imgSrc }, err);
          (_b2 = (_a2 = ctx.cfg.callbacks).onError) == null ? void 0 : _b2.call(_a2, e2);
          if (ctx.cfg.errors.failOnAssetError) throw e2;
          if (ctx.cfg.debug) console.warn("[html_to_vector_pdf] SVG conversion failed:", err);
        });
        imagePromises.push(promise2);
        ctx.items.push(imgItem);
        return;
      }
      const promise = rasterizeImageElementToPngDataUrl(imgEl, rect.width, rect.height, rasterScale).then((dataUrl) => {
        imgItem.imageSrc = dataUrl;
        imgItem.imageFormat = "PNG";
      }).catch((err) => {
        var _a2, _b2;
        const e2 = imageRasterizeError(imgSrc, err);
        (_b2 = (_a2 = ctx.cfg.callbacks).onError) == null ? void 0 : _b2.call(_a2, e2);
        if (ctx.cfg.errors.failOnAssetError) throw e2;
        if (ctx.cfg.debug) console.warn("[html_to_vector_pdf] Image rasterize failed:", err);
      });
      imagePromises.push(promise);
      ctx.items.push(imgItem);
    }
  };
  const processWhitespace = (txt) => {
    const rawText = txt.textContent || "";
    if (!/\S/.test(rawText)) return null;
    if (txt.parentElement && txt.parentElement.closest("canvas")) return null;
    const parentElForWhitespace = txt.parentElement;
    const parentWhiteSpace = parentElForWhitespace ? window.getComputedStyle(parentElForWhitespace).whiteSpace || "" : "";
    const ws = parentWhiteSpace.toLowerCase();
    const preservesBoundaryWhitespace = ws === "pre" || ws === "pre-wrap" || ws === "break-spaces";
    const hasMeaningfulSibling = (direction2) => {
      let sib = direction2 === "prev" ? txt.previousSibling : txt.nextSibling;
      while (sib) {
        if (sib.nodeType === Node.ELEMENT_NODE) {
          const tag = sib.tagName.toUpperCase();
          if (tag === "BR") return false;
          return true;
        }
        if (sib.nodeType === Node.TEXT_NODE) {
          const t2 = (sib.textContent || "").replace(/\u00a0/g, " ");
          if (/\S/.test(t2)) return true;
        }
        sib = direction2 === "prev" ? sib.previousSibling : sib.nextSibling;
      }
      return false;
    };
    const startsWithSpace = /^[\s\u00a0]/.test(rawText);
    const endsWithSpace = /[\s\u00a0]$/.test(rawText);
    const collapseNonNbspWhitespace = (s2) => s2.replace(/[ \t\r\n\f\v]+/g, " ");
    const trimNonNbspWhitespace = (s2) => s2.replace(/^[ \t\r\n\f\v]+|[ \t\r\n\f\v]+$/g, "");
    let str = trimNonNbspWhitespace(collapseNonNbspWhitespace(rawText));
    if (!preservesBoundaryWhitespace) {
      if (startsWithSpace && hasMeaningfulSibling("prev")) str = ` ${str}`;
      if (endsWithSpace && hasMeaningfulSibling("next")) str = `${str} `;
    } else {
      if (startsWithSpace) str = ` ${str}`;
      if (endsWithSpace) str = `${str} `;
    }
    return str;
  };
  const applyTextTransform = (str, style) => {
    const tt2 = (style.textTransform || "none").toLowerCase();
    if (tt2 === "uppercase") return str.toUpperCase();
    if (tt2 === "lowercase") return str.toLowerCase();
    if (tt2 === "capitalize") return str.replace(/\b[a-z]/gi, (l2) => l2.toUpperCase());
    return str;
  };
  const checkIsFloating = (el, limit) => {
    let curr = el;
    while (curr && curr !== limit && curr !== document.body) {
      const s2 = window.getComputedStyle(curr);
      if (s2.float !== "none" && s2.float !== "" || s2.position === "absolute" || s2.position === "fixed") {
        return true;
      }
      curr = curr.parentElement;
    }
    return false;
  };
  const checkHasLayoutImpact = (parentEl, layoutEl) => {
    if (parentEl === layoutEl) return false;
    let curr = parentEl;
    while (curr && curr !== layoutEl) {
      const s2 = window.getComputedStyle(curr);
      if (s2.display === "block" || s2.display === "inline-block" || parsePx(s2.paddingLeft) > 0 || parsePx(s2.paddingRight) > 0 || parsePx(s2.paddingTop) > 0 || parsePx(s2.paddingBottom) > 0 || parsePx(s2.marginLeft) > 0 || parsePx(s2.marginRight) > 0 || parsePx(s2.borderLeftWidth) > 0 || parsePx(s2.borderRightWidth) > 0) {
        return true;
      }
      curr = curr.parentElement;
    }
    return false;
  };
  const canAggregateText = (ctx, layoutEl, fontStyle2, rectsLen, inTableCell, hasFloatingChildren, hasLayoutImpact) => {
    if (!inTableCell) return false;
    if (hasFloatingChildren) return false;
    if (hasLayoutImpact) return false;
    if (ctx.cellHasMixedTextStyles(layoutEl)) return false;
    if (buildTextStyleKey(fontStyle2) !== buildTextStyleKey(window.getComputedStyle(layoutEl))) return false;
    return true;
  };
  const parseTextNode = (ctx, txt, shouldExclude, walked) => {
    const str = processWhitespace(txt);
    if (!str) return;
    if (!txt.parentElement || shouldExclude(txt.parentElement)) return;
    const parentEl = txt.parentElement;
    const fontStyle2 = window.getComputedStyle(parentEl);
    const layoutEl = parentEl.closest("td,th") || parentEl;
    const layoutStyle = window.getComputedStyle(layoutEl);
    const layoutRect = layoutEl.getBoundingClientRect();
    const directDivParent = parentEl.closest("div");
    const useNestedDivPadding = directDivParent && directDivParent !== layoutEl && layoutEl.contains(directDivParent);
    let paddingLeftPx = parsePx(layoutStyle.paddingLeft);
    let paddingRightPx = parsePx(layoutStyle.paddingRight);
    if (useNestedDivPadding) {
      const divStyle = window.getComputedStyle(directDivParent);
      paddingLeftPx += parsePx(divStyle.paddingLeft);
      paddingRightPx += parsePx(divStyle.paddingRight);
    }
    const contentLeftPx = layoutRect.left + paddingLeftPx;
    const contentRightPx = layoutRect.right - paddingRightPx;
    const contentWidthPx = Math.max(0, contentRightPx - contentLeftPx);
    const finalStr = applyTextTransform(str, fontStyle2);
    const textAlign2 = pickTextAlign(layoutEl, layoutStyle.textAlign || "");
    const whiteSpace = (layoutStyle.whiteSpace || "").toLowerCase();
    const cssNoWrap = whiteSpace.includes("nowrap");
    const range = document.createRange();
    range.selectNodeContents(txt);
    const rects = range.getClientRects();
    const firstRect = rects.length > 0 ? rects[0] : range.getBoundingClientRect();
    const rectsLen = rects.length > 0 ? rects.length : firstRect.width > 0 && firstRect.height > 0 ? 1 : 0;
    const browserWrapped = rectsLen > 1;
    const noWrap = cssNoWrap || !browserWrapped;
    if (!(layoutRect.width > 0 && layoutStyle.display !== "none" && firstRect.width > 0 && firstRect.height > 0)) return;
    const fontSizePx = parseFloat(fontStyle2.fontSize);
    const lineHeightPx = parseLineHeightPx(layoutStyle.lineHeight, fontSizePx);
    const lineHeightMm = ctx.px2mm(lineHeightPx) * ctx.cfg.text.scale;
    const y2 = ctx.px2mm(firstRect.top - ctx.rootRect.top);
    const h2 = ctx.px2mm(firstRect.height);
    const baselineOffsetPx = computeAlphabeticBaselineOffsetPx(fontStyle2, firstRect.height);
    const baselineOffset = ctx.px2mm(baselineOffsetPx) * ctx.cfg.text.scale;
    const xMmActual = ctx.cfg.margins.left + ctx.px2mm(firstRect.left - ctx.rootRect.left);
    const xLeftMm = ctx.cfg.margins.left + ctx.px2mm(contentLeftPx - ctx.rootRect.left);
    const xRightMm = ctx.cfg.margins.left + ctx.px2mm(contentRightPx - ctx.rootRect.left);
    const xMmCellAligned = textAlign2 === "right" ? xRightMm : textAlign2 === "center" ? (xLeftMm + xRightMm) / 2 : xLeftMm;
    const inTableCell = layoutEl.tagName === "TD" || layoutEl.tagName === "TH";
    const rawBucketPx = Math.round(firstRect.top / 2) * 2;
    let yBucketPx = rawBucketPx;
    if (inTableCell) {
      const layoutId = ctx.getLayoutId(layoutEl);
      if (ctx.cellLastTextBucket && ctx.cellLastTextBucket.has(layoutId)) {
        const lastBucket = ctx.cellLastTextBucket.get(layoutId);
        if (Math.abs(rawBucketPx - lastBucket) < 5) {
          console.log(`[DEBUG] Forcing bucket: raw=${rawBucketPx}, forced=${lastBucket}, text="${finalStr.substring(0, 30)}..."`);
          yBucketPx = lastBucket;
        } else {
          console.log(`[DEBUG] New line: raw=${rawBucketPx}, last=${lastBucket}, text="${finalStr.substring(0, 30)}..."`);
          ctx.cellLastTextBucket.set(layoutId, rawBucketPx);
        }
      } else {
        console.log(`[DEBUG] First text in cell: bucket=${rawBucketPx}, text="${finalStr.substring(0, 30)}..."`);
        if (!ctx.cellLastTextBucket) ctx.cellLastTextBucket = /* @__PURE__ */ new Map();
        ctx.cellLastTextBucket.set(layoutId, rawBucketPx);
      }
    }
    const hasFloatingChildren = inTableCell && layoutEl.querySelector('[style*="float:"]') !== null;
    const hasLayoutImpact = checkHasLayoutImpact(parentEl, layoutEl);
    const canAggregate = canAggregateText(
      ctx,
      layoutEl,
      fontStyle2,
      rectsLen,
      inTableCell,
      hasFloatingChildren,
      hasLayoutImpact
    );
    if (canAggregate) {
      const layoutId = ctx.getLayoutId(layoutEl);
      const styleKey = buildTextStyleKey(fontStyle2);
      const key = `${layoutId}|${styleKey}|${yBucketPx}|${textAlign2}`;
      const existing = ctx.aggregatedTextByKey.get(key);
      if (existing) {
        console.log(`[DEBUG] Aggregating text: "${finalStr.substring(0, 30)}..." into existing key=${key}`);
        existing.text = `${existing.text ?? ""}${finalStr}`;
        existing.cssNoWrap = (existing.cssNoWrap ?? false) || cssNoWrap;
        existing.rectsLen = Math.max(existing.rectsLen ?? 0, rectsLen);
        existing.noWrap = (existing.noWrap ?? true) && noWrap;
      } else {
        ctx.aggregatedTextByKey.set(key, {
          type: "text",
          x: xMmCellAligned,
          y: y2 + baselineOffset,
          w: ctx.px2mm(layoutRect.width),
          h: h2,
          style: fontStyle2,
          text: finalStr,
          textAlign: textAlign2,
          maxWidthMm: ctx.px2mm(contentWidthPx),
          lineHeightMm,
          noWrap,
          cssNoWrap,
          rectsLen,
          alignmentBucket: `${ctx.getLayoutId(layoutEl)}|${yBucketPx}`,
          zIndex: 20
        });
      }
      return;
    }
    const isFloating = checkIsFloating(parentEl, layoutEl);
    const isFloatLeft = isFloating && window.getComputedStyle(parentEl.closest('[style*="float"]') || parentEl).float === "left";
    const shouldSkipInlineGroup = isFloating || hasLayoutImpact;
    const createItem = (isFirstItemInWrapped = false) => ({
      type: "text",
      x: xMmActual,
      y: y2 + baselineOffset,
      w: ctx.px2mm(firstRect.width),
      h: h2,
      style: fontStyle2,
      text: finalStr,
      textAlign: shouldSkipInlineGroup ? "left" : textAlign2,
      // Force left if not aggregating to respect xMmActual
      maxWidthMm: ctx.px2mm(contentWidthPx - (isFirstItemInWrapped ? firstRect.left - contentLeftPx : 0)),
      lineHeightMm,
      noWrap: !browserWrapped,
      cssNoWrap,
      rectsLen,
      inlineGroupId: !shouldSkipInlineGroup ? `${ctx.getLayoutId(layoutEl)}|${yBucketPx}` : void 0,
      inlineOrder: !shouldSkipInlineGroup ? walked : void 0,
      alignmentBucket: `${ctx.getLayoutId(layoutEl)}|${yBucketPx}`,
      floatLeft: isFloatLeft,
      contentLeftMm: xLeftMm,
      contentRightMm: xRightMm,
      zIndex: 20
    });
    if (inTableCell) {
      ctx.items.push(createItem(false));
      return;
    }
    ctx.items.push(createItem(true));
  };
  const parseElementToItems = async (element, cfg, px2mm) => {
    const rootRect = element.getBoundingClientRect();
    const imagePromises = [];
    const pageBreakBeforeYs = [];
    const maybeYield = createYieldController({
      yieldEveryNodes: cfg.performance.yieldEveryNodes,
      yieldEveryMs: cfg.performance.yieldEveryMs,
      strategy: cfg.performance.yieldStrategy
    });
    const items = [];
    const getLayoutId = createLayoutIdGetter();
    const aggregatedTextByKey = /* @__PURE__ */ new Map();
    const cellHasMixedTextStyles = createCellHasMixedTextStyles();
    const shouldExclude = createShouldExclude(cfg.excludeSelectors);
    const isPageBreakBefore = createIsPageBreakBefore(cfg.pagination.pageBreakBeforeSelectors);
    const ctx = {
      cfg,
      rootRect,
      px2mm,
      items,
      aggregatedTextByKey,
      getLayoutId,
      cellHasMixedTextStyles
    };
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT);
    let node2 = walker.nextNode();
    let walked = 0;
    while (node2) {
      walked++;
      await maybeYield(walked);
      if (node2.nodeType === Node.ELEMENT_NODE) {
        const el = node2;
        if (isPageBreakBefore(el)) {
          const rect = el.getBoundingClientRect();
          if (rect.height >= 0) {
            const isFooterWrapper = el.classList.contains("pagebreak_bf_processed") && el.querySelector(".cls_footer_layer_onscreen") !== null;
            const breakY = isFooterWrapper ? px2mm(rect.bottom - rootRect.top) : px2mm(rect.top - rootRect.top);
            if (breakY > 0) pageBreakBeforeYs.push(breakY);
          }
        }
        if (shouldExclude(el)) {
          node2 = walker.nextNode();
          continue;
        }
        parseElementNode(ctx, el, imagePromises);
      } else if (node2.nodeType === Node.TEXT_NODE) {
        parseTextNode(ctx, node2, shouldExclude, walked);
      }
      node2 = walker.nextNode();
    }
    if (aggregatedTextByKey.size > 0) {
      for (const item of aggregatedTextByKey.values()) items.push(item);
    }
    const itemsByLayoutId = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (item.type === "text" && item.alignmentBucket) {
        const layoutId = item.alignmentBucket.split("|")[0];
        if (!itemsByLayoutId.has(layoutId)) itemsByLayoutId.set(layoutId, []);
        itemsByLayoutId.get(layoutId).push(item);
      }
    }
    for (const [layoutId, layoutItems] of itemsByLayoutId) {
      if (layoutItems.length <= 1) continue;
      const buckets = /* @__PURE__ */ new Set();
      for (const item of layoutItems) {
        const parts = item.alignmentBucket.split("|");
        if (parts.length >= 2) {
          const bucketPx = parseInt(parts[1], 10);
          if (!isNaN(bucketPx)) buckets.add(bucketPx);
        }
      }
      if (buckets.size <= 1) continue;
      const sortedBuckets = Array.from(buckets).sort((a2, b2) => a2 - b2);
      const bucketMapping = /* @__PURE__ */ new Map();
      let masterBucket = sortedBuckets[0];
      bucketMapping.set(masterBucket, masterBucket);
      for (let i2 = 1; i2 < sortedBuckets.length; i2++) {
        const current = sortedBuckets[i2];
        if (current - masterBucket <= 4) {
          bucketMapping.set(current, masterBucket);
        } else {
          masterBucket = current;
          bucketMapping.set(current, current);
        }
      }
      for (const item of layoutItems) {
        const parts = item.alignmentBucket.split("|");
        if (parts.length < 2) continue;
        const currentBucketPx = parseInt(parts[1], 10);
        if (isNaN(currentBucketPx)) continue;
        const newBucketPx = bucketMapping.get(currentBucketPx);
        if (newBucketPx !== void 0 && newBucketPx !== currentBucketPx) {
          const newBucketStr = newBucketPx.toString();
          item.alignmentBucket = `${layoutId}|${newBucketStr}`;
          if (item.inlineGroupId) {
            item.inlineGroupId = `${layoutId}|${newBucketStr}`;
          }
        }
      }
    }
    const itemsByBucket = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (item.type === "text" && item.alignmentBucket) {
        const bucket = itemsByBucket.get(item.alignmentBucket);
        if (bucket) bucket.push(item);
        else itemsByBucket.set(item.alignmentBucket, [item]);
      }
    }
    for (const bucketItems of itemsByBucket.values()) {
      if (bucketItems.length === 0) continue;
      let anchorY = null;
      let fallbackY = null;
      let minY = Infinity;
      let maxY = -Infinity;
      for (const item of bucketItems) {
        if (item.inlineGroupId) {
          if (anchorY === null) anchorY = item.y;
        }
        if (fallbackY === null) fallbackY = item.y;
        minY = Math.min(minY, item.y);
        maxY = Math.max(maxY, item.y);
      }
      const targetY = anchorY ?? fallbackY;
      if (targetY !== null && bucketItems.length > 1) {
        if (maxY - minY < 2) {
          for (const item of bucketItems) {
            item.y = targetY;
          }
        }
      }
      for (const item of bucketItems) {
        if (item.floatLeft && item.contentLeftMm !== void 0) {
          item.x = item.contentLeftMm;
        }
      }
    }
    await Promise.all(imagePromises);
    return { items, pageBreakBeforeYs };
  };
  function _typeof$1(o2) {
    "@babel/helpers - typeof";
    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof$1(o2);
  }
  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;
  var fleb = new u8([
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    1,
    1,
    1,
    2,
    2,
    2,
    2,
    3,
    3,
    3,
    3,
    4,
    4,
    4,
    4,
    5,
    5,
    5,
    5,
    0,
    /* unused */
    0,
    0,
    /* impossible */
    0
  ]);
  var fdeb = new u8([
    0,
    0,
    0,
    0,
    1,
    1,
    2,
    2,
    3,
    3,
    4,
    4,
    5,
    5,
    6,
    6,
    7,
    7,
    8,
    8,
    9,
    9,
    10,
    10,
    11,
    11,
    12,
    12,
    13,
    13,
    /* unused */
    0,
    0
  ]);
  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
  var freb = function(eb, start) {
    var b2 = new u16(31);
    for (var i2 = 0; i2 < 31; ++i2) {
      b2[i2] = start += 1 << eb[i2 - 1];
    }
    var r2 = new i32(b2[30]);
    for (var i2 = 1; i2 < 30; ++i2) {
      for (var j2 = b2[i2]; j2 < b2[i2 + 1]; ++j2) {
        r2[j2] = j2 - b2[i2] << 5 | i2;
      }
    }
    return { b: b2, r: r2 };
  };
  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;
  fl[28] = 258, revfl[258] = 28;
  var _b = freb(fdeb, 0), revfd = _b.r;
  var rev = new u16(32768);
  for (var i$6 = 0; i$6 < 32768; ++i$6) {
    var x$1 = (i$6 & 43690) >> 1 | (i$6 & 21845) << 1;
    x$1 = (x$1 & 52428) >> 2 | (x$1 & 13107) << 2;
    x$1 = (x$1 & 61680) >> 4 | (x$1 & 3855) << 4;
    rev[i$6] = ((x$1 & 65280) >> 8 | (x$1 & 255) << 8) >> 1;
  }
  var hMap = (function(cd, mb, r2) {
    var s2 = cd.length;
    var i2 = 0;
    var l2 = new u16(mb);
    for (; i2 < s2; ++i2) {
      if (cd[i2])
        ++l2[cd[i2] - 1];
    }
    var le2 = new u16(mb);
    for (i2 = 1; i2 < mb; ++i2) {
      le2[i2] = le2[i2 - 1] + l2[i2 - 1] << 1;
    }
    var co;
    if (r2) {
      co = new u16(1 << mb);
      var rvb = 15 - mb;
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          var sv = i2 << 4 | cd[i2];
          var r_1 = mb - cd[i2];
          var v2 = le2[cd[i2] - 1]++ << r_1;
          for (var m2 = v2 | (1 << r_1) - 1; v2 <= m2; ++v2) {
            co[rev[v2] >> rvb] = sv;
          }
        }
      }
    } else {
      co = new u16(s2);
      for (i2 = 0; i2 < s2; ++i2) {
        if (cd[i2]) {
          co[i2] = rev[le2[cd[i2] - 1]++] >> 15 - cd[i2];
        }
      }
    }
    return co;
  });
  var flt = new u8(288);
  for (var i$6 = 0; i$6 < 144; ++i$6)
    flt[i$6] = 8;
  for (var i$6 = 144; i$6 < 256; ++i$6)
    flt[i$6] = 9;
  for (var i$6 = 256; i$6 < 280; ++i$6)
    flt[i$6] = 7;
  for (var i$6 = 280; i$6 < 288; ++i$6)
    flt[i$6] = 8;
  var fdt = new u8(32);
  for (var i$6 = 0; i$6 < 32; ++i$6)
    fdt[i$6] = 5;
  var flm = /* @__PURE__ */ hMap(flt, 9, 0);
  var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
  var shft = function(p2) {
    return (p2 + 7) / 8 | 0;
  };
  var slc = function(v2, s2, e2) {
    if (e2 == null || e2 > v2.length)
      e2 = v2.length;
    return new u8(v2.subarray(s2, e2));
  };
  var wbits = function(d2, p2, v2) {
    v2 <<= p2 & 7;
    var o2 = p2 / 8 | 0;
    d2[o2] |= v2;
    d2[o2 + 1] |= v2 >> 8;
  };
  var wbits16 = function(d2, p2, v2) {
    v2 <<= p2 & 7;
    var o2 = p2 / 8 | 0;
    d2[o2] |= v2;
    d2[o2 + 1] |= v2 >> 8;
    d2[o2 + 2] |= v2 >> 16;
  };
  var hTree = function(d2, mb) {
    var t2 = [];
    for (var i2 = 0; i2 < d2.length; ++i2) {
      if (d2[i2])
        t2.push({ s: i2, f: d2[i2] });
    }
    var s2 = t2.length;
    var t22 = t2.slice();
    if (!s2)
      return { t: et$1, l: 0 };
    if (s2 == 1) {
      var v2 = new u8(t2[0].s + 1);
      v2[t2[0].s] = 1;
      return { t: v2, l: 1 };
    }
    t2.sort(function(a2, b2) {
      return a2.f - b2.f;
    });
    t2.push({ s: -1, f: 25001 });
    var l2 = t2[0], r2 = t2[1], i0 = 0, i1 = 1, i22 = 2;
    t2[0] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
    while (i1 != s2 - 1) {
      l2 = t2[t2[i0].f < t2[i22].f ? i0++ : i22++];
      r2 = t2[i0 != i1 && t2[i0].f < t2[i22].f ? i0++ : i22++];
      t2[i1++] = { s: -1, f: l2.f + r2.f, l: l2, r: r2 };
    }
    var maxSym = t22[0].s;
    for (var i2 = 1; i2 < s2; ++i2) {
      if (t22[i2].s > maxSym)
        maxSym = t22[i2].s;
    }
    var tr = new u16(maxSym + 1);
    var mbt = ln(t2[i1 - 1], tr, 0);
    if (mbt > mb) {
      var i2 = 0, dt2 = 0;
      var lft = mbt - mb, cst = 1 << lft;
      t22.sort(function(a2, b2) {
        return tr[b2.s] - tr[a2.s] || a2.f - b2.f;
      });
      for (; i2 < s2; ++i2) {
        var i2_1 = t22[i2].s;
        if (tr[i2_1] > mb) {
          dt2 += cst - (1 << mbt - tr[i2_1]);
          tr[i2_1] = mb;
        } else
          break;
      }
      dt2 >>= lft;
      while (dt2 > 0) {
        var i2_2 = t22[i2].s;
        if (tr[i2_2] < mb)
          dt2 -= 1 << mb - tr[i2_2]++ - 1;
        else
          ++i2;
      }
      for (; i2 >= 0 && dt2; --i2) {
        var i2_3 = t22[i2].s;
        if (tr[i2_3] == mb) {
          --tr[i2_3];
          ++dt2;
        }
      }
      mbt = mb;
    }
    return { t: new u8(tr), l: mbt };
  };
  var ln = function(n2, l2, d2) {
    return n2.s == -1 ? Math.max(ln(n2.l, l2, d2 + 1), ln(n2.r, l2, d2 + 1)) : l2[n2.s] = d2;
  };
  var lc = function(c2) {
    var s2 = c2.length;
    while (s2 && !c2[--s2])
      ;
    var cl = new u16(++s2);
    var cli = 0, cln = c2[0], cls = 1;
    var w2 = function(v2) {
      cl[cli++] = v2;
    };
    for (var i2 = 1; i2 <= s2; ++i2) {
      if (c2[i2] == cln && i2 != s2)
        ++cls;
      else {
        if (!cln && cls > 2) {
          for (; cls > 138; cls -= 138)
            w2(32754);
          if (cls > 2) {
            w2(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
            cls = 0;
          }
        } else if (cls > 3) {
          w2(cln), --cls;
          for (; cls > 6; cls -= 6)
            w2(8304);
          if (cls > 2)
            w2(cls - 3 << 5 | 8208), cls = 0;
        }
        while (cls--)
          w2(cln);
        cls = 1;
        cln = c2[i2];
      }
    }
    return { c: cl.subarray(0, cli), n: s2 };
  };
  var clen = function(cf, cl) {
    var l2 = 0;
    for (var i2 = 0; i2 < cl.length; ++i2)
      l2 += cf[i2] * cl[i2];
    return l2;
  };
  var wfblk = function(out, pos, dat) {
    var s2 = dat.length;
    var o2 = shft(pos + 2);
    out[o2] = s2 & 255;
    out[o2 + 1] = s2 >> 8;
    out[o2 + 2] = out[o2] ^ 255;
    out[o2 + 3] = out[o2 + 1] ^ 255;
    for (var i2 = 0; i2 < s2; ++i2)
      out[o2 + i2 + 4] = dat[i2];
    return (o2 + 4 + s2) * 8;
  };
  var wblk = function(dat, out, final, syms, lf, df, eb, li, bs, bl, p2) {
    wbits(out, p2++, final);
    ++lf[256];
    var _a2 = hTree(lf, 15), dlt = _a2.t, mlb = _a2.l;
    var _b2 = hTree(df, 15), ddt = _b2.t, mdb = _b2.l;
    var _c = lc(dlt), lclt = _c.c, nlc = _c.n;
    var _d = lc(ddt), lcdt = _d.c, ndc = _d.n;
    var lcfreq = new u16(19);
    for (var i2 = 0; i2 < lclt.length; ++i2)
      ++lcfreq[lclt[i2] & 31];
    for (var i2 = 0; i2 < lcdt.length; ++i2)
      ++lcfreq[lcdt[i2] & 31];
    var _e2 = hTree(lcfreq, 7), lct = _e2.t, mlcb = _e2.l;
    var nlcc = 19;
    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)
      ;
    var flen = bl + 5 << 3;
    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + 2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18];
    if (bs >= 0 && flen <= ftlen && flen <= dtlen)
      return wfblk(out, p2, dat.subarray(bs, bs + bl));
    var lm, ll, dm, dl;
    wbits(out, p2, 1 + (dtlen < ftlen)), p2 += 2;
    if (dtlen < ftlen) {
      lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
      var llm = hMap(lct, mlcb, 0);
      wbits(out, p2, nlc - 257);
      wbits(out, p2 + 5, ndc - 1);
      wbits(out, p2 + 10, nlcc - 4);
      p2 += 14;
      for (var i2 = 0; i2 < nlcc; ++i2)
        wbits(out, p2 + 3 * i2, lct[clim[i2]]);
      p2 += 3 * nlcc;
      var lcts = [lclt, lcdt];
      for (var it2 = 0; it2 < 2; ++it2) {
        var clct = lcts[it2];
        for (var i2 = 0; i2 < clct.length; ++i2) {
          var len = clct[i2] & 31;
          wbits(out, p2, llm[len]), p2 += lct[len];
          if (len > 15)
            wbits(out, p2, clct[i2] >> 5 & 127), p2 += clct[i2] >> 12;
        }
      }
    } else {
      lm = flm, ll = flt, dm = fdm, dl = fdt;
    }
    for (var i2 = 0; i2 < li; ++i2) {
      var sym = syms[i2];
      if (sym > 255) {
        var len = sym >> 18 & 31;
        wbits16(out, p2, lm[len + 257]), p2 += ll[len + 257];
        if (len > 7)
          wbits(out, p2, sym >> 23 & 31), p2 += fleb[len];
        var dst = sym & 31;
        wbits16(out, p2, dm[dst]), p2 += dl[dst];
        if (dst > 3)
          wbits16(out, p2, sym >> 5 & 8191), p2 += fdeb[dst];
      } else {
        wbits16(out, p2, lm[sym]), p2 += ll[sym];
      }
    }
    wbits16(out, p2, lm[256]);
    return p2 + ll[256];
  };
  var deo = /* @__PURE__ */ new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
  var et$1 = /* @__PURE__ */ new u8(0);
  var dflt = function(dat, lvl, plvl, pre, post, st2) {
    var s2 = st2.z || dat.length;
    var o2 = new u8(pre + s2 + 5 * (1 + Math.ceil(s2 / 7e3)) + post);
    var w2 = o2.subarray(pre, o2.length - post);
    var lst = st2.l;
    var pos = (st2.r || 0) & 7;
    if (lvl) {
      if (pos)
        w2[0] = st2.r >> 3;
      var opt = deo[lvl - 1];
      var n2 = opt >> 13, c2 = opt & 8191;
      var msk_1 = (1 << plvl) - 1;
      var prev = st2.p || new u16(32768), head = st2.h || new u16(msk_1 + 1);
      var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
      var hsh = function(i3) {
        return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
      };
      var syms = new i32(25e3);
      var lf = new u16(288), df = new u16(32);
      var lc_1 = 0, eb = 0, i2 = st2.i || 0, li = 0, wi = st2.w || 0, bs = 0;
      for (; i2 + 2 < s2; ++i2) {
        var hv = hsh(i2);
        var imod = i2 & 32767, pimod = head[hv];
        prev[imod] = pimod;
        head[hv] = imod;
        if (wi <= i2) {
          var rem = s2 - i2;
          if ((lc_1 > 7e3 || li > 24576) && (rem > 423 || !lst)) {
            pos = wblk(dat, w2, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
            li = lc_1 = eb = 0, bs = i2;
            for (var j2 = 0; j2 < 286; ++j2)
              lf[j2] = 0;
            for (var j2 = 0; j2 < 30; ++j2)
              df[j2] = 0;
          }
          var l2 = 2, d2 = 0, ch_1 = c2, dif = imod - pimod & 32767;
          if (rem > 2 && hv == hsh(i2 - dif)) {
            var maxn = Math.min(n2, rem) - 1;
            var maxd = Math.min(32767, i2);
            var ml = Math.min(258, rem);
            while (dif <= maxd && --ch_1 && imod != pimod) {
              if (dat[i2 + l2] == dat[i2 + l2 - dif]) {
                var nl = 0;
                for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl)
                  ;
                if (nl > l2) {
                  l2 = nl, d2 = dif;
                  if (nl > maxn)
                    break;
                  var mmd = Math.min(dif, nl - 2);
                  var md = 0;
                  for (var j2 = 0; j2 < mmd; ++j2) {
                    var ti = i2 - dif + j2 & 32767;
                    var pti = prev[ti];
                    var cd = ti - pti & 32767;
                    if (cd > md)
                      md = cd, pimod = ti;
                  }
                }
              }
              imod = pimod, pimod = prev[imod];
              dif += imod - pimod & 32767;
            }
          }
          if (d2) {
            syms[li++] = 268435456 | revfl[l2] << 18 | revfd[d2];
            var lin = revfl[l2] & 31, din = revfd[d2] & 31;
            eb += fleb[lin] + fdeb[din];
            ++lf[257 + lin];
            ++df[din];
            wi = i2 + l2;
            ++lc_1;
          } else {
            syms[li++] = dat[i2];
            ++lf[dat[i2]];
          }
        }
      }
      for (i2 = Math.max(i2, wi); i2 < s2; ++i2) {
        syms[li++] = dat[i2];
        ++lf[dat[i2]];
      }
      pos = wblk(dat, w2, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
      if (!lst) {
        st2.r = pos & 7 | w2[pos / 8 | 0] << 3;
        pos -= 7;
        st2.h = head, st2.p = prev, st2.i = i2, st2.w = wi;
      }
    } else {
      for (var i2 = st2.w || 0; i2 < s2 + lst; i2 += 65535) {
        var e2 = i2 + 65535;
        if (e2 >= s2) {
          w2[pos / 8 | 0] = lst;
          e2 = s2;
        }
        pos = wfblk(w2, pos + 1, dat.subarray(i2, e2));
      }
      st2.i = s2;
    }
    return slc(o2, 0, pre + shft(pos) + post);
  };
  var adler = function() {
    var a2 = 1, b2 = 0;
    return {
      p: function(d2) {
        var n2 = a2, m2 = b2;
        var l2 = d2.length | 0;
        for (var i2 = 0; i2 != l2; ) {
          var e2 = Math.min(i2 + 2655, l2);
          for (; i2 < e2; ++i2)
            m2 += n2 += d2[i2];
          n2 = (n2 & 65535) + 15 * (n2 >> 16), m2 = (m2 & 65535) + 15 * (m2 >> 16);
        }
        a2 = n2, b2 = m2;
      },
      d: function() {
        a2 %= 65521, b2 %= 65521;
        return (a2 & 255) << 24 | (a2 & 65280) << 8 | (b2 & 255) << 8 | b2 >> 8;
      }
    };
  };
  var dopt = function(dat, opt, pre, post, st2) {
    if (!st2) {
      st2 = { l: 1 };
      if (opt.dictionary) {
        var dict = opt.dictionary.subarray(-32768);
        var newDat = new u8(dict.length + dat.length);
        newDat.set(dict);
        newDat.set(dat, dict.length);
        dat = newDat;
        st2.w = dict.length;
      }
    }
    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? st2.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 20 : 12 + opt.mem, pre, post, st2);
  };
  var wbytes = function(d2, b2, v2) {
    for (; v2; ++b2)
      d2[b2] = v2, v2 >>>= 8;
  };
  var zlh = function(c2, o2) {
    var lv = o2.level, fl2 = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
    c2[0] = 120, c2[1] = fl2 << 6 | (o2.dictionary && 32);
    c2[1] |= 31 - (c2[0] << 8 | c2[1]) % 31;
    if (o2.dictionary) {
      var h2 = adler();
      h2.p(o2.dictionary);
      wbytes(c2, 2, h2.d());
    }
  };
  function zlibSync(data, opts) {
    if (!opts)
      opts = {};
    var a2 = adler();
    a2.p(data);
    var d2 = dopt(data, opts, opts.dictionary ? 6 : 2, 4);
    return zlh(d2, opts), wbytes(d2, d2.length - 4, a2.d()), d2;
  }
  var td = typeof TextDecoder != "undefined" && /* @__PURE__ */ new TextDecoder();
  var tds = 0;
  try {
    td.decode(et$1, { stream: true });
    tds = 1;
  } catch (e2) {
  }
  function _arrayWithHoles(r2) {
    if (Array.isArray(r2)) return r2;
  }
  function _iterableToArrayLimit(r2, l2) {
    var t2 = null == r2 ? null : "undefined" != typeof Symbol && r2[Symbol.iterator] || r2["@@iterator"];
    if (null != t2) {
      var e2, n2, i2, u2, a2 = [], f2 = true, o2 = false;
      try {
        if (i2 = (t2 = t2.call(r2)).next, 0 === l2) ;
        else for (; !(f2 = (e2 = i2.call(t2)).done) && (a2.push(e2.value), a2.length !== l2); f2 = true) ;
      } catch (r3) {
        o2 = true, n2 = r3;
      } finally {
        try {
          if (!f2 && null != t2["return"] && (u2 = t2["return"](), Object(u2) !== u2)) return;
        } finally {
          if (o2) throw n2;
        }
      }
      return a2;
    }
  }
  function _arrayLikeToArray(r2, a2) {
    (null == a2 || a2 > r2.length) && (a2 = r2.length);
    for (var e2 = 0, n2 = Array(a2); e2 < a2; e2++) n2[e2] = r2[e2];
    return n2;
  }
  function _unsupportedIterableToArray(r2, a2) {
    if (r2) {
      if ("string" == typeof r2) return _arrayLikeToArray(r2, a2);
      var t2 = {}.toString.call(r2).slice(8, -1);
      return "Object" === t2 && r2.constructor && (t2 = r2.constructor.name), "Map" === t2 || "Set" === t2 ? Array.from(r2) : "Arguments" === t2 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t2) ? _arrayLikeToArray(r2, a2) : void 0;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(r2, e2) {
    return _arrayWithHoles(r2) || _iterableToArrayLimit(r2, e2) || _unsupportedIterableToArray(r2, e2) || _nonIterableRest();
  }
  function decode$2(bytes, encoding = "utf8") {
    const decoder = new TextDecoder(encoding);
    return decoder.decode(bytes);
  }
  const encoder = new TextEncoder();
  function encode(str) {
    return encoder.encode(str);
  }
  const defaultByteLength = 1024 * 8;
  const hostBigEndian = (() => {
    const array = new Uint8Array(4);
    const view = new Uint32Array(array.buffer);
    return !((view[0] = 1) & array[0]);
  })();
  const typedArrays = {
    int8: globalThis.Int8Array,
    uint8: globalThis.Uint8Array,
    int16: globalThis.Int16Array,
    uint16: globalThis.Uint16Array,
    int32: globalThis.Int32Array,
    uint32: globalThis.Uint32Array,
    uint64: globalThis.BigUint64Array,
    int64: globalThis.BigInt64Array,
    float32: globalThis.Float32Array,
    float64: globalThis.Float64Array
  };
  class IOBuffer {
    /**
     * Create a new IOBuffer.
     * @param data - The data to construct the IOBuffer with.
     * If data is a number, it will be the new buffer's length<br>
     * If data is `undefined`, the buffer will be initialized with a default length of 8Kb<br>
     * If data is an ArrayBuffer, SharedArrayBuffer, an ArrayBufferView (Typed Array), an IOBuffer instance,
     * or a Node.js Buffer, a view will be created over the underlying ArrayBuffer.
     * @param options - An object for the options.
     * @returns A new IOBuffer instance.
     */
    constructor(data = defaultByteLength, options = {}) {
      /**
       * Reference to the internal ArrayBuffer object.
       */
      __publicField(this, "buffer");
      /**
       * Byte length of the internal ArrayBuffer.
       */
      __publicField(this, "byteLength");
      /**
       * Byte offset of the internal ArrayBuffer.
       */
      __publicField(this, "byteOffset");
      /**
       * Byte length of the internal ArrayBuffer.
       */
      __publicField(this, "length");
      /**
       * The current offset of the buffer's pointer.
       */
      __publicField(this, "offset");
      __publicField(this, "lastWrittenByte");
      __publicField(this, "littleEndian");
      __publicField(this, "_data");
      __publicField(this, "_mark");
      __publicField(this, "_marks");
      let dataIsGiven = false;
      if (typeof data === "number") {
        data = new ArrayBuffer(data);
      } else {
        dataIsGiven = true;
        this.lastWrittenByte = data.byteLength;
      }
      const offset = options.offset ? options.offset >>> 0 : 0;
      const byteLength = data.byteLength - offset;
      let dvOffset = offset;
      if (ArrayBuffer.isView(data) || data instanceof IOBuffer) {
        if (data.byteLength !== data.buffer.byteLength) {
          dvOffset = data.byteOffset + offset;
        }
        data = data.buffer;
      }
      if (dataIsGiven) {
        this.lastWrittenByte = byteLength;
      } else {
        this.lastWrittenByte = 0;
      }
      this.buffer = data;
      this.length = byteLength;
      this.byteLength = byteLength;
      this.byteOffset = dvOffset;
      this.offset = 0;
      this.littleEndian = true;
      this._data = new DataView(this.buffer, dvOffset, byteLength);
      this._mark = 0;
      this._marks = [];
    }
    /**
     * Checks if the memory allocated to the buffer is sufficient to store more
     * bytes after the offset.
     * @param byteLength - The needed memory in bytes.
     * @returns `true` if there is sufficient space and `false` otherwise.
     */
    available(byteLength = 1) {
      return this.offset + byteLength <= this.length;
    }
    /**
     * Check if little-endian mode is used for reading and writing multi-byte
     * values.
     * @returns `true` if little-endian mode is used, `false` otherwise.
     */
    isLittleEndian() {
      return this.littleEndian;
    }
    /**
     * Set little-endian mode for reading and writing multi-byte values.
     * @returns This.
     */
    setLittleEndian() {
      this.littleEndian = true;
      return this;
    }
    /**
     * Check if big-endian mode is used for reading and writing multi-byte values.
     * @returns `true` if big-endian mode is used, `false` otherwise.
     */
    isBigEndian() {
      return !this.littleEndian;
    }
    /**
     * Switches to big-endian mode for reading and writing multi-byte values.
     * @returns This.
     */
    setBigEndian() {
      this.littleEndian = false;
      return this;
    }
    /**
     * Move the pointer n bytes forward.
     * @param n - Number of bytes to skip.
     * @returns This.
     */
    skip(n2 = 1) {
      this.offset += n2;
      return this;
    }
    /**
     * Move the pointer n bytes backward.
     * @param n - Number of bytes to move back.
     * @returns This.
     */
    back(n2 = 1) {
      this.offset -= n2;
      return this;
    }
    /**
     * Move the pointer to the given offset.
     * @param offset - The offset to move to.
     * @returns This.
     */
    seek(offset) {
      this.offset = offset;
      return this;
    }
    /**
     * Store the current pointer offset.
     * @see {@link IOBuffer#reset}
     * @returns This.
     */
    mark() {
      this._mark = this.offset;
      return this;
    }
    /**
     * Move the pointer back to the last pointer offset set by mark.
     * @see {@link IOBuffer#mark}
     * @returns This.
     */
    reset() {
      this.offset = this._mark;
      return this;
    }
    /**
     * Push the current pointer offset to the mark stack.
     * @see {@link IOBuffer#popMark}
     * @returns This.
     */
    pushMark() {
      this._marks.push(this.offset);
      return this;
    }
    /**
     * Pop the last pointer offset from the mark stack, and set the current
     * pointer offset to the popped value.
     * @see {@link IOBuffer#pushMark}
     * @returns This.
     */
    popMark() {
      const offset = this._marks.pop();
      if (offset === void 0) {
        throw new Error("Mark stack empty");
      }
      this.seek(offset);
      return this;
    }
    /**
     * Move the pointer offset back to 0.
     * @returns This.
     */
    rewind() {
      this.offset = 0;
      return this;
    }
    /**
     * Make sure the buffer has sufficient memory to write a given byteLength at
     * the current pointer offset.
     * If the buffer's memory is insufficient, this method will create a new
     * buffer (a copy) with a length that is twice (byteLength + current offset).
     * @param byteLength - The needed memory in bytes.
     * @returns This.
     */
    ensureAvailable(byteLength = 1) {
      if (!this.available(byteLength)) {
        const lengthNeeded = this.offset + byteLength;
        const newLength = lengthNeeded * 2;
        const newArray = new Uint8Array(newLength);
        newArray.set(new Uint8Array(this.buffer));
        this.buffer = newArray.buffer;
        this.length = newLength;
        this.byteLength = newLength;
        this._data = new DataView(this.buffer);
      }
      return this;
    }
    /**
     * Read a byte and return false if the byte's value is 0, or true otherwise.
     * Moves pointer forward by one byte.
     * @returns The read boolean.
     */
    readBoolean() {
      return this.readUint8() !== 0;
    }
    /**
     * Read a signed 8-bit integer and move pointer forward by 1 byte.
     * @returns The read byte.
     */
    readInt8() {
      return this._data.getInt8(this.offset++);
    }
    /**
     * Read an unsigned 8-bit integer and move pointer forward by 1 byte.
     * @returns The read byte.
     */
    readUint8() {
      return this._data.getUint8(this.offset++);
    }
    /**
     * Alias for {@link IOBuffer#readUint8}.
     * @returns The read byte.
     */
    readByte() {
      return this.readUint8();
    }
    /**
     * Read `n` bytes and move pointer forward by `n` bytes.
     * @param n - Number of bytes to read.
     * @returns The read bytes.
     */
    readBytes(n2 = 1) {
      return this.readArray(n2, "uint8");
    }
    /**
     * Creates an array of corresponding to the type `type` and size `size`.
     * For example type `uint8` will create a `Uint8Array`.
     * @param size - size of the resulting array
     * @param type - number type of elements to read
     * @returns The read array.
     */
    readArray(size, type) {
      const bytes = typedArrays[type].BYTES_PER_ELEMENT * size;
      const offset = this.byteOffset + this.offset;
      const slice = this.buffer.slice(offset, offset + bytes);
      if (this.littleEndian === hostBigEndian && type !== "uint8" && type !== "int8") {
        const slice2 = new Uint8Array(this.buffer.slice(offset, offset + bytes));
        slice2.reverse();
        const returnArray2 = new typedArrays[type](slice2.buffer);
        this.offset += bytes;
        returnArray2.reverse();
        return returnArray2;
      }
      const returnArray = new typedArrays[type](slice);
      this.offset += bytes;
      return returnArray;
    }
    /**
     * Read a 16-bit signed integer and move pointer forward by 2 bytes.
     * @returns The read value.
     */
    readInt16() {
      const value = this._data.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    }
    /**
     * Read a 16-bit unsigned integer and move pointer forward by 2 bytes.
     * @returns The read value.
     */
    readUint16() {
      const value = this._data.getUint16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    }
    /**
     * Read a 32-bit signed integer and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readInt32() {
      const value = this._data.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    }
    /**
     * Read a 32-bit unsigned integer and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readUint32() {
      const value = this._data.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    }
    /**
     * Read a 32-bit floating number and move pointer forward by 4 bytes.
     * @returns The read value.
     */
    readFloat32() {
      const value = this._data.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    }
    /**
     * Read a 64-bit floating number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readFloat64() {
      const value = this._data.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    }
    /**
     * Read a 64-bit signed integer number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readBigInt64() {
      const value = this._data.getBigInt64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    }
    /**
     * Read a 64-bit unsigned integer number and move pointer forward by 8 bytes.
     * @returns The read value.
     */
    readBigUint64() {
      const value = this._data.getBigUint64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    }
    /**
     * Read a 1-byte ASCII character and move pointer forward by 1 byte.
     * @returns The read character.
     */
    readChar() {
      return String.fromCharCode(this.readInt8());
    }
    /**
     * Read `n` 1-byte ASCII characters and move pointer forward by `n` bytes.
     * @param n - Number of characters to read.
     * @returns The read characters.
     */
    readChars(n2 = 1) {
      let result = "";
      for (let i2 = 0; i2 < n2; i2++) {
        result += this.readChar();
      }
      return result;
    }
    /**
     * Read the next `n` bytes, return a UTF-8 decoded string and move pointer
     * forward by `n` bytes.
     * @param n - Number of bytes to read.
     * @returns The decoded string.
     */
    readUtf8(n2 = 1) {
      return decode$2(this.readBytes(n2));
    }
    /**
     * Read the next `n` bytes, return a string decoded with `encoding` and move pointer
     * forward by `n` bytes.
     * If no encoding is passed, the function is equivalent to @see {@link IOBuffer#readUtf8}
     * @param n - Number of bytes to read.
     * @param encoding - The encoding to use. Default is 'utf8'.
     * @returns The decoded string.
     */
    decodeText(n2 = 1, encoding = "utf8") {
      return decode$2(this.readBytes(n2), encoding);
    }
    /**
     * Write 0xff if the passed value is truthy, 0x00 otherwise and move pointer
     * forward by 1 byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeBoolean(value) {
      this.writeUint8(value ? 255 : 0);
      return this;
    }
    /**
     * Write `value` as an 8-bit signed integer and move pointer forward by 1 byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt8(value) {
      this.ensureAvailable(1);
      this._data.setInt8(this.offset++, value);
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as an 8-bit unsigned integer and move pointer forward by 1
     * byte.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint8(value) {
      this.ensureAvailable(1);
      this._data.setUint8(this.offset++, value);
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * An alias for {@link IOBuffer#writeUint8}.
     * @param value - The value to write.
     * @returns This.
     */
    writeByte(value) {
      return this.writeUint8(value);
    }
    /**
     * Write all elements of `bytes` as uint8 values and move pointer forward by
     * `bytes.length` bytes.
     * @param bytes - The array of bytes to write.
     * @returns This.
     */
    writeBytes(bytes) {
      this.ensureAvailable(bytes.length);
      for (let i2 = 0; i2 < bytes.length; i2++) {
        this._data.setUint8(this.offset++, bytes[i2]);
      }
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 16-bit signed integer and move pointer forward by 2
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt16(value) {
      this.ensureAvailable(2);
      this._data.setInt16(this.offset, value, this.littleEndian);
      this.offset += 2;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 16-bit unsigned integer and move pointer forward by 2
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint16(value) {
      this.ensureAvailable(2);
      this._data.setUint16(this.offset, value, this.littleEndian);
      this.offset += 2;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 32-bit signed integer and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeInt32(value) {
      this.ensureAvailable(4);
      this._data.setInt32(this.offset, value, this.littleEndian);
      this.offset += 4;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 32-bit unsigned integer and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeUint32(value) {
      this.ensureAvailable(4);
      this._data.setUint32(this.offset, value, this.littleEndian);
      this.offset += 4;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 32-bit floating number and move pointer forward by 4
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeFloat32(value) {
      this.ensureAvailable(4);
      this._data.setFloat32(this.offset, value, this.littleEndian);
      this.offset += 4;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 64-bit floating number and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeFloat64(value) {
      this.ensureAvailable(8);
      this._data.setFloat64(this.offset, value, this.littleEndian);
      this.offset += 8;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 64-bit signed bigint and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeBigInt64(value) {
      this.ensureAvailable(8);
      this._data.setBigInt64(this.offset, value, this.littleEndian);
      this.offset += 8;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write `value` as a 64-bit unsigned bigint and move pointer forward by 8
     * bytes.
     * @param value - The value to write.
     * @returns This.
     */
    writeBigUint64(value) {
      this.ensureAvailable(8);
      this._data.setBigUint64(this.offset, value, this.littleEndian);
      this.offset += 8;
      this._updateLastWrittenByte();
      return this;
    }
    /**
     * Write the charCode of `str`'s first character as an 8-bit unsigned integer
     * and move pointer forward by 1 byte.
     * @param str - The character to write.
     * @returns This.
     */
    writeChar(str) {
      return this.writeUint8(str.charCodeAt(0));
    }
    /**
     * Write the charCodes of all `str`'s characters as 8-bit unsigned integers
     * and move pointer forward by `str.length` bytes.
     * @param str - The characters to write.
     * @returns This.
     */
    writeChars(str) {
      for (let i2 = 0; i2 < str.length; i2++) {
        this.writeUint8(str.charCodeAt(i2));
      }
      return this;
    }
    /**
     * UTF-8 encode and write `str` to the current pointer offset and move pointer
     * forward according to the encoded length.
     * @param str - The string to write.
     * @returns This.
     */
    writeUtf8(str) {
      return this.writeBytes(encode(str));
    }
    /**
     * Export a Uint8Array view of the internal buffer.
     * The view starts at the byte offset and its length
     * is calculated to stop at the last written byte or the original length.
     * @returns A new Uint8Array view.
     */
    toArray() {
      return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte);
    }
    /**
     *  Get the total number of bytes written so far, regardless of the current offset.
     * @returns - Total number of bytes.
     */
    getWrittenByteLength() {
      return this.lastWrittenByte - this.byteOffset;
    }
    /**
     * Update the last written byte offset
     * @private
     */
    _updateLastWrittenByte() {
      if (this.offset > this.lastWrittenByte) {
        this.lastWrittenByte = this.offset;
      }
    }
  }
  function zero$1(buf) {
    let len = buf.length;
    while (--len >= 0) {
      buf[len] = 0;
    }
  }
  const MIN_MATCH$1 = 3;
  const MAX_MATCH$1 = 258;
  const LENGTH_CODES$1 = 29;
  const LITERALS$1 = 256;
  const L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
  const D_CODES$1 = 30;
  const DIST_CODE_LEN = 512;
  const static_ltree = new Array((L_CODES$1 + 2) * 2);
  zero$1(static_ltree);
  const static_dtree = new Array(D_CODES$1 * 2);
  zero$1(static_dtree);
  const _dist_code = new Array(DIST_CODE_LEN);
  zero$1(_dist_code);
  const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
  zero$1(_length_code);
  const base_length = new Array(LENGTH_CODES$1);
  zero$1(base_length);
  const base_dist = new Array(D_CODES$1);
  zero$1(base_dist);
  const adler32 = (adler2, buf, len, pos) => {
    let s1 = adler2 & 65535 | 0, s2 = adler2 >>> 16 & 65535 | 0, n2 = 0;
    while (len !== 0) {
      n2 = len > 2e3 ? 2e3 : len;
      len -= n2;
      do {
        s1 = s1 + buf[pos++] | 0;
        s2 = s2 + s1 | 0;
      } while (--n2);
      s1 %= 65521;
      s2 %= 65521;
    }
    return s1 | s2 << 16 | 0;
  };
  var adler32_1 = adler32;
  const makeTable = () => {
    let c2, table = [];
    for (var n2 = 0; n2 < 256; n2++) {
      c2 = n2;
      for (var k2 = 0; k2 < 8; k2++) {
        c2 = c2 & 1 ? 3988292384 ^ c2 >>> 1 : c2 >>> 1;
      }
      table[n2] = c2;
    }
    return table;
  };
  const crcTable$1 = new Uint32Array(makeTable());
  const crc32 = (crc2, buf, len, pos) => {
    const t2 = crcTable$1;
    const end = pos + len;
    crc2 ^= -1;
    for (let i2 = pos; i2 < end; i2++) {
      crc2 = crc2 >>> 8 ^ t2[(crc2 ^ buf[i2]) & 255];
    }
    return crc2 ^ -1;
  };
  var crc32_1 = crc32;
  var messages = {
    2: "need dictionary",
    /* Z_NEED_DICT       2  */
    1: "stream end",
    /* Z_STREAM_END      1  */
    0: "",
    /* Z_OK              0  */
    "-1": "file error",
    /* Z_ERRNO         (-1) */
    "-2": "stream error",
    /* Z_STREAM_ERROR  (-2) */
    "-3": "data error",
    /* Z_DATA_ERROR    (-3) */
    "-4": "insufficient memory",
    /* Z_MEM_ERROR     (-4) */
    "-5": "buffer error",
    /* Z_BUF_ERROR     (-5) */
    "-6": "incompatible version"
    /* Z_VERSION_ERROR (-6) */
  };
  var constants$2 = {
    /* Allowed flush values; see deflate() and inflate() below for details */
    Z_NO_FLUSH: 0,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    /* Return codes for the compression/decompression functions. Negative values
    * are errors, positive values are used for special but normal events.
    */
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    /* The deflate compression method */
    Z_DEFLATED: 8
    //Z_NULL:                 null // Use -1 or null inline, depending on var type
  };
  const _has = (obj, key) => {
    return Object.prototype.hasOwnProperty.call(obj, key);
  };
  var assign = function(obj) {
    const sources = Array.prototype.slice.call(arguments, 1);
    while (sources.length) {
      const source = sources.shift();
      if (!source) {
        continue;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be non-object");
      }
      for (const p2 in source) {
        if (_has(source, p2)) {
          obj[p2] = source[p2];
        }
      }
    }
    return obj;
  };
  var flattenChunks = (chunks) => {
    let len = 0;
    for (let i2 = 0, l2 = chunks.length; i2 < l2; i2++) {
      len += chunks[i2].length;
    }
    const result = new Uint8Array(len);
    for (let i2 = 0, pos = 0, l2 = chunks.length; i2 < l2; i2++) {
      let chunk = chunks[i2];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  };
  var common = {
    assign,
    flattenChunks
  };
  let STR_APPLY_UIA_OK = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (__) {
    STR_APPLY_UIA_OK = false;
  }
  const _utf8len = new Uint8Array(256);
  for (let q2 = 0; q2 < 256; q2++) {
    _utf8len[q2] = q2 >= 252 ? 6 : q2 >= 248 ? 5 : q2 >= 240 ? 4 : q2 >= 224 ? 3 : q2 >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  var string2buf = (str) => {
    if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
      return new TextEncoder().encode(str);
    }
    let buf, c2, c22, m_pos, i2, str_len = str.length, buf_len = 0;
    for (m_pos = 0; m_pos < str_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      buf_len += c2 < 128 ? 1 : c2 < 2048 ? 2 : c2 < 65536 ? 3 : 4;
    }
    buf = new Uint8Array(buf_len);
    for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
      c2 = str.charCodeAt(m_pos);
      if ((c2 & 64512) === 55296 && m_pos + 1 < str_len) {
        c22 = str.charCodeAt(m_pos + 1);
        if ((c22 & 64512) === 56320) {
          c2 = 65536 + (c2 - 55296 << 10) + (c22 - 56320);
          m_pos++;
        }
      }
      if (c2 < 128) {
        buf[i2++] = c2;
      } else if (c2 < 2048) {
        buf[i2++] = 192 | c2 >>> 6;
        buf[i2++] = 128 | c2 & 63;
      } else if (c2 < 65536) {
        buf[i2++] = 224 | c2 >>> 12;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      } else {
        buf[i2++] = 240 | c2 >>> 18;
        buf[i2++] = 128 | c2 >>> 12 & 63;
        buf[i2++] = 128 | c2 >>> 6 & 63;
        buf[i2++] = 128 | c2 & 63;
      }
    }
    return buf;
  };
  const buf2binstring = (buf, len) => {
    if (len < 65534) {
      if (buf.subarray && STR_APPLY_UIA_OK) {
        return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
      }
    }
    let result = "";
    for (let i2 = 0; i2 < len; i2++) {
      result += String.fromCharCode(buf[i2]);
    }
    return result;
  };
  var buf2string = (buf, max) => {
    const len = max || buf.length;
    if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
      return new TextDecoder().decode(buf.subarray(0, max));
    }
    let i2, out;
    const utf16buf = new Array(len * 2);
    for (out = 0, i2 = 0; i2 < len; ) {
      let c2 = buf[i2++];
      if (c2 < 128) {
        utf16buf[out++] = c2;
        continue;
      }
      let c_len = _utf8len[c2];
      if (c_len > 4) {
        utf16buf[out++] = 65533;
        i2 += c_len - 1;
        continue;
      }
      c2 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
      while (c_len > 1 && i2 < len) {
        c2 = c2 << 6 | buf[i2++] & 63;
        c_len--;
      }
      if (c_len > 1) {
        utf16buf[out++] = 65533;
        continue;
      }
      if (c2 < 65536) {
        utf16buf[out++] = c2;
      } else {
        c2 -= 65536;
        utf16buf[out++] = 55296 | c2 >> 10 & 1023;
        utf16buf[out++] = 56320 | c2 & 1023;
      }
    }
    return buf2binstring(utf16buf, out);
  };
  var utf8border = (buf, max) => {
    max = max || buf.length;
    if (max > buf.length) {
      max = buf.length;
    }
    let pos = max - 1;
    while (pos >= 0 && (buf[pos] & 192) === 128) {
      pos--;
    }
    if (pos < 0) {
      return max;
    }
    if (pos === 0) {
      return max;
    }
    return pos + _utf8len[buf[pos]] > max ? pos : max;
  };
  var strings = {
    string2buf,
    buf2string,
    utf8border
  };
  function ZStream() {
    this.input = null;
    this.next_in = 0;
    this.avail_in = 0;
    this.total_in = 0;
    this.output = null;
    this.next_out = 0;
    this.avail_out = 0;
    this.total_out = 0;
    this.msg = "";
    this.state = null;
    this.data_type = 2;
    this.adler = 0;
  }
  var zstream = ZStream;
  const BAD$1 = 16209;
  const TYPE$1 = 16191;
  var inffast = function inflate_fast(strm, start) {
    let _in;
    let last;
    let _out;
    let beg;
    let end;
    let dmax;
    let wsize;
    let whave;
    let wnext;
    let s_window;
    let hold;
    let bits;
    let lcode;
    let dcode;
    let lmask;
    let dmask;
    let here;
    let op;
    let len;
    let dist;
    let from;
    let from_source;
    let input, output;
    const state2 = strm.state;
    _in = strm.next_in;
    input = strm.input;
    last = _in + (strm.avail_in - 5);
    _out = strm.next_out;
    output = strm.output;
    beg = _out - (start - strm.avail_out);
    end = _out + (strm.avail_out - 257);
    dmax = state2.dmax;
    wsize = state2.wsize;
    whave = state2.whave;
    wnext = state2.wnext;
    s_window = state2.window;
    hold = state2.hold;
    bits = state2.bits;
    lcode = state2.lencode;
    dcode = state2.distcode;
    lmask = (1 << state2.lenbits) - 1;
    dmask = (1 << state2.distbits) - 1;
    top:
      do {
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = lcode[hold & lmask];
        dolen:
          for (; ; ) {
            op = here >>> 24;
            hold >>>= op;
            bits -= op;
            op = here >>> 16 & 255;
            if (op === 0) {
              output[_out++] = here & 65535;
            } else if (op & 16) {
              len = here & 65535;
              op &= 15;
              if (op) {
                if (bits < op) {
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                len += hold & (1 << op) - 1;
                hold >>>= op;
                bits -= op;
              }
              if (bits < 15) {
                hold += input[_in++] << bits;
                bits += 8;
                hold += input[_in++] << bits;
                bits += 8;
              }
              here = dcode[hold & dmask];
              dodist:
                for (; ; ) {
                  op = here >>> 24;
                  hold >>>= op;
                  bits -= op;
                  op = here >>> 16 & 255;
                  if (op & 16) {
                    dist = here & 65535;
                    op &= 15;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                      }
                    }
                    dist += hold & (1 << op) - 1;
                    if (dist > dmax) {
                      strm.msg = "invalid distance too far back";
                      state2.mode = BAD$1;
                      break top;
                    }
                    hold >>>= op;
                    bits -= op;
                    op = _out - beg;
                    if (dist > op) {
                      op = dist - op;
                      if (op > whave) {
                        if (state2.sane) {
                          strm.msg = "invalid distance too far back";
                          state2.mode = BAD$1;
                          break top;
                        }
                      }
                      from = 0;
                      from_source = s_window;
                      if (wnext === 0) {
                        from += wsize - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      } else if (wnext < op) {
                        from += wsize + wnext - op;
                        op -= wnext;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = 0;
                          if (wnext < len) {
                            op = wnext;
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                      } else {
                        from += wnext - op;
                        if (op < len) {
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                      while (len > 2) {
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        output[_out++] = from_source[from++];
                        len -= 3;
                      }
                      if (len) {
                        output[_out++] = from_source[from++];
                        if (len > 1) {
                          output[_out++] = from_source[from++];
                        }
                      }
                    } else {
                      from = _out - dist;
                      do {
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        output[_out++] = output[from++];
                        len -= 3;
                      } while (len > 2);
                      if (len) {
                        output[_out++] = output[from++];
                        if (len > 1) {
                          output[_out++] = output[from++];
                        }
                      }
                    }
                  } else if ((op & 64) === 0) {
                    here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                    continue dodist;
                  } else {
                    strm.msg = "invalid distance code";
                    state2.mode = BAD$1;
                    break top;
                  }
                  break;
                }
            } else if ((op & 64) === 0) {
              here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
              continue dolen;
            } else if (op & 32) {
              state2.mode = TYPE$1;
              break top;
            } else {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD$1;
              break top;
            }
            break;
          }
      } while (_in < last && _out < end);
    len = bits >> 3;
    _in -= len;
    bits -= len << 3;
    hold &= (1 << bits) - 1;
    strm.next_in = _in;
    strm.next_out = _out;
    strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
    strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
    state2.hold = hold;
    state2.bits = bits;
    return;
  };
  const MAXBITS = 15;
  const ENOUGH_LENS$1 = 852;
  const ENOUGH_DISTS$1 = 592;
  const CODES$1 = 0;
  const LENS$1 = 1;
  const DISTS$1 = 2;
  const lbase = new Uint16Array([
    /* Length codes 257..285 base */
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    13,
    15,
    17,
    19,
    23,
    27,
    31,
    35,
    43,
    51,
    59,
    67,
    83,
    99,
    115,
    131,
    163,
    195,
    227,
    258,
    0,
    0
  ]);
  const lext = new Uint8Array([
    /* Length codes 257..285 extra */
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    16,
    17,
    17,
    17,
    17,
    18,
    18,
    18,
    18,
    19,
    19,
    19,
    19,
    20,
    20,
    20,
    20,
    21,
    21,
    21,
    21,
    16,
    72,
    78
  ]);
  const dbase = new Uint16Array([
    /* Distance codes 0..29 base */
    1,
    2,
    3,
    4,
    5,
    7,
    9,
    13,
    17,
    25,
    33,
    49,
    65,
    97,
    129,
    193,
    257,
    385,
    513,
    769,
    1025,
    1537,
    2049,
    3073,
    4097,
    6145,
    8193,
    12289,
    16385,
    24577,
    0,
    0
  ]);
  const dext = new Uint8Array([
    /* Distance codes 0..29 extra */
    16,
    16,
    16,
    16,
    17,
    17,
    18,
    18,
    19,
    19,
    20,
    20,
    21,
    21,
    22,
    22,
    23,
    23,
    24,
    24,
    25,
    25,
    26,
    26,
    27,
    27,
    28,
    28,
    29,
    29,
    64,
    64
  ]);
  const inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {
    const bits = opts.bits;
    let len = 0;
    let sym = 0;
    let min = 0, max = 0;
    let root = 0;
    let curr = 0;
    let drop = 0;
    let left = 0;
    let used = 0;
    let huff = 0;
    let incr;
    let fill;
    let low;
    let mask;
    let next;
    let base = null;
    let match;
    const count = new Uint16Array(MAXBITS + 1);
    const offs = new Uint16Array(MAXBITS + 1);
    let extra = null;
    let here_bits, here_op, here_val;
    for (len = 0; len <= MAXBITS; len++) {
      count[len] = 0;
    }
    for (sym = 0; sym < codes; sym++) {
      count[lens[lens_index + sym]]++;
    }
    root = bits;
    for (max = MAXBITS; max >= 1; max--) {
      if (count[max] !== 0) {
        break;
      }
    }
    if (root > max) {
      root = max;
    }
    if (max === 0) {
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      table[table_index++] = 1 << 24 | 64 << 16 | 0;
      opts.bits = 1;
      return 0;
    }
    for (min = 1; min < max; min++) {
      if (count[min] !== 0) {
        break;
      }
    }
    if (root < min) {
      root = min;
    }
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
      left <<= 1;
      left -= count[len];
      if (left < 0) {
        return -1;
      }
    }
    if (left > 0 && (type === CODES$1 || max !== 1)) {
      return -1;
    }
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++) {
      offs[len + 1] = offs[len] + count[len];
    }
    for (sym = 0; sym < codes; sym++) {
      if (lens[lens_index + sym] !== 0) {
        work[offs[lens[lens_index + sym]]++] = sym;
      }
    }
    if (type === CODES$1) {
      base = extra = work;
      match = 20;
    } else if (type === LENS$1) {
      base = lbase;
      extra = lext;
      match = 257;
    } else {
      base = dbase;
      extra = dext;
      match = 0;
    }
    huff = 0;
    sym = 0;
    len = min;
    next = table_index;
    curr = root;
    drop = 0;
    low = -1;
    used = 1 << root;
    mask = used - 1;
    if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
      return 1;
    }
    for (; ; ) {
      here_bits = len - drop;
      if (work[sym] + 1 < match) {
        here_op = 0;
        here_val = work[sym];
      } else if (work[sym] >= match) {
        here_op = extra[work[sym] - match];
        here_val = base[work[sym] - match];
      } else {
        here_op = 32 + 64;
        here_val = 0;
      }
      incr = 1 << len - drop;
      fill = 1 << curr;
      min = fill;
      do {
        fill -= incr;
        table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
      } while (fill !== 0);
      incr = 1 << len - 1;
      while (huff & incr) {
        incr >>= 1;
      }
      if (incr !== 0) {
        huff &= incr - 1;
        huff += incr;
      } else {
        huff = 0;
      }
      sym++;
      if (--count[len] === 0) {
        if (len === max) {
          break;
        }
        len = lens[lens_index + work[sym]];
      }
      if (len > root && (huff & mask) !== low) {
        if (drop === 0) {
          drop = root;
        }
        next += min;
        curr = len - drop;
        left = 1 << curr;
        while (curr + drop < max) {
          left -= count[curr + drop];
          if (left <= 0) {
            break;
          }
          curr++;
          left <<= 1;
        }
        used += 1 << curr;
        if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {
          return 1;
        }
        low = huff & mask;
        table[low] = root << 24 | curr << 16 | next - table_index | 0;
      }
    }
    if (huff !== 0) {
      table[next + huff] = len - drop << 24 | 64 << 16 | 0;
    }
    opts.bits = root;
    return 0;
  };
  var inftrees = inflate_table;
  const CODES = 0;
  const LENS = 1;
  const DISTS = 2;
  const {
    Z_FINISH: Z_FINISH$1,
    Z_BLOCK,
    Z_TREES,
    Z_OK: Z_OK$1,
    Z_STREAM_END: Z_STREAM_END$1,
    Z_NEED_DICT: Z_NEED_DICT$1,
    Z_STREAM_ERROR: Z_STREAM_ERROR$1,
    Z_DATA_ERROR: Z_DATA_ERROR$1,
    Z_MEM_ERROR: Z_MEM_ERROR$1,
    Z_BUF_ERROR,
    Z_DEFLATED
  } = constants$2;
  const HEAD = 16180;
  const FLAGS = 16181;
  const TIME = 16182;
  const OS = 16183;
  const EXLEN = 16184;
  const EXTRA = 16185;
  const NAME = 16186;
  const COMMENT = 16187;
  const HCRC = 16188;
  const DICTID = 16189;
  const DICT = 16190;
  const TYPE = 16191;
  const TYPEDO = 16192;
  const STORED = 16193;
  const COPY_ = 16194;
  const COPY = 16195;
  const TABLE = 16196;
  const LENLENS = 16197;
  const CODELENS = 16198;
  const LEN_ = 16199;
  const LEN = 16200;
  const LENEXT = 16201;
  const DIST = 16202;
  const DISTEXT = 16203;
  const MATCH = 16204;
  const LIT = 16205;
  const CHECK = 16206;
  const LENGTH = 16207;
  const DONE = 16208;
  const BAD = 16209;
  const MEM = 16210;
  const SYNC = 16211;
  const ENOUGH_LENS = 852;
  const ENOUGH_DISTS = 592;
  const MAX_WBITS = 15;
  const DEF_WBITS = MAX_WBITS;
  const zswap32 = (q2) => {
    return (q2 >>> 24 & 255) + (q2 >>> 8 & 65280) + ((q2 & 65280) << 8) + ((q2 & 255) << 24);
  };
  function InflateState() {
    this.strm = null;
    this.mode = 0;
    this.last = false;
    this.wrap = 0;
    this.havedict = false;
    this.flags = 0;
    this.dmax = 0;
    this.check = 0;
    this.total = 0;
    this.head = null;
    this.wbits = 0;
    this.wsize = 0;
    this.whave = 0;
    this.wnext = 0;
    this.window = null;
    this.hold = 0;
    this.bits = 0;
    this.length = 0;
    this.offset = 0;
    this.extra = 0;
    this.lencode = null;
    this.distcode = null;
    this.lenbits = 0;
    this.distbits = 0;
    this.ncode = 0;
    this.nlen = 0;
    this.ndist = 0;
    this.have = 0;
    this.next = null;
    this.lens = new Uint16Array(320);
    this.work = new Uint16Array(288);
    this.lendyn = null;
    this.distdyn = null;
    this.sane = 0;
    this.back = 0;
    this.was = 0;
  }
  const inflateStateCheck = (strm) => {
    if (!strm) {
      return 1;
    }
    const state2 = strm.state;
    if (!state2 || state2.strm !== strm || state2.mode < HEAD || state2.mode > SYNC) {
      return 1;
    }
    return 0;
  };
  const inflateResetKeep = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state2 = strm.state;
    strm.total_in = strm.total_out = state2.total = 0;
    strm.msg = "";
    if (state2.wrap) {
      strm.adler = state2.wrap & 1;
    }
    state2.mode = HEAD;
    state2.last = 0;
    state2.havedict = 0;
    state2.flags = -1;
    state2.dmax = 32768;
    state2.head = null;
    state2.hold = 0;
    state2.bits = 0;
    state2.lencode = state2.lendyn = new Int32Array(ENOUGH_LENS);
    state2.distcode = state2.distdyn = new Int32Array(ENOUGH_DISTS);
    state2.sane = 1;
    state2.back = -1;
    return Z_OK$1;
  };
  const inflateReset = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state2 = strm.state;
    state2.wsize = 0;
    state2.whave = 0;
    state2.wnext = 0;
    return inflateResetKeep(strm);
  };
  const inflateReset2 = (strm, windowBits) => {
    let wrap;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state2 = strm.state;
    if (windowBits < 0) {
      wrap = 0;
      windowBits = -windowBits;
    } else {
      wrap = (windowBits >> 4) + 5;
      if (windowBits < 48) {
        windowBits &= 15;
      }
    }
    if (windowBits && (windowBits < 8 || windowBits > 15)) {
      return Z_STREAM_ERROR$1;
    }
    if (state2.window !== null && state2.wbits !== windowBits) {
      state2.window = null;
    }
    state2.wrap = wrap;
    state2.wbits = windowBits;
    return inflateReset(strm);
  };
  const inflateInit2 = (strm, windowBits) => {
    if (!strm) {
      return Z_STREAM_ERROR$1;
    }
    const state2 = new InflateState();
    strm.state = state2;
    state2.strm = strm;
    state2.window = null;
    state2.mode = HEAD;
    const ret = inflateReset2(strm, windowBits);
    if (ret !== Z_OK$1) {
      strm.state = null;
    }
    return ret;
  };
  const inflateInit = (strm) => {
    return inflateInit2(strm, DEF_WBITS);
  };
  let virgin = true;
  let lenfix, distfix;
  const fixedtables = (state2) => {
    if (virgin) {
      lenfix = new Int32Array(512);
      distfix = new Int32Array(32);
      let sym = 0;
      while (sym < 144) {
        state2.lens[sym++] = 8;
      }
      while (sym < 256) {
        state2.lens[sym++] = 9;
      }
      while (sym < 280) {
        state2.lens[sym++] = 7;
      }
      while (sym < 288) {
        state2.lens[sym++] = 8;
      }
      inftrees(LENS, state2.lens, 0, 288, lenfix, 0, state2.work, { bits: 9 });
      sym = 0;
      while (sym < 32) {
        state2.lens[sym++] = 5;
      }
      inftrees(DISTS, state2.lens, 0, 32, distfix, 0, state2.work, { bits: 5 });
      virgin = false;
    }
    state2.lencode = lenfix;
    state2.lenbits = 9;
    state2.distcode = distfix;
    state2.distbits = 5;
  };
  const updatewindow = (strm, src, end, copy) => {
    let dist;
    const state2 = strm.state;
    if (state2.window === null) {
      state2.wsize = 1 << state2.wbits;
      state2.wnext = 0;
      state2.whave = 0;
      state2.window = new Uint8Array(state2.wsize);
    }
    if (copy >= state2.wsize) {
      state2.window.set(src.subarray(end - state2.wsize, end), 0);
      state2.wnext = 0;
      state2.whave = state2.wsize;
    } else {
      dist = state2.wsize - state2.wnext;
      if (dist > copy) {
        dist = copy;
      }
      state2.window.set(src.subarray(end - copy, end - copy + dist), state2.wnext);
      copy -= dist;
      if (copy) {
        state2.window.set(src.subarray(end - copy, end), 0);
        state2.wnext = copy;
        state2.whave = state2.wsize;
      } else {
        state2.wnext += dist;
        if (state2.wnext === state2.wsize) {
          state2.wnext = 0;
        }
        if (state2.whave < state2.wsize) {
          state2.whave += dist;
        }
      }
    }
    return 0;
  };
  const inflate$2 = (strm, flush) => {
    let state2;
    let input, output;
    let next;
    let put;
    let have, left;
    let hold;
    let bits;
    let _in, _out;
    let copy;
    let from;
    let from_source;
    let here = 0;
    let here_bits, here_op, here_val;
    let last_bits, last_op, last_val;
    let len;
    let ret;
    const hbuf = new Uint8Array(4);
    let opts;
    let n2;
    const order = (
      /* permutation of code lengths */
      new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
    );
    if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
      return Z_STREAM_ERROR$1;
    }
    state2 = strm.state;
    if (state2.mode === TYPE) {
      state2.mode = TYPEDO;
    }
    put = strm.next_out;
    output = strm.output;
    left = strm.avail_out;
    next = strm.next_in;
    input = strm.input;
    have = strm.avail_in;
    hold = state2.hold;
    bits = state2.bits;
    _in = have;
    _out = left;
    ret = Z_OK$1;
    inf_leave:
      for (; ; ) {
        switch (state2.mode) {
          case HEAD:
            if (state2.wrap === 0) {
              state2.mode = TYPEDO;
              break;
            }
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.wrap & 2 && hold === 35615) {
              if (state2.wbits === 0) {
                state2.wbits = 15;
              }
              state2.check = 0;
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
              hold = 0;
              bits = 0;
              state2.mode = FLAGS;
              break;
            }
            if (state2.head) {
              state2.head.done = false;
            }
            if (!(state2.wrap & 1) || /* check if zlib header allowed */
            (((hold & 255) << 8) + (hold >> 8)) % 31) {
              strm.msg = "incorrect header check";
              state2.mode = BAD;
              break;
            }
            if ((hold & 15) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            hold >>>= 4;
            bits -= 4;
            len = (hold & 15) + 8;
            if (state2.wbits === 0) {
              state2.wbits = len;
            }
            if (len > 15 || len > state2.wbits) {
              strm.msg = "invalid window size";
              state2.mode = BAD;
              break;
            }
            state2.dmax = 1 << state2.wbits;
            state2.flags = 0;
            strm.adler = state2.check = 1;
            state2.mode = hold & 512 ? DICTID : TYPE;
            hold = 0;
            bits = 0;
            break;
          case FLAGS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.flags = hold;
            if ((state2.flags & 255) !== Z_DEFLATED) {
              strm.msg = "unknown compression method";
              state2.mode = BAD;
              break;
            }
            if (state2.flags & 57344) {
              strm.msg = "unknown header flags set";
              state2.mode = BAD;
              break;
            }
            if (state2.head) {
              state2.head.text = hold >> 8 & 1;
            }
            if (state2.flags & 512 && state2.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = TIME;
          /* falls through */
          case TIME:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.time = hold;
            }
            if (state2.flags & 512 && state2.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              hbuf[2] = hold >>> 16 & 255;
              hbuf[3] = hold >>> 24 & 255;
              state2.check = crc32_1(state2.check, hbuf, 4, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = OS;
          /* falls through */
          case OS:
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state2.head) {
              state2.head.xflags = hold & 255;
              state2.head.os = hold >> 8;
            }
            if (state2.flags & 512 && state2.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state2.check = crc32_1(state2.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
            state2.mode = EXLEN;
          /* falls through */
          case EXLEN:
            if (state2.flags & 1024) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length = hold;
              if (state2.head) {
                state2.head.extra_len = hold;
              }
              if (state2.flags & 512 && state2.wrap & 4) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state2.check = crc32_1(state2.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
            } else if (state2.head) {
              state2.head.extra = null;
            }
            state2.mode = EXTRA;
          /* falls through */
          case EXTRA:
            if (state2.flags & 1024) {
              copy = state2.length;
              if (copy > have) {
                copy = have;
              }
              if (copy) {
                if (state2.head) {
                  len = state2.head.extra_len - state2.length;
                  if (!state2.head.extra) {
                    state2.head.extra = new Uint8Array(state2.head.extra_len);
                  }
                  state2.head.extra.set(
                    input.subarray(
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      next + copy
                    ),
                    /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                    len
                  );
                }
                if (state2.flags & 512 && state2.wrap & 4) {
                  state2.check = crc32_1(state2.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                state2.length -= copy;
              }
              if (state2.length) {
                break inf_leave;
              }
            }
            state2.length = 0;
            state2.mode = NAME;
          /* falls through */
          case NAME:
            if (state2.flags & 2048) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.name += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state2.flags & 512 && state2.wrap & 4) {
                state2.check = crc32_1(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.name = null;
            }
            state2.length = 0;
            state2.mode = COMMENT;
          /* falls through */
          case COMMENT:
            if (state2.flags & 4096) {
              if (have === 0) {
                break inf_leave;
              }
              copy = 0;
              do {
                len = input[next + copy++];
                if (state2.head && len && state2.length < 65536) {
                  state2.head.comment += String.fromCharCode(len);
                }
              } while (len && copy < have);
              if (state2.flags & 512 && state2.wrap & 4) {
                state2.check = crc32_1(state2.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              if (len) {
                break inf_leave;
              }
            } else if (state2.head) {
              state2.head.comment = null;
            }
            state2.mode = HCRC;
          /* falls through */
          case HCRC:
            if (state2.flags & 512) {
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 4 && hold !== (state2.check & 65535)) {
                strm.msg = "header crc mismatch";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            if (state2.head) {
              state2.head.hcrc = state2.flags >> 9 & 1;
              state2.head.done = true;
            }
            strm.adler = state2.check = 0;
            state2.mode = TYPE;
            break;
          case DICTID:
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            strm.adler = state2.check = zswap32(hold);
            hold = 0;
            bits = 0;
            state2.mode = DICT;
          /* falls through */
          case DICT:
            if (state2.havedict === 0) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              return Z_NEED_DICT$1;
            }
            strm.adler = state2.check = 1;
            state2.mode = TYPE;
          /* falls through */
          case TYPE:
            if (flush === Z_BLOCK || flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case TYPEDO:
            if (state2.last) {
              hold >>>= bits & 7;
              bits -= bits & 7;
              state2.mode = CHECK;
              break;
            }
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.last = hold & 1;
            hold >>>= 1;
            bits -= 1;
            switch (hold & 3) {
              case 0:
                state2.mode = STORED;
                break;
              case 1:
                fixedtables(state2);
                state2.mode = LEN_;
                if (flush === Z_TREES) {
                  hold >>>= 2;
                  bits -= 2;
                  break inf_leave;
                }
                break;
              case 2:
                state2.mode = TABLE;
                break;
              case 3:
                strm.msg = "invalid block type";
                state2.mode = BAD;
            }
            hold >>>= 2;
            bits -= 2;
            break;
          case STORED:
            hold >>>= bits & 7;
            bits -= bits & 7;
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
              strm.msg = "invalid stored block lengths";
              state2.mode = BAD;
              break;
            }
            state2.length = hold & 65535;
            hold = 0;
            bits = 0;
            state2.mode = COPY_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case COPY_:
            state2.mode = COPY;
          /* falls through */
          case COPY:
            copy = state2.length;
            if (copy) {
              if (copy > have) {
                copy = have;
              }
              if (copy > left) {
                copy = left;
              }
              if (copy === 0) {
                break inf_leave;
              }
              output.set(input.subarray(next, next + copy), put);
              have -= copy;
              next += copy;
              left -= copy;
              put += copy;
              state2.length -= copy;
              break;
            }
            state2.mode = TYPE;
            break;
          case TABLE:
            while (bits < 14) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state2.nlen = (hold & 31) + 257;
            hold >>>= 5;
            bits -= 5;
            state2.ndist = (hold & 31) + 1;
            hold >>>= 5;
            bits -= 5;
            state2.ncode = (hold & 15) + 4;
            hold >>>= 4;
            bits -= 4;
            if (state2.nlen > 286 || state2.ndist > 30) {
              strm.msg = "too many length or distance symbols";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = LENLENS;
          /* falls through */
          case LENLENS:
            while (state2.have < state2.ncode) {
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.lens[order[state2.have++]] = hold & 7;
              hold >>>= 3;
              bits -= 3;
            }
            while (state2.have < 19) {
              state2.lens[order[state2.have++]] = 0;
            }
            state2.lencode = state2.lendyn;
            state2.lenbits = 7;
            opts = { bits: state2.lenbits };
            ret = inftrees(CODES, state2.lens, 0, 19, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid code lengths set";
              state2.mode = BAD;
              break;
            }
            state2.have = 0;
            state2.mode = CODELENS;
          /* falls through */
          case CODELENS:
            while (state2.have < state2.nlen + state2.ndist) {
              for (; ; ) {
                here = state2.lencode[hold & (1 << state2.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_val < 16) {
                hold >>>= here_bits;
                bits -= here_bits;
                state2.lens[state2.have++] = here_val;
              } else {
                if (here_val === 16) {
                  n2 = here_bits + 2;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  if (state2.have === 0) {
                    strm.msg = "invalid bit length repeat";
                    state2.mode = BAD;
                    break;
                  }
                  len = state2.lens[state2.have - 1];
                  copy = 3 + (hold & 3);
                  hold >>>= 2;
                  bits -= 2;
                } else if (here_val === 17) {
                  n2 = here_bits + 3;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 3 + (hold & 7);
                  hold >>>= 3;
                  bits -= 3;
                } else {
                  n2 = here_bits + 7;
                  while (bits < n2) {
                    if (have === 0) {
                      break inf_leave;
                    }
                    have--;
                    hold += input[next++] << bits;
                    bits += 8;
                  }
                  hold >>>= here_bits;
                  bits -= here_bits;
                  len = 0;
                  copy = 11 + (hold & 127);
                  hold >>>= 7;
                  bits -= 7;
                }
                if (state2.have + copy > state2.nlen + state2.ndist) {
                  strm.msg = "invalid bit length repeat";
                  state2.mode = BAD;
                  break;
                }
                while (copy--) {
                  state2.lens[state2.have++] = len;
                }
              }
            }
            if (state2.mode === BAD) {
              break;
            }
            if (state2.lens[256] === 0) {
              strm.msg = "invalid code -- missing end-of-block";
              state2.mode = BAD;
              break;
            }
            state2.lenbits = 9;
            opts = { bits: state2.lenbits };
            ret = inftrees(LENS, state2.lens, 0, state2.nlen, state2.lencode, 0, state2.work, opts);
            state2.lenbits = opts.bits;
            if (ret) {
              strm.msg = "invalid literal/lengths set";
              state2.mode = BAD;
              break;
            }
            state2.distbits = 6;
            state2.distcode = state2.distdyn;
            opts = { bits: state2.distbits };
            ret = inftrees(DISTS, state2.lens, state2.nlen, state2.ndist, state2.distcode, 0, state2.work, opts);
            state2.distbits = opts.bits;
            if (ret) {
              strm.msg = "invalid distances set";
              state2.mode = BAD;
              break;
            }
            state2.mode = LEN_;
            if (flush === Z_TREES) {
              break inf_leave;
            }
          /* falls through */
          case LEN_:
            state2.mode = LEN;
          /* falls through */
          case LEN:
            if (have >= 6 && left >= 258) {
              strm.next_out = put;
              strm.avail_out = left;
              strm.next_in = next;
              strm.avail_in = have;
              state2.hold = hold;
              state2.bits = bits;
              inffast(strm, _out);
              put = strm.next_out;
              output = strm.output;
              left = strm.avail_out;
              next = strm.next_in;
              input = strm.input;
              have = strm.avail_in;
              hold = state2.hold;
              bits = state2.bits;
              if (state2.mode === TYPE) {
                state2.back = -1;
              }
              break;
            }
            state2.back = 0;
            for (; ; ) {
              here = state2.lencode[hold & (1 << state2.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_op && (here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            state2.length = here_val;
            if (here_op === 0) {
              state2.mode = LIT;
              break;
            }
            if (here_op & 32) {
              state2.back = -1;
              state2.mode = TYPE;
              break;
            }
            if (here_op & 64) {
              strm.msg = "invalid literal/length code";
              state2.mode = BAD;
              break;
            }
            state2.extra = here_op & 15;
            state2.mode = LENEXT;
          /* falls through */
          case LENEXT:
            if (state2.extra) {
              n2 = state2.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.length += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            state2.was = state2.length;
            state2.mode = DIST;
          /* falls through */
          case DIST:
            for (; ; ) {
              here = state2.distcode[hold & (1 << state2.distbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if ((here_op & 240) === 0) {
              last_bits = here_bits;
              last_op = here_op;
              last_val = here_val;
              for (; ; ) {
                here = state2.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (last_bits + here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              hold >>>= last_bits;
              bits -= last_bits;
              state2.back += last_bits;
            }
            hold >>>= here_bits;
            bits -= here_bits;
            state2.back += here_bits;
            if (here_op & 64) {
              strm.msg = "invalid distance code";
              state2.mode = BAD;
              break;
            }
            state2.offset = here_val;
            state2.extra = here_op & 15;
            state2.mode = DISTEXT;
          /* falls through */
          case DISTEXT:
            if (state2.extra) {
              n2 = state2.extra;
              while (bits < n2) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state2.offset += hold & (1 << state2.extra) - 1;
              hold >>>= state2.extra;
              bits -= state2.extra;
              state2.back += state2.extra;
            }
            if (state2.offset > state2.dmax) {
              strm.msg = "invalid distance too far back";
              state2.mode = BAD;
              break;
            }
            state2.mode = MATCH;
          /* falls through */
          case MATCH:
            if (left === 0) {
              break inf_leave;
            }
            copy = _out - left;
            if (state2.offset > copy) {
              copy = state2.offset - copy;
              if (copy > state2.whave) {
                if (state2.sane) {
                  strm.msg = "invalid distance too far back";
                  state2.mode = BAD;
                  break;
                }
              }
              if (copy > state2.wnext) {
                copy -= state2.wnext;
                from = state2.wsize - copy;
              } else {
                from = state2.wnext - copy;
              }
              if (copy > state2.length) {
                copy = state2.length;
              }
              from_source = state2.window;
            } else {
              from_source = output;
              from = put - state2.offset;
              copy = state2.length;
            }
            if (copy > left) {
              copy = left;
            }
            left -= copy;
            state2.length -= copy;
            do {
              output[put++] = from_source[from++];
            } while (--copy);
            if (state2.length === 0) {
              state2.mode = LEN;
            }
            break;
          case LIT:
            if (left === 0) {
              break inf_leave;
            }
            output[put++] = state2.length;
            left--;
            state2.mode = LEN;
            break;
          case CHECK:
            if (state2.wrap) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold |= input[next++] << bits;
                bits += 8;
              }
              _out -= left;
              strm.total_out += _out;
              state2.total += _out;
              if (state2.wrap & 4 && _out) {
                strm.adler = state2.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
                state2.flags ? crc32_1(state2.check, output, _out, put - _out) : adler32_1(state2.check, output, _out, put - _out);
              }
              _out = left;
              if (state2.wrap & 4 && (state2.flags ? hold : zswap32(hold)) !== state2.check) {
                strm.msg = "incorrect data check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = LENGTH;
          /* falls through */
          case LENGTH:
            if (state2.wrap && state2.flags) {
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state2.wrap & 4 && hold !== (state2.total & 4294967295)) {
                strm.msg = "incorrect length check";
                state2.mode = BAD;
                break;
              }
              hold = 0;
              bits = 0;
            }
            state2.mode = DONE;
          /* falls through */
          case DONE:
            ret = Z_STREAM_END$1;
            break inf_leave;
          case BAD:
            ret = Z_DATA_ERROR$1;
            break inf_leave;
          case MEM:
            return Z_MEM_ERROR$1;
          case SYNC:
          /* falls through */
          default:
            return Z_STREAM_ERROR$1;
        }
      }
    strm.next_out = put;
    strm.avail_out = left;
    strm.next_in = next;
    strm.avail_in = have;
    state2.hold = hold;
    state2.bits = bits;
    if (state2.wsize || _out !== strm.avail_out && state2.mode < BAD && (state2.mode < CHECK || flush !== Z_FINISH$1)) {
      if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
    }
    _in -= strm.avail_in;
    _out -= strm.avail_out;
    strm.total_in += _in;
    strm.total_out += _out;
    state2.total += _out;
    if (state2.wrap & 4 && _out) {
      strm.adler = state2.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
      state2.flags ? crc32_1(state2.check, output, _out, strm.next_out - _out) : adler32_1(state2.check, output, _out, strm.next_out - _out);
    }
    strm.data_type = state2.bits + (state2.last ? 64 : 0) + (state2.mode === TYPE ? 128 : 0) + (state2.mode === LEN_ || state2.mode === COPY_ ? 256 : 0);
    if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
      ret = Z_BUF_ERROR;
    }
    return ret;
  };
  const inflateEnd = (strm) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    let state2 = strm.state;
    if (state2.window) {
      state2.window = null;
    }
    strm.state = null;
    return Z_OK$1;
  };
  const inflateGetHeader = (strm, head) => {
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    const state2 = strm.state;
    if ((state2.wrap & 2) === 0) {
      return Z_STREAM_ERROR$1;
    }
    state2.head = head;
    head.done = false;
    return Z_OK$1;
  };
  const inflateSetDictionary = (strm, dictionary) => {
    const dictLength = dictionary.length;
    let state2;
    let dictid;
    let ret;
    if (inflateStateCheck(strm)) {
      return Z_STREAM_ERROR$1;
    }
    state2 = strm.state;
    if (state2.wrap !== 0 && state2.mode !== DICT) {
      return Z_STREAM_ERROR$1;
    }
    if (state2.mode === DICT) {
      dictid = 1;
      dictid = adler32_1(dictid, dictionary, dictLength, 0);
      if (dictid !== state2.check) {
        return Z_DATA_ERROR$1;
      }
    }
    ret = updatewindow(strm, dictionary, dictLength, dictLength);
    if (ret) {
      state2.mode = MEM;
      return Z_MEM_ERROR$1;
    }
    state2.havedict = 1;
    return Z_OK$1;
  };
  var inflateReset_1 = inflateReset;
  var inflateReset2_1 = inflateReset2;
  var inflateResetKeep_1 = inflateResetKeep;
  var inflateInit_1 = inflateInit;
  var inflateInit2_1 = inflateInit2;
  var inflate_2$1 = inflate$2;
  var inflateEnd_1 = inflateEnd;
  var inflateGetHeader_1 = inflateGetHeader;
  var inflateSetDictionary_1 = inflateSetDictionary;
  var inflateInfo = "pako inflate (from Nodeca project)";
  var inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo
  };
  function GZheader() {
    this.text = 0;
    this.time = 0;
    this.xflags = 0;
    this.os = 0;
    this.extra = null;
    this.extra_len = 0;
    this.name = "";
    this.comment = "";
    this.hcrc = 0;
    this.done = false;
  }
  var gzheader = GZheader;
  const toString = Object.prototype.toString;
  const {
    Z_NO_FLUSH,
    Z_FINISH,
    Z_OK,
    Z_STREAM_END,
    Z_NEED_DICT,
    Z_STREAM_ERROR,
    Z_DATA_ERROR,
    Z_MEM_ERROR
  } = constants$2;
  function Inflate$1(options) {
    this.options = common.assign({
      chunkSize: 1024 * 64,
      windowBits: 15,
      to: ""
    }, options || {});
    const opt = this.options;
    if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
      opt.windowBits = -opt.windowBits;
      if (opt.windowBits === 0) {
        opt.windowBits = -15;
      }
    }
    if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
      opt.windowBits += 32;
    }
    if (opt.windowBits > 15 && opt.windowBits < 48) {
      if ((opt.windowBits & 15) === 0) {
        opt.windowBits |= 15;
      }
    }
    this.err = 0;
    this.msg = "";
    this.ended = false;
    this.chunks = [];
    this.strm = new zstream();
    this.strm.avail_out = 0;
    let status = inflate_1$2.inflateInit2(
      this.strm,
      opt.windowBits
    );
    if (status !== Z_OK) {
      throw new Error(messages[status]);
    }
    this.header = new gzheader();
    inflate_1$2.inflateGetHeader(this.strm, this.header);
    if (opt.dictionary) {
      if (typeof opt.dictionary === "string") {
        opt.dictionary = strings.string2buf(opt.dictionary);
      } else if (toString.call(opt.dictionary) === "[object ArrayBuffer]") {
        opt.dictionary = new Uint8Array(opt.dictionary);
      }
      if (opt.raw) {
        status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
        if (status !== Z_OK) {
          throw new Error(messages[status]);
        }
      }
    }
  }
  Inflate$1.prototype.push = function(data, flush_mode) {
    const strm = this.strm;
    const chunkSize = this.options.chunkSize;
    const dictionary = this.options.dictionary;
    let status, _flush_mode, last_avail_out;
    if (this.ended) return false;
    if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
    else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
    if (toString.call(data) === "[object ArrayBuffer]") {
      strm.input = new Uint8Array(data);
    } else {
      strm.input = data;
    }
    strm.next_in = 0;
    strm.avail_in = strm.input.length;
    for (; ; ) {
      if (strm.avail_out === 0) {
        strm.output = new Uint8Array(chunkSize);
        strm.next_out = 0;
        strm.avail_out = chunkSize;
      }
      status = inflate_1$2.inflate(strm, _flush_mode);
      if (status === Z_NEED_DICT && dictionary) {
        status = inflate_1$2.inflateSetDictionary(strm, dictionary);
        if (status === Z_OK) {
          status = inflate_1$2.inflate(strm, _flush_mode);
        } else if (status === Z_DATA_ERROR) {
          status = Z_NEED_DICT;
        }
      }
      while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {
        inflate_1$2.inflateReset(strm);
        status = inflate_1$2.inflate(strm, _flush_mode);
      }
      switch (status) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
          this.onEnd(status);
          this.ended = true;
          return false;
      }
      last_avail_out = strm.avail_out;
      if (strm.next_out) {
        if (strm.avail_out === 0 || status === Z_STREAM_END) {
          if (this.options.to === "string") {
            let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
            let tail = strm.next_out - next_out_utf8;
            let utf8str = strings.buf2string(strm.output, next_out_utf8);
            strm.next_out = tail;
            strm.avail_out = chunkSize - tail;
            if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
            this.onData(utf8str);
          } else {
            this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
          }
        }
      }
      if (status === Z_OK && last_avail_out === 0) continue;
      if (status === Z_STREAM_END) {
        status = inflate_1$2.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return true;
      }
      if (strm.avail_in === 0) break;
    }
    return true;
  };
  Inflate$1.prototype.onData = function(chunk) {
    this.chunks.push(chunk);
  };
  Inflate$1.prototype.onEnd = function(status) {
    if (status === Z_OK) {
      if (this.options.to === "string") {
        this.result = this.chunks.join("");
      } else {
        this.result = common.flattenChunks(this.chunks);
      }
    }
    this.chunks = [];
    this.err = status;
    this.msg = this.strm.msg;
  };
  function inflate$1(input, options) {
    const inflator = new Inflate$1(options);
    inflator.push(input);
    if (inflator.err) throw inflator.msg || messages[inflator.err];
    return inflator.result;
  }
  var Inflate_1$1 = Inflate$1;
  var inflate_2 = inflate$1;
  var inflate_1$1 = {
    Inflate: Inflate_1$1,
    inflate: inflate_2
  };
  const { Inflate, inflate } = inflate_1$1;
  var Inflate_1 = Inflate;
  var inflate_1 = inflate;
  const crcTable = [];
  for (let n2 = 0; n2 < 256; n2++) {
    let c2 = n2;
    for (let k2 = 0; k2 < 8; k2++) {
      if (c2 & 1) {
        c2 = 3988292384 ^ c2 >>> 1;
      } else {
        c2 = c2 >>> 1;
      }
    }
    crcTable[n2] = c2;
  }
  const initialCrc = 4294967295;
  function updateCrc(currentCrc, data, length) {
    let c2 = currentCrc;
    for (let n2 = 0; n2 < length; n2++) {
      c2 = crcTable[(c2 ^ data[n2]) & 255] ^ c2 >>> 8;
    }
    return c2;
  }
  function crc(data, length) {
    return (updateCrc(initialCrc, data, length) ^ initialCrc) >>> 0;
  }
  function checkCrc(buffer, crcLength, chunkName) {
    const expectedCrc = buffer.readUint32();
    const actualCrc = crc(new Uint8Array(buffer.buffer, buffer.byteOffset + buffer.offset - crcLength - 4, crcLength), crcLength);
    if (actualCrc !== expectedCrc) {
      throw new Error(`CRC mismatch for chunk ${chunkName}. Expected ${expectedCrc}, found ${actualCrc}`);
    }
  }
  function unfilterNone(currentLine, newLine, bytesPerLine) {
    for (let i2 = 0; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2];
    }
  }
  function unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel) {
    let i2 = 0;
    for (; i2 < bytesPerPixel; i2++) {
      newLine[i2] = currentLine[i2];
    }
    for (; i2 < bytesPerLine; i2++) {
      newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
    }
  }
  function unfilterUp(currentLine, newLine, prevLine, bytesPerLine) {
    let i2 = 0;
    if (prevLine.length === 0) {
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2];
      }
    } else {
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
      }
    }
  }
  function unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i2 = 0;
    if (prevLine.length === 0) {
      for (; i2 < bytesPerPixel; i2++) {
        newLine[i2] = currentLine[i2];
      }
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] >> 1) & 255;
      }
    } else {
      for (; i2 < bytesPerPixel; i2++) {
        newLine[i2] = currentLine[i2] + (prevLine[i2] >> 1) & 255;
      }
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2] + (newLine[i2 - bytesPerPixel] + prevLine[i2] >> 1) & 255;
      }
    }
  }
  function unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel) {
    let i2 = 0;
    if (prevLine.length === 0) {
      for (; i2 < bytesPerPixel; i2++) {
        newLine[i2] = currentLine[i2];
      }
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2] + newLine[i2 - bytesPerPixel] & 255;
      }
    } else {
      for (; i2 < bytesPerPixel; i2++) {
        newLine[i2] = currentLine[i2] + prevLine[i2] & 255;
      }
      for (; i2 < bytesPerLine; i2++) {
        newLine[i2] = currentLine[i2] + paethPredictor(newLine[i2 - bytesPerPixel], prevLine[i2], prevLine[i2 - bytesPerPixel]) & 255;
      }
    }
  }
  function paethPredictor(a2, b2, c2) {
    const p2 = a2 + b2 - c2;
    const pa = Math.abs(p2 - a2);
    const pb = Math.abs(p2 - b2);
    const pc = Math.abs(p2 - c2);
    if (pa <= pb && pa <= pc)
      return a2;
    else if (pb <= pc)
      return b2;
    else
      return c2;
  }
  function applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel) {
    switch (filterType) {
      case 0:
        unfilterNone(currentLine, newLine, passLineBytes);
        break;
      case 1:
        unfilterSub(currentLine, newLine, passLineBytes, bytesPerPixel);
        break;
      case 2:
        unfilterUp(currentLine, newLine, prevLine, passLineBytes);
        break;
      case 3:
        unfilterAverage(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
        break;
      case 4:
        unfilterPaeth(currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
        break;
      default:
        throw new Error(`Unsupported filter: ${filterType}`);
    }
  }
  const uint16$1 = new Uint16Array([255]);
  const uint8$1 = new Uint8Array(uint16$1.buffer);
  const osIsLittleEndian$1 = uint8$1[0] === 255;
  function decodeInterlaceAdam7(params) {
    const { data, width, height, channels, depth } = params;
    const passes = [
      { x: 0, y: 0, xStep: 8, yStep: 8 },
      // Pass 1
      { x: 4, y: 0, xStep: 8, yStep: 8 },
      // Pass 2
      { x: 0, y: 4, xStep: 4, yStep: 8 },
      // Pass 3
      { x: 2, y: 0, xStep: 4, yStep: 4 },
      // Pass 4
      { x: 0, y: 2, xStep: 2, yStep: 4 },
      // Pass 5
      { x: 1, y: 0, xStep: 2, yStep: 2 },
      // Pass 6
      { x: 0, y: 1, xStep: 1, yStep: 2 }
      // Pass 7
    ];
    const bytesPerPixel = Math.ceil(depth / 8) * channels;
    const resultData = new Uint8Array(height * width * bytesPerPixel);
    let offset = 0;
    for (let passIndex = 0; passIndex < 7; passIndex++) {
      const pass = passes[passIndex];
      const passWidth = Math.ceil((width - pass.x) / pass.xStep);
      const passHeight = Math.ceil((height - pass.y) / pass.yStep);
      if (passWidth <= 0 || passHeight <= 0)
        continue;
      const passLineBytes = passWidth * bytesPerPixel;
      const prevLine = new Uint8Array(passLineBytes);
      for (let y2 = 0; y2 < passHeight; y2++) {
        const filterType = data[offset++];
        const currentLine = data.subarray(offset, offset + passLineBytes);
        offset += passLineBytes;
        const newLine = new Uint8Array(passLineBytes);
        applyUnfilter(filterType, currentLine, newLine, prevLine, passLineBytes, bytesPerPixel);
        prevLine.set(newLine);
        for (let x2 = 0; x2 < passWidth; x2++) {
          const outputX = pass.x + x2 * pass.xStep;
          const outputY = pass.y + y2 * pass.yStep;
          if (outputX >= width || outputY >= height)
            continue;
          for (let i2 = 0; i2 < bytesPerPixel; i2++) {
            resultData[(outputY * width + outputX) * bytesPerPixel + i2] = newLine[x2 * bytesPerPixel + i2];
          }
        }
      }
    }
    if (depth === 16) {
      const uint16Data = new Uint16Array(resultData.buffer);
      if (osIsLittleEndian$1) {
        for (let k2 = 0; k2 < uint16Data.length; k2++) {
          uint16Data[k2] = swap16$1(uint16Data[k2]);
        }
      }
      return uint16Data;
    } else {
      return resultData;
    }
  }
  function swap16$1(val) {
    return (val & 255) << 8 | val >> 8 & 255;
  }
  const uint16 = new Uint16Array([255]);
  const uint8 = new Uint8Array(uint16.buffer);
  const osIsLittleEndian = uint8[0] === 255;
  const empty = new Uint8Array(0);
  function decodeInterlaceNull(params) {
    const { data, width, height, channels, depth } = params;
    const bytesPerPixel = Math.ceil(depth / 8) * channels;
    const bytesPerLine = Math.ceil(depth / 8 * channels * width);
    const newData = new Uint8Array(height * bytesPerLine);
    let prevLine = empty;
    let offset = 0;
    let currentLine;
    let newLine;
    for (let i2 = 0; i2 < height; i2++) {
      currentLine = data.subarray(offset + 1, offset + 1 + bytesPerLine);
      newLine = newData.subarray(i2 * bytesPerLine, (i2 + 1) * bytesPerLine);
      switch (data[offset]) {
        case 0:
          unfilterNone(currentLine, newLine, bytesPerLine);
          break;
        case 1:
          unfilterSub(currentLine, newLine, bytesPerLine, bytesPerPixel);
          break;
        case 2:
          unfilterUp(currentLine, newLine, prevLine, bytesPerLine);
          break;
        case 3:
          unfilterAverage(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
          break;
        case 4:
          unfilterPaeth(currentLine, newLine, prevLine, bytesPerLine, bytesPerPixel);
          break;
        default:
          throw new Error(`Unsupported filter: ${data[offset]}`);
      }
      prevLine = newLine;
      offset += bytesPerLine + 1;
    }
    if (depth === 16) {
      const uint16Data = new Uint16Array(newData.buffer);
      if (osIsLittleEndian) {
        for (let k2 = 0; k2 < uint16Data.length; k2++) {
          uint16Data[k2] = swap16(uint16Data[k2]);
        }
      }
      return uint16Data;
    } else {
      return newData;
    }
  }
  function swap16(val) {
    return (val & 255) << 8 | val >> 8 & 255;
  }
  const pngSignature = Uint8Array.of(137, 80, 78, 71, 13, 10, 26, 10);
  function checkSignature(buffer) {
    if (!hasPngSignature(buffer.readBytes(pngSignature.length))) {
      throw new Error("wrong PNG signature");
    }
  }
  function hasPngSignature(array) {
    if (array.length < pngSignature.length) {
      return false;
    }
    for (let i2 = 0; i2 < pngSignature.length; i2++) {
      if (array[i2] !== pngSignature[i2]) {
        return false;
      }
    }
    return true;
  }
  const textChunkName = "tEXt";
  const NULL$1 = 0;
  const latin1Decoder = new TextDecoder("latin1");
  function validateKeyword(keyword) {
    validateLatin1(keyword);
    if (keyword.length === 0 || keyword.length > 79) {
      throw new Error("keyword length must be between 1 and 79");
    }
  }
  const latin1Regex = /^[\u0000-\u00FF]*$/;
  function validateLatin1(text2) {
    if (!latin1Regex.test(text2)) {
      throw new Error("invalid latin1 text");
    }
  }
  function decodetEXt(text2, buffer, length) {
    const keyword = readKeyword(buffer);
    text2[keyword] = readLatin1(buffer, length - keyword.length - 1);
  }
  function readKeyword(buffer) {
    buffer.mark();
    while (buffer.readByte() !== NULL$1) {
    }
    const end = buffer.offset;
    buffer.reset();
    const keyword = latin1Decoder.decode(buffer.readBytes(end - buffer.offset - 1));
    buffer.skip(1);
    validateKeyword(keyword);
    return keyword;
  }
  function readLatin1(buffer, length) {
    return latin1Decoder.decode(buffer.readBytes(length));
  }
  const ColorType = {
    UNKNOWN: -1,
    GREYSCALE: 0,
    TRUECOLOUR: 2,
    INDEXED_COLOUR: 3,
    GREYSCALE_ALPHA: 4,
    TRUECOLOUR_ALPHA: 6
  };
  const CompressionMethod = {
    UNKNOWN: -1,
    DEFLATE: 0
  };
  const FilterMethod = {
    UNKNOWN: -1,
    ADAPTIVE: 0
  };
  const InterlaceMethod = {
    UNKNOWN: -1,
    NO_INTERLACE: 0,
    ADAM7: 1
  };
  const DisposeOpType = {
    NONE: 0,
    BACKGROUND: 1,
    PREVIOUS: 2
  };
  const BlendOpType = {
    SOURCE: 0,
    OVER: 1
  };
  class PngDecoder extends IOBuffer {
    constructor(data, options = {}) {
      super(data);
      __publicField(this, "_checkCrc");
      __publicField(this, "_inflator");
      __publicField(this, "_png");
      __publicField(this, "_apng");
      __publicField(this, "_end");
      __publicField(this, "_hasPalette");
      __publicField(this, "_palette");
      __publicField(this, "_hasTransparency");
      __publicField(this, "_transparency");
      __publicField(this, "_compressionMethod");
      __publicField(this, "_filterMethod");
      __publicField(this, "_interlaceMethod");
      __publicField(this, "_colorType");
      __publicField(this, "_isAnimated");
      __publicField(this, "_numberOfFrames");
      __publicField(this, "_numberOfPlays");
      __publicField(this, "_frames");
      __publicField(this, "_writingDataChunks");
      const { checkCrc: checkCrc2 = false } = options;
      this._checkCrc = checkCrc2;
      this._inflator = new Inflate_1();
      this._png = {
        width: -1,
        height: -1,
        channels: -1,
        data: new Uint8Array(0),
        depth: 1,
        text: {}
      };
      this._apng = {
        width: -1,
        height: -1,
        channels: -1,
        depth: 1,
        numberOfFrames: 1,
        numberOfPlays: 0,
        text: {},
        frames: []
      };
      this._end = false;
      this._hasPalette = false;
      this._palette = [];
      this._hasTransparency = false;
      this._transparency = new Uint16Array(0);
      this._compressionMethod = CompressionMethod.UNKNOWN;
      this._filterMethod = FilterMethod.UNKNOWN;
      this._interlaceMethod = InterlaceMethod.UNKNOWN;
      this._colorType = ColorType.UNKNOWN;
      this._isAnimated = false;
      this._numberOfFrames = 1;
      this._numberOfPlays = 0;
      this._frames = [];
      this._writingDataChunks = false;
      this.setBigEndian();
    }
    decode() {
      checkSignature(this);
      while (!this._end) {
        const length = this.readUint32();
        const type = this.readChars(4);
        this.decodeChunk(length, type);
      }
      this.decodeImage();
      return this._png;
    }
    decodeApng() {
      checkSignature(this);
      while (!this._end) {
        const length = this.readUint32();
        const type = this.readChars(4);
        this.decodeApngChunk(length, type);
      }
      this.decodeApngImage();
      return this._apng;
    }
    // https://www.w3.org/TR/PNG/#5Chunk-layout
    decodeChunk(length, type) {
      const offset = this.offset;
      switch (type) {
        // 11.2 Critical chunks
        case "IHDR":
          this.decodeIHDR();
          break;
        case "PLTE":
          this.decodePLTE(length);
          break;
        case "IDAT":
          this.decodeIDAT(length);
          break;
        case "IEND":
          this._end = true;
          break;
        // 11.3 Ancillary chunks
        case "tRNS":
          this.decodetRNS(length);
          break;
        case "iCCP":
          this.decodeiCCP(length);
          break;
        case textChunkName:
          decodetEXt(this._png.text, this, length);
          break;
        case "pHYs":
          this.decodepHYs();
          break;
        default:
          this.skip(length);
          break;
      }
      if (this.offset - offset !== length) {
        throw new Error(`Length mismatch while decoding chunk ${type}`);
      }
      if (this._checkCrc) {
        checkCrc(this, length + 4, type);
      } else {
        this.skip(4);
      }
    }
    decodeApngChunk(length, type) {
      const offset = this.offset;
      if (type !== "fdAT" && type !== "IDAT" && this._writingDataChunks) {
        this.pushDataToFrame();
      }
      switch (type) {
        case "acTL":
          this.decodeACTL();
          break;
        case "fcTL":
          this.decodeFCTL();
          break;
        case "fdAT":
          this.decodeFDAT(length);
          break;
        default:
          this.decodeChunk(length, type);
          this.offset = offset + length;
          break;
      }
      if (this.offset - offset !== length) {
        throw new Error(`Length mismatch while decoding chunk ${type}`);
      }
      if (this._checkCrc) {
        checkCrc(this, length + 4, type);
      } else {
        this.skip(4);
      }
    }
    // https://www.w3.org/TR/PNG/#11IHDR
    decodeIHDR() {
      const image2 = this._png;
      image2.width = this.readUint32();
      image2.height = this.readUint32();
      image2.depth = checkBitDepth(this.readUint8());
      const colorType = this.readUint8();
      this._colorType = colorType;
      let channels;
      switch (colorType) {
        case ColorType.GREYSCALE:
          channels = 1;
          break;
        case ColorType.TRUECOLOUR:
          channels = 3;
          break;
        case ColorType.INDEXED_COLOUR:
          channels = 1;
          break;
        case ColorType.GREYSCALE_ALPHA:
          channels = 2;
          break;
        case ColorType.TRUECOLOUR_ALPHA:
          channels = 4;
          break;
        // Kept for exhaustiveness.
        // eslint-disable-next-line unicorn/no-useless-switch-case
        case ColorType.UNKNOWN:
        default:
          throw new Error(`Unknown color type: ${colorType}`);
      }
      this._png.channels = channels;
      this._compressionMethod = this.readUint8();
      if (this._compressionMethod !== CompressionMethod.DEFLATE) {
        throw new Error(`Unsupported compression method: ${this._compressionMethod}`);
      }
      this._filterMethod = this.readUint8();
      this._interlaceMethod = this.readUint8();
    }
    decodeACTL() {
      this._numberOfFrames = this.readUint32();
      this._numberOfPlays = this.readUint32();
      this._isAnimated = true;
    }
    decodeFCTL() {
      const image2 = {
        sequenceNumber: this.readUint32(),
        width: this.readUint32(),
        height: this.readUint32(),
        xOffset: this.readUint32(),
        yOffset: this.readUint32(),
        delayNumber: this.readUint16(),
        delayDenominator: this.readUint16(),
        disposeOp: this.readUint8(),
        blendOp: this.readUint8(),
        data: new Uint8Array(0)
      };
      this._frames.push(image2);
    }
    // https://www.w3.org/TR/PNG/#11PLTE
    decodePLTE(length) {
      if (length % 3 !== 0) {
        throw new RangeError(`PLTE field length must be a multiple of 3. Got ${length}`);
      }
      const l2 = length / 3;
      this._hasPalette = true;
      const palette = [];
      this._palette = palette;
      for (let i2 = 0; i2 < l2; i2++) {
        palette.push([this.readUint8(), this.readUint8(), this.readUint8()]);
      }
    }
    // https://www.w3.org/TR/PNG/#11IDAT
    decodeIDAT(length) {
      this._writingDataChunks = true;
      const dataLength = length;
      const dataOffset = this.offset + this.byteOffset;
      this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
      if (this._inflator.err) {
        throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
      }
      this.skip(length);
    }
    decodeFDAT(length) {
      this._writingDataChunks = true;
      let dataLength = length;
      let dataOffset = this.offset + this.byteOffset;
      dataOffset += 4;
      dataLength -= 4;
      this._inflator.push(new Uint8Array(this.buffer, dataOffset, dataLength));
      if (this._inflator.err) {
        throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
      }
      this.skip(length);
    }
    // https://www.w3.org/TR/PNG/#11tRNS
    decodetRNS(length) {
      switch (this._colorType) {
        case ColorType.GREYSCALE:
        case ColorType.TRUECOLOUR: {
          if (length % 2 !== 0) {
            throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${length}`);
          }
          if (length / 2 > this._png.width * this._png.height) {
            throw new Error(`tRNS chunk contains more alpha values than there are pixels (${length / 2} vs ${this._png.width * this._png.height})`);
          }
          this._hasTransparency = true;
          this._transparency = new Uint16Array(length / 2);
          for (let i2 = 0; i2 < length / 2; i2++) {
            this._transparency[i2] = this.readUint16();
          }
          break;
        }
        case ColorType.INDEXED_COLOUR: {
          if (length > this._palette.length) {
            throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${length} vs ${this._palette.length})`);
          }
          let i2 = 0;
          for (; i2 < length; i2++) {
            const alpha = this.readByte();
            this._palette[i2].push(alpha);
          }
          for (; i2 < this._palette.length; i2++) {
            this._palette[i2].push(255);
          }
          break;
        }
        // Kept for exhaustiveness.
        /* eslint-disable unicorn/no-useless-switch-case */
        case ColorType.UNKNOWN:
        case ColorType.GREYSCALE_ALPHA:
        case ColorType.TRUECOLOUR_ALPHA:
        default: {
          throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`);
        }
      }
    }
    // https://www.w3.org/TR/PNG/#11iCCP
    decodeiCCP(length) {
      const name = readKeyword(this);
      const compressionMethod = this.readUint8();
      if (compressionMethod !== CompressionMethod.DEFLATE) {
        throw new Error(`Unsupported iCCP compression method: ${compressionMethod}`);
      }
      const compressedProfile = this.readBytes(length - name.length - 2);
      this._png.iccEmbeddedProfile = {
        name,
        profile: inflate_1(compressedProfile)
      };
    }
    // https://www.w3.org/TR/PNG/#11pHYs
    decodepHYs() {
      const ppuX = this.readUint32();
      const ppuY = this.readUint32();
      const unitSpecifier = this.readByte();
      this._png.resolution = { x: ppuX, y: ppuY, unit: unitSpecifier };
    }
    decodeApngImage() {
      this._apng.width = this._png.width;
      this._apng.height = this._png.height;
      this._apng.channels = this._png.channels;
      this._apng.depth = this._png.depth;
      this._apng.numberOfFrames = this._numberOfFrames;
      this._apng.numberOfPlays = this._numberOfPlays;
      this._apng.text = this._png.text;
      this._apng.resolution = this._png.resolution;
      for (let i2 = 0; i2 < this._numberOfFrames; i2++) {
        const newFrame = {
          sequenceNumber: this._frames[i2].sequenceNumber,
          delayNumber: this._frames[i2].delayNumber,
          delayDenominator: this._frames[i2].delayDenominator,
          data: this._apng.depth === 8 ? new Uint8Array(this._apng.width * this._apng.height * this._apng.channels) : new Uint16Array(this._apng.width * this._apng.height * this._apng.channels)
        };
        const frame = this._frames.at(i2);
        if (frame) {
          frame.data = decodeInterlaceNull({
            data: frame.data,
            width: frame.width,
            height: frame.height,
            channels: this._apng.channels,
            depth: this._apng.depth
          });
          if (this._hasPalette) {
            this._apng.palette = this._palette;
          }
          if (this._hasTransparency) {
            this._apng.transparency = this._transparency;
          }
          if (i2 === 0 || frame.xOffset === 0 && frame.yOffset === 0 && frame.width === this._png.width && frame.height === this._png.height) {
            newFrame.data = frame.data;
          } else {
            const prevFrame = this._apng.frames.at(i2 - 1);
            this.disposeFrame(frame, prevFrame, newFrame);
            this.addFrameDataToCanvas(newFrame, frame);
          }
          this._apng.frames.push(newFrame);
        }
      }
      return this._apng;
    }
    disposeFrame(frame, prevFrame, imageFrame) {
      switch (frame.disposeOp) {
        case DisposeOpType.NONE:
          break;
        case DisposeOpType.BACKGROUND:
          for (let row = 0; row < this._png.height; row++) {
            for (let col = 0; col < this._png.width; col++) {
              const index2 = (row * frame.width + col) * this._png.channels;
              for (let channel = 0; channel < this._png.channels; channel++) {
                imageFrame.data[index2 + channel] = 0;
              }
            }
          }
          break;
        case DisposeOpType.PREVIOUS:
          imageFrame.data.set(prevFrame.data);
          break;
        default:
          throw new Error("Unknown disposeOp");
      }
    }
    addFrameDataToCanvas(imageFrame, frame) {
      const maxValue = 1 << this._png.depth;
      const calculatePixelIndices = (row, col) => {
        const index2 = ((row + frame.yOffset) * this._png.width + frame.xOffset + col) * this._png.channels;
        const frameIndex = (row * frame.width + col) * this._png.channels;
        return { index: index2, frameIndex };
      };
      switch (frame.blendOp) {
        case BlendOpType.SOURCE:
          for (let row = 0; row < frame.height; row++) {
            for (let col = 0; col < frame.width; col++) {
              const { index: index2, frameIndex } = calculatePixelIndices(row, col);
              for (let channel = 0; channel < this._png.channels; channel++) {
                imageFrame.data[index2 + channel] = frame.data[frameIndex + channel];
              }
            }
          }
          break;
        // https://www.w3.org/TR/png-3/#13Alpha-channel-processing
        case BlendOpType.OVER:
          for (let row = 0; row < frame.height; row++) {
            for (let col = 0; col < frame.width; col++) {
              const { index: index2, frameIndex } = calculatePixelIndices(row, col);
              for (let channel = 0; channel < this._png.channels; channel++) {
                const sourceAlpha = frame.data[frameIndex + this._png.channels - 1] / maxValue;
                const foregroundValue = channel % (this._png.channels - 1) === 0 ? 1 : frame.data[frameIndex + channel];
                const value = Math.floor(sourceAlpha * foregroundValue + (1 - sourceAlpha) * imageFrame.data[index2 + channel]);
                imageFrame.data[index2 + channel] += value;
              }
            }
          }
          break;
        default:
          throw new Error("Unknown blendOp");
      }
    }
    decodeImage() {
      var _a2;
      if (this._inflator.err) {
        throw new Error(`Error while decompressing the data: ${this._inflator.err}`);
      }
      const data = this._isAnimated ? ((_a2 = this._frames) == null ? void 0 : _a2.at(0)).data : this._inflator.result;
      if (this._filterMethod !== FilterMethod.ADAPTIVE) {
        throw new Error(`Filter method ${this._filterMethod} not supported`);
      }
      if (this._interlaceMethod === InterlaceMethod.NO_INTERLACE) {
        this._png.data = decodeInterlaceNull({
          data,
          width: this._png.width,
          height: this._png.height,
          channels: this._png.channels,
          depth: this._png.depth
        });
      } else if (this._interlaceMethod === InterlaceMethod.ADAM7) {
        this._png.data = decodeInterlaceAdam7({
          data,
          width: this._png.width,
          height: this._png.height,
          channels: this._png.channels,
          depth: this._png.depth
        });
      } else {
        throw new Error(`Interlace method ${this._interlaceMethod} not supported`);
      }
      if (this._hasPalette) {
        this._png.palette = this._palette;
      }
      if (this._hasTransparency) {
        this._png.transparency = this._transparency;
      }
    }
    pushDataToFrame() {
      const result = this._inflator.result;
      const lastFrame = this._frames.at(-1);
      if (lastFrame) {
        lastFrame.data = result;
      } else {
        this._frames.push({
          sequenceNumber: 0,
          width: this._png.width,
          height: this._png.height,
          xOffset: 0,
          yOffset: 0,
          delayNumber: 0,
          delayDenominator: 0,
          disposeOp: DisposeOpType.NONE,
          blendOp: BlendOpType.SOURCE,
          data: result
        });
      }
      this._inflator = new Inflate_1();
      this._writingDataChunks = false;
    }
  }
  function checkBitDepth(value) {
    if (value !== 1 && value !== 2 && value !== 4 && value !== 8 && value !== 16) {
      throw new Error(`invalid bit depth: ${value}`);
    }
    return value;
  }
  var ResolutionUnitSpecifier;
  (function(ResolutionUnitSpecifier2) {
    ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["UNKNOWN"] = 0] = "UNKNOWN";
    ResolutionUnitSpecifier2[ResolutionUnitSpecifier2["METRE"] = 1] = "METRE";
  })(ResolutionUnitSpecifier || (ResolutionUnitSpecifier = {}));
  function decodePng(data, options) {
    const decoder = new PngDecoder(data, options);
    return decoder.decode();
  }
  /** @license
   *
   * jsPDF - PDF Document creation from JavaScript
   * Version 4.0.0 Built on 2025-12-18T10:27:09.425Z
   *                      CommitID 00000000
   *
   * Copyright (c) 2010-2025 James Hall <james@parall.ax>, https://github.com/MrRio/jsPDF
   *               2015-2025 yWorks GmbH, http://www.yworks.com
   *               2015-2025 Lukas Hollnder <lukas.hollaender@yworks.com>, https://github.com/HackbrettXXX
   *               2016-2018 Aras Abbasi <aras.abbasi@gmail.com>
   *               2010 Aaron Spike, https://github.com/acspike
   *               2012 Willow Systems Corporation, https://github.com/willowsystems
   *               2012 Pablo Hess, https://github.com/pablohess
   *               2012 Florian Jenett, https://github.com/fjenett
   *               2013 Warren Weckesser, https://github.com/warrenweckesser
   *               2013 Youssef Beddad, https://github.com/lifof
   *               2013 Lee Driscoll, https://github.com/lsdriscoll
   *               2013 Stefan Slonevskiy, https://github.com/stefslon
   *               2013 Jeremy Morel, https://github.com/jmorel
   *               2013 Christoph Hartmann, https://github.com/chris-rock
   *               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
   *               2014 James Makes, https://github.com/dollaruw
   *               2014 Diego Casorran, https://github.com/diegocr
   *               2014 Steven Spungin, https://github.com/Flamenco
   *               2014 Kenneth Glassey, https://github.com/Gavvers
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   *
   * Contributor(s):
   *    siefkenj, ahwolf, rickygu, Midnith, saintclair, eaparango,
   *    kim3er, mfo, alnorth, Flamenco
   */
  var i$5 = /* @__PURE__ */ (function() {
    return "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this;
  })();
  function a$2() {
    i$5.console && "function" == typeof i$5.console.log && i$5.console.log.apply(i$5.console, arguments);
  }
  var o$1 = { log: a$2, warn: function(t2) {
    i$5.console && ("function" == typeof i$5.console.warn ? i$5.console.warn.apply(i$5.console, arguments) : a$2.call(null, arguments));
  }, error: function(t2) {
    i$5.console && ("function" == typeof i$5.console.error ? i$5.console.error.apply(i$5.console, arguments) : a$2(t2));
  } };
  function s$1(t2, e2, n2) {
    var r2 = new XMLHttpRequest();
    r2.open("GET", t2), r2.responseType = "blob", r2.onload = function() {
      l$1(r2.response, e2, n2);
    }, r2.onerror = function() {
      o$1.error("could not download file");
    }, r2.send();
  }
  function u$2(t2) {
    var e2 = new XMLHttpRequest();
    e2.open("HEAD", t2, false);
    try {
      e2.send();
    } catch (n2) {
    }
    return e2.status >= 200 && e2.status <= 299;
  }
  function c$2(t2) {
    try {
      t2.dispatchEvent(new MouseEvent("click"));
    } catch (n2) {
      var e2 = document.createEvent("MouseEvents");
      e2.initMouseEvent("click", true, true, window, 0, 0, 0, 80, 20, false, false, false, false, 0, null), t2.dispatchEvent(e2);
    }
  }
  var l$1 = i$5.saveAs || ("object" !== ("undefined" == typeof window ? "undefined" : _typeof$1(window)) || window !== i$5 ? function() {
  } : "undefined" != typeof HTMLAnchorElement && "download" in HTMLAnchorElement.prototype ? function(t2, e2, n2) {
    var r2 = i$5.URL || i$5.webkitURL, a2 = document.createElement("a");
    e2 = e2 || t2.name || "download", a2.download = e2, a2.rel = "noopener", "string" == typeof t2 ? (a2.href = t2, a2.origin !== location.origin ? u$2(a2.href) ? s$1(t2, e2, n2) : c$2(a2, a2.target = "_blank") : c$2(a2)) : (a2.href = r2.createObjectURL(t2), setTimeout(function() {
      r2.revokeObjectURL(a2.href);
    }, 4e4), setTimeout(function() {
      c$2(a2);
    }, 0));
  } : "msSaveOrOpenBlob" in navigator ? function(e2, n2, r2) {
    if (n2 = n2 || e2.name || "download", "string" == typeof e2) if (u$2(e2)) s$1(e2, n2, r2);
    else {
      var i2 = document.createElement("a");
      i2.href = e2, i2.target = "_blank", setTimeout(function() {
        c$2(i2);
      });
    }
    else navigator.msSaveOrOpenBlob((function(e3, n3) {
      return void 0 === n3 ? n3 = { autoBom: false } : "object" !== _typeof$1(n3) && (o$1.warn("Deprecated: Expected third argument to be a object"), n3 = { autoBom: !n3 }), n3.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e3.type) ? new Blob([String.fromCharCode(65279), e3], { type: e3.type }) : e3;
    })(e2, r2), n2);
  } : function(e2, n2, r2, a2) {
    if ((a2 = a2 || open("", "_blank")) && (a2.document.title = a2.document.body.innerText = "downloading..."), "string" == typeof e2) return s$1(e2, n2, r2);
    var o2 = "application/octet-stream" === e2.type, u2 = /constructor/i.test(i$5.HTMLElement) || i$5.safari, c2 = /CriOS\/[\d]+/.test(navigator.userAgent);
    if ((c2 || o2 && u2) && "object" === ("undefined" == typeof FileReader ? "undefined" : _typeof$1(FileReader))) {
      var l2 = new FileReader();
      l2.onloadend = function() {
        var t2 = l2.result;
        t2 = c2 ? t2 : t2.replace(/^data:[^;]*;/, "data:attachment/file;"), a2 ? a2.location.href = t2 : location = t2, a2 = null;
      }, l2.readAsDataURL(e2);
    } else {
      var h2 = i$5.URL || i$5.webkitURL, f2 = h2.createObjectURL(e2);
      a2 ? a2.location = f2 : location.href = f2, a2 = null, setTimeout(function() {
        h2.revokeObjectURL(f2);
      }, 4e4);
    }
  });
  /**
   * A class to parse color values
   * @author Stoyan Stefanov <sstoo@gmail.com>
   * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
   * @license Use it if you like it
   */
  function h$1(t2) {
    var e2;
    t2 = t2 || "", this.ok = false, "#" == t2.charAt(0) && (t2 = t2.substr(1, 6)), t2 = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[t2 = (t2 = t2.replace(/ /g, "")).toLowerCase()] || t2;
    for (var n2 = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function(t3) {
      return [parseInt(t3[1]), parseInt(t3[2]), parseInt(t3[3])];
    } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function(t3) {
      return [parseInt(t3[1], 16), parseInt(t3[2], 16), parseInt(t3[3], 16)];
    } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function(t3) {
      return [parseInt(t3[1] + t3[1], 16), parseInt(t3[2] + t3[2], 16), parseInt(t3[3] + t3[3], 16)];
    } }], r2 = 0; r2 < n2.length; r2++) {
      var i2 = n2[r2].re, a2 = n2[r2].process, o2 = i2.exec(t2);
      o2 && (e2 = a2(o2), this.r = e2[0], this.g = e2[1], this.b = e2[2], this.ok = true);
    }
    this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function() {
      return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
    }, this.toHex = function() {
      var t3 = this.r.toString(16), e3 = this.g.toString(16), n3 = this.b.toString(16);
      return 1 == t3.length && (t3 = "0" + t3), 1 == e3.length && (e3 = "0" + e3), 1 == n3.length && (n3 = "0" + n3), "#" + t3 + e3 + n3;
    };
  }
  var f$2 = i$5.atob.bind(i$5), d = i$5.btoa.bind(i$5);
  /**
   * @license
   * Joseph Myers does not specify a particular license for his work.
   *
   * Author: Joseph Myers
   * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
   *
   * Modified by: Owen Leong
   */
  function p$1(t2, e2) {
    var n2 = t2[0], r2 = t2[1], i2 = t2[2], a2 = t2[3];
    n2 = m$2(n2, r2, i2, a2, e2[0], 7, -680876936), a2 = m$2(a2, n2, r2, i2, e2[1], 12, -389564586), i2 = m$2(i2, a2, n2, r2, e2[2], 17, 606105819), r2 = m$2(r2, i2, a2, n2, e2[3], 22, -1044525330), n2 = m$2(n2, r2, i2, a2, e2[4], 7, -176418897), a2 = m$2(a2, n2, r2, i2, e2[5], 12, 1200080426), i2 = m$2(i2, a2, n2, r2, e2[6], 17, -1473231341), r2 = m$2(r2, i2, a2, n2, e2[7], 22, -45705983), n2 = m$2(n2, r2, i2, a2, e2[8], 7, 1770035416), a2 = m$2(a2, n2, r2, i2, e2[9], 12, -1958414417), i2 = m$2(i2, a2, n2, r2, e2[10], 17, -42063), r2 = m$2(r2, i2, a2, n2, e2[11], 22, -1990404162), n2 = m$2(n2, r2, i2, a2, e2[12], 7, 1804603682), a2 = m$2(a2, n2, r2, i2, e2[13], 12, -40341101), i2 = m$2(i2, a2, n2, r2, e2[14], 17, -1502002290), n2 = v$1(n2, r2 = m$2(r2, i2, a2, n2, e2[15], 22, 1236535329), i2, a2, e2[1], 5, -165796510), a2 = v$1(a2, n2, r2, i2, e2[6], 9, -1069501632), i2 = v$1(i2, a2, n2, r2, e2[11], 14, 643717713), r2 = v$1(r2, i2, a2, n2, e2[0], 20, -373897302), n2 = v$1(n2, r2, i2, a2, e2[5], 5, -701558691), a2 = v$1(a2, n2, r2, i2, e2[10], 9, 38016083), i2 = v$1(i2, a2, n2, r2, e2[15], 14, -660478335), r2 = v$1(r2, i2, a2, n2, e2[4], 20, -405537848), n2 = v$1(n2, r2, i2, a2, e2[9], 5, 568446438), a2 = v$1(a2, n2, r2, i2, e2[14], 9, -1019803690), i2 = v$1(i2, a2, n2, r2, e2[3], 14, -187363961), r2 = v$1(r2, i2, a2, n2, e2[8], 20, 1163531501), n2 = v$1(n2, r2, i2, a2, e2[13], 5, -1444681467), a2 = v$1(a2, n2, r2, i2, e2[2], 9, -51403784), i2 = v$1(i2, a2, n2, r2, e2[7], 14, 1735328473), n2 = b(n2, r2 = v$1(r2, i2, a2, n2, e2[12], 20, -1926607734), i2, a2, e2[5], 4, -378558), a2 = b(a2, n2, r2, i2, e2[8], 11, -2022574463), i2 = b(i2, a2, n2, r2, e2[11], 16, 1839030562), r2 = b(r2, i2, a2, n2, e2[14], 23, -35309556), n2 = b(n2, r2, i2, a2, e2[1], 4, -1530992060), a2 = b(a2, n2, r2, i2, e2[4], 11, 1272893353), i2 = b(i2, a2, n2, r2, e2[7], 16, -155497632), r2 = b(r2, i2, a2, n2, e2[10], 23, -1094730640), n2 = b(n2, r2, i2, a2, e2[13], 4, 681279174), a2 = b(a2, n2, r2, i2, e2[0], 11, -358537222), i2 = b(i2, a2, n2, r2, e2[3], 16, -722521979), r2 = b(r2, i2, a2, n2, e2[6], 23, 76029189), n2 = b(n2, r2, i2, a2, e2[9], 4, -640364487), a2 = b(a2, n2, r2, i2, e2[12], 11, -421815835), i2 = b(i2, a2, n2, r2, e2[15], 16, 530742520), n2 = y$1(n2, r2 = b(r2, i2, a2, n2, e2[2], 23, -995338651), i2, a2, e2[0], 6, -198630844), a2 = y$1(a2, n2, r2, i2, e2[7], 10, 1126891415), i2 = y$1(i2, a2, n2, r2, e2[14], 15, -1416354905), r2 = y$1(r2, i2, a2, n2, e2[5], 21, -57434055), n2 = y$1(n2, r2, i2, a2, e2[12], 6, 1700485571), a2 = y$1(a2, n2, r2, i2, e2[3], 10, -1894986606), i2 = y$1(i2, a2, n2, r2, e2[10], 15, -1051523), r2 = y$1(r2, i2, a2, n2, e2[1], 21, -2054922799), n2 = y$1(n2, r2, i2, a2, e2[8], 6, 1873313359), a2 = y$1(a2, n2, r2, i2, e2[15], 10, -30611744), i2 = y$1(i2, a2, n2, r2, e2[6], 15, -1560198380), r2 = y$1(r2, i2, a2, n2, e2[13], 21, 1309151649), n2 = y$1(n2, r2, i2, a2, e2[4], 6, -145523070), a2 = y$1(a2, n2, r2, i2, e2[11], 10, -1120210379), i2 = y$1(i2, a2, n2, r2, e2[2], 15, 718787259), r2 = y$1(r2, i2, a2, n2, e2[9], 21, -343485551), t2[0] = P(n2, t2[0]), t2[1] = P(r2, t2[1]), t2[2] = P(i2, t2[2]), t2[3] = P(a2, t2[3]);
  }
  function g(t2, e2, n2, r2, i2, a2) {
    return e2 = P(P(e2, t2), P(r2, a2)), P(e2 << i2 | e2 >>> 32 - i2, n2);
  }
  function m$2(t2, e2, n2, r2, i2, a2, o2) {
    return g(e2 & n2 | ~e2 & r2, t2, e2, i2, a2, o2);
  }
  function v$1(t2, e2, n2, r2, i2, a2, o2) {
    return g(e2 & r2 | n2 & ~r2, t2, e2, i2, a2, o2);
  }
  function b(t2, e2, n2, r2, i2, a2, o2) {
    return g(e2 ^ n2 ^ r2, t2, e2, i2, a2, o2);
  }
  function y$1(t2, e2, n2, r2, i2, a2, o2) {
    return g(n2 ^ (e2 | ~r2), t2, e2, i2, a2, o2);
  }
  function w(t2) {
    var e2, n2 = t2.length, r2 = [1732584193, -271733879, -1732584194, 271733878];
    for (e2 = 64; e2 <= t2.length; e2 += 64) p$1(r2, N$1(t2.substring(e2 - 64, e2)));
    t2 = t2.substring(e2 - 64);
    var i2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    for (e2 = 0; e2 < t2.length; e2++) i2[e2 >> 2] |= t2.charCodeAt(e2) << (e2 % 4 << 3);
    if (i2[e2 >> 2] |= 128 << (e2 % 4 << 3), e2 > 55) for (p$1(r2, i2), e2 = 0; e2 < 16; e2++) i2[e2] = 0;
    return i2[14] = 8 * n2, p$1(r2, i2), r2;
  }
  function N$1(t2) {
    var e2, n2 = [];
    for (e2 = 0; e2 < 64; e2 += 4) n2[e2 >> 2] = t2.charCodeAt(e2) + (t2.charCodeAt(e2 + 1) << 8) + (t2.charCodeAt(e2 + 2) << 16) + (t2.charCodeAt(e2 + 3) << 24);
    return n2;
  }
  var L$1 = "0123456789abcdef".split("");
  function x(t2) {
    for (var e2 = "", n2 = 0; n2 < 4; n2++) e2 += L$1[t2 >> 8 * n2 + 4 & 15] + L$1[t2 >> 8 * n2 & 15];
    return e2;
  }
  function A$1(t2) {
    return String.fromCharCode(255 & t2, (65280 & t2) >> 8, (16711680 & t2) >> 16, (4278190080 & t2) >> 24);
  }
  function S(t2) {
    return w(t2).map(A$1).join("");
  }
  var _$1 = "5d41402abc4b2a76b9719d911017c592" != (function(t2) {
    for (var e2 = 0; e2 < t2.length; e2++) t2[e2] = x(t2[e2]);
    return t2.join("");
  })(w("hello"));
  function P(t2, e2) {
    if (_$1) {
      var n2 = (65535 & t2) + (65535 & e2);
      return (t2 >> 16) + (e2 >> 16) + (n2 >> 16) << 16 | 65535 & n2;
    }
    return t2 + e2 & 4294967295;
  }
  /**
   * @license
   * FPDF is released under a permissive license: there is no usage restriction.
   * You may embed it freely in your application (commercial or not), with or
   * without modifications.
   *
   * Reference: http://www.fpdf.org/en/script/script37.php
   */
  function k(t2, e2) {
    var n2, r2, i2, a2;
    if (t2 !== n2) {
      for (var o2 = (i2 = t2, a2 = 1 + (256 / t2.length | 0), new Array(a2 + 1).join(i2)), s2 = [], u2 = 0; u2 < 256; u2++) s2[u2] = u2;
      var c2 = 0;
      for (u2 = 0; u2 < 256; u2++) {
        var l2 = s2[u2];
        c2 = (c2 + l2 + o2.charCodeAt(u2)) % 256, s2[u2] = s2[c2], s2[c2] = l2;
      }
      n2 = t2, r2 = s2;
    } else s2 = r2;
    var h2 = e2.length, f2 = 0, d2 = 0, p2 = "";
    for (u2 = 0; u2 < h2; u2++) d2 = (d2 + (l2 = s2[f2 = (f2 + 1) % 256])) % 256, s2[f2] = s2[d2], s2[d2] = l2, o2 = s2[(s2[f2] + s2[d2]) % 256], p2 += String.fromCharCode(e2.charCodeAt(u2) ^ o2);
    return p2;
  }
  /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   * Author: Owen Leong (@owenl131)
   * Date: 15 Oct 2020
   * References:
   * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
   * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
   * http://www.fpdf.org/en/script/script37.php
   */
  var F$1 = { print: 4, modify: 8, copy: 16, "annot-forms": 32 };
  function I(t2, e2, n2, r2) {
    this.v = 1, this.r = 2;
    var i2 = 192;
    t2.forEach(function(t3) {
      if (void 0 !== F$1.perm) throw new Error("Invalid permission: " + t3);
      i2 += F$1[t3];
    }), this.padding = "(N^NuAd\0NV\b..\0h>/\fdSiz";
    var a2 = (e2 + this.padding).substr(0, 32), o2 = (n2 + this.padding).substr(0, 32);
    this.O = this.processOwnerPassword(a2, o2), this.P = -(1 + (255 ^ i2)), this.encryptionKey = S(a2 + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(r2)).substr(0, 5), this.U = k(this.encryptionKey, this.padding);
  }
  function j(t2) {
    if (/[^\u0000-\u00ff]/.test(t2)) throw new Error("Invalid PDF Name Object: " + t2 + ", Only accept ASCII characters.");
    for (var e2 = "", n2 = t2.length, r2 = 0; r2 < n2; r2++) {
      var i2 = t2.charCodeAt(r2);
      e2 += i2 < 33 || 35 === i2 || 37 === i2 || 40 === i2 || 41 === i2 || 47 === i2 || 60 === i2 || 62 === i2 || 91 === i2 || 93 === i2 || 123 === i2 || 125 === i2 || i2 > 126 ? "#" + ("0" + i2.toString(16)).slice(-2) : t2[r2];
    }
    return e2;
  }
  function C(e2) {
    if ("object" !== _typeof$1(e2)) throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)");
    var n2 = {};
    this.subscribe = function(t2, e3, r2) {
      if (r2 = r2 || false, "string" != typeof t2 || "function" != typeof e3 || "boolean" != typeof r2) throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)");
      n2.hasOwnProperty(t2) || (n2[t2] = {});
      var i2 = Math.random().toString(35);
      return n2[t2][i2] = [e3, !!r2], i2;
    }, this.unsubscribe = function(t2) {
      for (var e3 in n2) if (n2[e3][t2]) return delete n2[e3][t2], 0 === Object.keys(n2[e3]).length && delete n2[e3], true;
      return false;
    }, this.publish = function(t2) {
      if (n2.hasOwnProperty(t2)) {
        var r2 = Array.prototype.slice.call(arguments, 1), a2 = [];
        for (var s2 in n2[t2]) {
          var u2 = n2[t2][s2];
          try {
            u2[0].apply(e2, r2);
          } catch (c2) {
            i$5.console && o$1.error("jsPDF PubSub Error", c2.message, c2);
          }
          u2[1] && a2.push(s2);
        }
        a2.length && a2.forEach(this.unsubscribe);
      }
    }, this.getTopics = function() {
      return n2;
    };
  }
  function O$1(t2) {
    if (!(this instanceof O$1)) return new O$1(t2);
    var e2 = "opacity,stroke-opacity".split(",");
    for (var n2 in t2) t2.hasOwnProperty(n2) && e2.indexOf(n2) >= 0 && (this[n2] = t2[n2]);
    this.id = "", this.objectNumber = -1;
  }
  function B(t2, e2) {
    this.gState = t2, this.matrix = e2, this.id = "", this.objectNumber = -1;
  }
  function M(t2, e2, n2, r2, i2) {
    if (!(this instanceof M)) return new M(t2, e2, n2, r2, i2);
    this.type = "axial" === t2 ? 2 : 3, this.coords = e2, this.colors = n2, B.call(this, r2, i2);
  }
  function q(t2, e2, n2, r2, i2) {
    if (!(this instanceof q)) return new q(t2, e2, n2, r2, i2);
    this.boundingBox = t2, this.xStep = e2, this.yStep = n2, this.stream = "", this.cloneIndex = 0, B.call(this, r2, i2);
  }
  function E$1(e2) {
    var n2, r2 = "string" == typeof arguments[0] ? arguments[0] : "p", a2 = arguments[1], s2 = arguments[2], u2 = arguments[3], c2 = [], f2 = 1, p2 = 16, g2 = "S", m2 = null;
    "object" === _typeof$1(e2 = e2 || {}) && (r2 = e2.orientation, a2 = e2.unit || a2, s2 = e2.format || s2, u2 = e2.compress || e2.compressPdf || u2, null !== (m2 = e2.encryption || null) && (m2.userPassword = m2.userPassword || "", m2.ownerPassword = m2.ownerPassword || "", m2.userPermissions = m2.userPermissions || []), f2 = "number" == typeof e2.userUnit ? Math.abs(e2.userUnit) : 1, void 0 !== e2.precision && (n2 = e2.precision), void 0 !== e2.floatPrecision && (p2 = e2.floatPrecision), g2 = e2.defaultPathOperation || "S"), c2 = e2.filters || (true === u2 ? ["FlateEncode"] : c2), a2 = a2 || "mm", r2 = ("" + (r2 || "P")).toLowerCase();
    var v2 = e2.putOnlyUsedFonts || false, b2 = {}, y2 = { internal: {}, __private__: {} };
    y2.__private__.PubSub = C;
    var w2 = "1.3", N2 = y2.__private__.getPdfVersion = function() {
      return w2;
    };
    y2.__private__.setPdfVersion = function(t2) {
      w2 = t2;
    };
    var L2 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
    y2.__private__.getPageFormats = function() {
      return L2;
    };
    var x2 = y2.__private__.getPageFormat = function(t2) {
      return L2[t2];
    };
    s2 = s2 || "a4";
    var A2 = "compat", S2 = "advanced", _2 = A2;
    function P2() {
      this.saveGraphicsState(), lt2(new Wt2(St, 0, 0, -St, 0, _n() * St).toString() + " cm"), this.setFontSize(this.getFontSize() / St), g2 = "n", _2 = S2;
    }
    function k2() {
      this.restoreGraphicsState(), g2 = "S", _2 = A2;
    }
    var F2 = y2.__private__.combineFontStyleAndFontWeight = function(t2, e3) {
      if ("bold" == t2 && "normal" == e3 || "bold" == t2 && 400 == e3 || "normal" == t2 && "italic" == e3 || "bold" == t2 && "italic" == e3) throw new Error("Invalid Combination of fontweight and fontstyle");
      return e3 && (t2 = 400 == e3 || "normal" === e3 ? "italic" === t2 ? "italic" : "normal" : 700 != e3 && "bold" !== e3 || "normal" !== t2 ? (700 == e3 ? "bold" : e3) + "" + t2 : "bold"), t2;
    };
    y2.advancedAPI = function(t2) {
      var e3 = _2 === A2;
      return e3 && P2.call(this), "function" != typeof t2 || (t2(this), e3 && k2.call(this)), this;
    }, y2.compatAPI = function(t2) {
      var e3 = _2 === S2;
      return e3 && k2.call(this), "function" != typeof t2 || (t2(this), e3 && P2.call(this)), this;
    }, y2.isAdvancedAPI = function() {
      return _2 === S2;
    };
    var B3, R2 = function(t2) {
      if (_2 !== S2) throw new Error(t2 + " is only available in 'advanced' API mode. You need to call advancedAPI() first.");
    }, D2 = y2.roundToPrecision = y2.__private__.roundToPrecision = function(t2, e3) {
      var r3 = n2 || e3;
      if (isNaN(t2) || isNaN(r3)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision");
      return t2.toFixed(r3).replace(/0+$/, "");
    };
    B3 = y2.hpf = y2.__private__.hpf = "number" == typeof p2 ? function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t2, p2);
    } : "smart" === p2 ? function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t2, t2 > -1 && t2 < 1 ? 16 : 5);
    } : function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.hpf");
      return D2(t2, 16);
    };
    var T2 = y2.f2 = y2.__private__.f2 = function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f2");
      return D2(t2, 2);
    }, z2 = y2.__private__.f3 = function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.f3");
      return D2(t2, 3);
    }, U2 = y2.scale = y2.__private__.scale = function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.scale");
      return _2 === A2 ? t2 * St : _2 === S2 ? t2 : void 0;
    }, H4 = function(t2) {
      return U2((function(t3) {
        return _2 === A2 ? _n() - t3 : _2 === S2 ? t3 : void 0;
      })(t2));
    };
    y2.__private__.setPrecision = y2.setPrecision = function(t2) {
      "number" == typeof parseInt(t2, 10) && (n2 = parseInt(t2, 10));
    };
    var W2, V2 = "00000000000000000000000000000000", G2 = y2.__private__.getFileId = function() {
      return V2;
    }, Y2 = y2.__private__.setFileId = function(t2) {
      return V2 = void 0 !== t2 && /^[a-fA-F0-9]{32}$/.test(t2) ? t2.toUpperCase() : V2.split("").map(function() {
        return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random()));
      }).join(""), null !== m2 && (je2 = new I(m2.userPermissions, m2.userPassword, m2.ownerPassword, V2)), V2;
    };
    y2.setFileId = function(t2) {
      return Y2(t2), this;
    }, y2.getFileId = function() {
      return G2();
    };
    var J2 = y2.__private__.convertDateToPDFDate = function(t2) {
      var e3 = t2.getTimezoneOffset(), n3 = e3 < 0 ? "+" : "-", r3 = Math.floor(Math.abs(e3 / 60)), i2 = Math.abs(e3 % 60), a3 = [n3, Q2(r3), "'", Q2(i2), "'"].join("");
      return ["D:", t2.getFullYear(), Q2(t2.getMonth() + 1), Q2(t2.getDate()), Q2(t2.getHours()), Q2(t2.getMinutes()), Q2(t2.getSeconds()), a3].join("");
    }, X2 = y2.__private__.convertPDFDateToDate = function(t2) {
      var e3 = parseInt(t2.substr(2, 4), 10), n3 = parseInt(t2.substr(6, 2), 10) - 1, r3 = parseInt(t2.substr(8, 2), 10), i2 = parseInt(t2.substr(10, 2), 10), a3 = parseInt(t2.substr(12, 2), 10), o2 = parseInt(t2.substr(14, 2), 10);
      return new Date(e3, n3, r3, i2, a3, o2, 0);
    }, K2 = y2.__private__.setCreationDate = function(t2) {
      var e3;
      if (void 0 === t2 && (t2 = /* @__PURE__ */ new Date()), t2 instanceof Date) e3 = J2(t2);
      else {
        if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(t2)) throw new Error("Invalid argument passed to jsPDF.setCreationDate");
        e3 = t2;
      }
      return W2 = e3;
    }, Z2 = y2.__private__.getCreationDate = function(t2) {
      var e3 = W2;
      return "jsDate" === t2 && (e3 = X2(W2)), e3;
    };
    y2.setCreationDate = function(t2) {
      return K2(t2), this;
    }, y2.getCreationDate = function(t2) {
      return Z2(t2);
    };
    var $2, Q2 = y2.__private__.padd2 = function(t2) {
      return ("0" + parseInt(t2)).slice(-2);
    }, tt2 = y2.__private__.padd2Hex = function(t2) {
      return ("00" + (t2 = t2.toString())).substr(t2.length);
    }, et2 = 0, nt2 = [], rt2 = [], it2 = 0, at2 = [], ot2 = [], st2 = false, ut2 = rt2;
    y2.__private__.setCustomOutputDestination = function(t2) {
      st2 = true, ut2 = t2;
    };
    var ct2 = function(t2) {
      st2 || (ut2 = t2);
    };
    y2.__private__.resetCustomOutputDestination = function() {
      st2 = false, ut2 = rt2;
    };
    var lt2 = y2.__private__.out = function(t2) {
      return t2 = t2.toString(), it2 += t2.length + 1, ut2.push(t2), ut2;
    }, ht2 = y2.__private__.write = function(t2) {
      return lt2(1 === arguments.length ? t2.toString() : Array.prototype.join.call(arguments, " "));
    }, ft2 = y2.__private__.getArrayBuffer = function(t2) {
      for (var e3 = t2.length, n3 = new ArrayBuffer(e3), r3 = new Uint8Array(n3); e3--; ) r3[e3] = t2.charCodeAt(e3);
      return n3;
    }, dt2 = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]];
    y2.__private__.getStandardFonts = function() {
      return dt2;
    };
    var pt2 = e2.fontSize || 16;
    y2.__private__.setFontSize = y2.setFontSize = function(t2) {
      return pt2 = _2 === S2 ? t2 / St : t2, this;
    };
    var gt2, mt2 = y2.__private__.getFontSize = y2.getFontSize = function() {
      return _2 === A2 ? pt2 : pt2 * St;
    }, vt2 = e2.R2L || false;
    y2.__private__.setR2L = y2.setR2L = function(t2) {
      return vt2 = t2, this;
    }, y2.__private__.getR2L = y2.getR2L = function() {
      return vt2;
    };
    var bt2, yt2 = y2.__private__.setZoomMode = function(t2) {
      if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(t2)) gt2 = t2;
      else if (isNaN(t2)) {
        if (-1 === [void 0, null, "fullwidth", "fullheight", "fullpage", "original"].indexOf(t2)) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + t2 + '" is not recognized.');
        gt2 = t2;
      } else gt2 = parseInt(t2, 10);
    };
    y2.__private__.getZoomMode = function() {
      return gt2;
    };
    var wt2, Nt2 = y2.__private__.setPageMode = function(t2) {
      if (-1 == [void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(t2)) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + t2 + '" is not recognized.');
      bt2 = t2;
    };
    y2.__private__.getPageMode = function() {
      return bt2;
    };
    var Lt2 = y2.__private__.setLayoutMode = function(t2) {
      if (-1 == [void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(t2)) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + t2 + '" is not recognized.');
      wt2 = t2;
    };
    y2.__private__.getLayoutMode = function() {
      return wt2;
    }, y2.__private__.setDisplayMode = y2.setDisplayMode = function(t2, e3, n3) {
      return yt2(t2), Lt2(e3), Nt2(n3), this;
    };
    var xt2 = { title: "", subject: "", author: "", keywords: "", creator: "" };
    y2.__private__.getDocumentProperty = function(t2) {
      if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty");
      return xt2[t2];
    }, y2.__private__.getDocumentProperties = function() {
      return xt2;
    }, y2.__private__.setDocumentProperties = y2.setProperties = y2.setDocumentProperties = function(t2) {
      for (var e3 in xt2) xt2.hasOwnProperty(e3) && t2[e3] && (xt2[e3] = t2[e3]);
      return this;
    }, y2.__private__.setDocumentProperty = function(t2, e3) {
      if (-1 === Object.keys(xt2).indexOf(t2)) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty");
      return xt2[t2] = e3;
    };
    var At2, St, _t2, Pt2, kt2, Ft2 = {}, It2 = {}, jt2 = [], Ct2 = {}, Ot2 = {}, Bt2 = {}, Mt2 = {}, qt2 = null, Et2 = 0, Rt2 = [], Dt2 = new C(y2), Tt2 = e2.hotfixes || [], zt2 = {}, Ut2 = {}, Ht2 = [], Wt2 = function t2(e3, n3, r3, i2, a3, o2) {
      if (!(this instanceof t2)) return new t2(e3, n3, r3, i2, a3, o2);
      isNaN(e3) && (e3 = 1), isNaN(n3) && (n3 = 0), isNaN(r3) && (r3 = 0), isNaN(i2) && (i2 = 1), isNaN(a3) && (a3 = 0), isNaN(o2) && (o2 = 0), this._matrix = [e3, n3, r3, i2, a3, o2];
    };
    Object.defineProperty(Wt2.prototype, "sx", { get: function() {
      return this._matrix[0];
    }, set: function(t2) {
      this._matrix[0] = t2;
    } }), Object.defineProperty(Wt2.prototype, "shy", { get: function() {
      return this._matrix[1];
    }, set: function(t2) {
      this._matrix[1] = t2;
    } }), Object.defineProperty(Wt2.prototype, "shx", { get: function() {
      return this._matrix[2];
    }, set: function(t2) {
      this._matrix[2] = t2;
    } }), Object.defineProperty(Wt2.prototype, "sy", { get: function() {
      return this._matrix[3];
    }, set: function(t2) {
      this._matrix[3] = t2;
    } }), Object.defineProperty(Wt2.prototype, "tx", { get: function() {
      return this._matrix[4];
    }, set: function(t2) {
      this._matrix[4] = t2;
    } }), Object.defineProperty(Wt2.prototype, "ty", { get: function() {
      return this._matrix[5];
    }, set: function(t2) {
      this._matrix[5] = t2;
    } }), Object.defineProperty(Wt2.prototype, "a", { get: function() {
      return this._matrix[0];
    }, set: function(t2) {
      this._matrix[0] = t2;
    } }), Object.defineProperty(Wt2.prototype, "b", { get: function() {
      return this._matrix[1];
    }, set: function(t2) {
      this._matrix[1] = t2;
    } }), Object.defineProperty(Wt2.prototype, "c", { get: function() {
      return this._matrix[2];
    }, set: function(t2) {
      this._matrix[2] = t2;
    } }), Object.defineProperty(Wt2.prototype, "d", { get: function() {
      return this._matrix[3];
    }, set: function(t2) {
      this._matrix[3] = t2;
    } }), Object.defineProperty(Wt2.prototype, "e", { get: function() {
      return this._matrix[4];
    }, set: function(t2) {
      this._matrix[4] = t2;
    } }), Object.defineProperty(Wt2.prototype, "f", { get: function() {
      return this._matrix[5];
    }, set: function(t2) {
      this._matrix[5] = t2;
    } }), Object.defineProperty(Wt2.prototype, "rotation", { get: function() {
      return Math.atan2(this.shx, this.sx);
    } }), Object.defineProperty(Wt2.prototype, "scaleX", { get: function() {
      return this.decompose().scale.sx;
    } }), Object.defineProperty(Wt2.prototype, "scaleY", { get: function() {
      return this.decompose().scale.sy;
    } }), Object.defineProperty(Wt2.prototype, "isIdentity", { get: function() {
      return 1 === this.sx && 0 === this.shy && 0 === this.shx && 1 === this.sy && 0 === this.tx && 0 === this.ty;
    } }), Wt2.prototype.join = function(t2) {
      return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(B3).join(t2);
    }, Wt2.prototype.multiply = function(t2) {
      var e3 = t2.sx * this.sx + t2.shy * this.shx, n3 = t2.sx * this.shy + t2.shy * this.sy, r3 = t2.shx * this.sx + t2.sy * this.shx, i2 = t2.shx * this.shy + t2.sy * this.sy, a3 = t2.tx * this.sx + t2.ty * this.shx + this.tx, o2 = t2.tx * this.shy + t2.ty * this.sy + this.ty;
      return new Wt2(e3, n3, r3, i2, a3, o2);
    }, Wt2.prototype.decompose = function() {
      var t2 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty, o2 = Math.sqrt(t2 * t2 + e3 * e3), s3 = (t2 /= o2) * n3 + (e3 /= o2) * r3;
      n3 -= t2 * s3, r3 -= e3 * s3;
      var u3 = Math.sqrt(n3 * n3 + r3 * r3);
      return s3 /= u3, t2 * (r3 /= u3) < e3 * (n3 /= u3) && (t2 = -t2, e3 = -e3, s3 = -s3, o2 = -o2), { scale: new Wt2(o2, 0, 0, u3, 0, 0), translate: new Wt2(1, 0, 0, 1, i2, a3), rotate: new Wt2(t2, e3, -e3, t2, 0, 0), skew: new Wt2(1, 0, s3, 1, 0, 0) };
    }, Wt2.prototype.toString = function(t2) {
      return this.join(" ");
    }, Wt2.prototype.inversed = function() {
      var t2 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty, o2 = 1 / (t2 * r3 - e3 * n3), s3 = r3 * o2, u3 = -e3 * o2, c3 = -n3 * o2, l2 = t2 * o2;
      return new Wt2(s3, u3, c3, l2, -s3 * i2 - c3 * a3, -u3 * i2 - l2 * a3);
    }, Wt2.prototype.applyToPoint = function(t2) {
      var e3 = t2.x * this.sx + t2.y * this.shx + this.tx, n3 = t2.x * this.shy + t2.y * this.sy + this.ty;
      return new gn(e3, n3);
    }, Wt2.prototype.applyToRectangle = function(t2) {
      var e3 = this.applyToPoint(t2), n3 = this.applyToPoint(new gn(t2.x + t2.w, t2.y + t2.h));
      return new mn(e3.x, e3.y, n3.x - e3.x, n3.y - e3.y);
    }, Wt2.prototype.clone = function() {
      var t2 = this.sx, e3 = this.shy, n3 = this.shx, r3 = this.sy, i2 = this.tx, a3 = this.ty;
      return new Wt2(t2, e3, n3, r3, i2, a3);
    }, y2.Matrix = Wt2;
    var Vt2 = y2.matrixMult = function(t2, e3) {
      return e3.multiply(t2);
    }, Gt2 = new Wt2(1, 0, 0, 1, 0, 0);
    y2.unitMatrix = y2.identityMatrix = Gt2;
    var Yt2 = function(t2, e3) {
      if (!Ot2[t2]) {
        var n3 = (e3 instanceof M ? "Sh" : "P") + (Object.keys(Ct2).length + 1).toString(10);
        e3.id = n3, Ot2[t2] = n3, Ct2[n3] = e3, Dt2.publish("addPattern", e3);
      }
    };
    y2.ShadingPattern = M, y2.TilingPattern = q, y2.addShadingPattern = function(t2, e3) {
      return R2("addShadingPattern()"), Yt2(t2, e3), this;
    }, y2.beginTilingPattern = function(t2) {
      R2("beginTilingPattern()"), bn(t2.boundingBox[0], t2.boundingBox[1], t2.boundingBox[2] - t2.boundingBox[0], t2.boundingBox[3] - t2.boundingBox[1], t2.matrix);
    }, y2.endTilingPattern = function(t2, e3) {
      R2("endTilingPattern()"), e3.stream = ot2[$2].join("\n"), Yt2(t2, e3), Dt2.publish("endTilingPattern", e3), Ht2.pop().restore();
    };
    var Jt2, Xt2 = y2.__private__.newObject = function() {
      var t2 = Kt2();
      return Zt2(t2, true), t2;
    }, Kt2 = y2.__private__.newObjectDeferred = function() {
      return et2++, nt2[et2] = function() {
        return it2;
      }, et2;
    }, Zt2 = function(t2, e3) {
      return e3 = "boolean" == typeof e3 && e3, nt2[t2] = it2, e3 && lt2(t2 + " 0 obj"), t2;
    }, $t2 = y2.__private__.newAdditionalObject = function() {
      var t2 = { objId: Kt2(), content: "" };
      return at2.push(t2), t2;
    }, Qt2 = Kt2(), te2 = Kt2(), ee2 = y2.__private__.decodeColorString = function(t2) {
      var e3 = t2.split(" ");
      if (2 !== e3.length || "g" !== e3[1] && "G" !== e3[1]) 5 !== e3.length || "k" !== e3[4] && "K" !== e3[4] || (e3 = [(1 - e3[0]) * (1 - e3[3]), (1 - e3[1]) * (1 - e3[3]), (1 - e3[2]) * (1 - e3[3]), "r"]);
      else {
        var n3 = parseFloat(e3[0]);
        e3 = [n3, n3, n3, "r"];
      }
      for (var r3 = "#", i2 = 0; i2 < 3; i2++) r3 += ("0" + Math.floor(255 * parseFloat(e3[i2])).toString(16)).slice(-2);
      return r3;
    }, ne2 = y2.__private__.encodeColorString = function(e3) {
      var n3;
      "string" == typeof e3 && (e3 = { ch1: e3 });
      var r3 = e3.ch1, i2 = e3.ch2, a3 = e3.ch3, o2 = e3.ch4, s3 = "draw" === e3.pdfColorType ? ["G", "RG", "K"] : ["g", "rg", "k"];
      if ("string" == typeof r3 && "#" !== r3.charAt(0)) {
        var u3 = new h$1(r3);
        if (u3.ok) r3 = u3.toHex();
        else if (!/^\d*\.?\d*$/.test(r3)) throw new Error('Invalid color "' + r3 + '" passed to jsPDF.encodeColorString.');
      }
      if ("string" == typeof r3 && /^#[0-9A-Fa-f]{3}$/.test(r3) && (r3 = "#" + r3[1] + r3[1] + r3[2] + r3[2] + r3[3] + r3[3]), "string" == typeof r3 && /^#[0-9A-Fa-f]{6}$/.test(r3)) {
        var c3 = parseInt(r3.substr(1), 16);
        r3 = c3 >> 16 & 255, i2 = c3 >> 8 & 255, a3 = 255 & c3;
      }
      if (void 0 === i2 || void 0 === o2 && r3 === i2 && i2 === a3) n3 = "string" == typeof r3 ? r3 + " " + s3[0] : 2 === e3.precision ? T2(r3 / 255) + " " + s3[0] : z2(r3 / 255) + " " + s3[0];
      else if (void 0 === o2 || "object" === _typeof$1(o2)) {
        if (o2 && !isNaN(o2.a) && 0 === o2.a) return ["1.", "1.", "1.", s3[1]].join(" ");
        n3 = "string" == typeof r3 ? [r3, i2, a3, s3[1]].join(" ") : 2 === e3.precision ? [T2(r3 / 255), T2(i2 / 255), T2(a3 / 255), s3[1]].join(" ") : [z2(r3 / 255), z2(i2 / 255), z2(a3 / 255), s3[1]].join(" ");
      } else n3 = "string" == typeof r3 ? [r3, i2, a3, o2, s3[2]].join(" ") : 2 === e3.precision ? [T2(r3), T2(i2), T2(a3), T2(o2), s3[2]].join(" ") : [z2(r3), z2(i2), z2(a3), z2(o2), s3[2]].join(" ");
      return n3;
    }, re2 = y2.__private__.getFilters = function() {
      return c2;
    }, ie2 = y2.__private__.putStream = function(t2) {
      var e3 = (t2 = t2 || {}).data || "", n3 = t2.filters || re2(), r3 = t2.alreadyAppliedFilters || [], i2 = t2.addLength1 || false, a3 = e3.length, o2 = t2.objectId, s3 = function(t3) {
        return t3;
      };
      if (null !== m2 && void 0 === o2) throw new Error("ObjectId must be passed to putStream for file encryption");
      null !== m2 && (s3 = je2.encryptor(o2, 0));
      var u3 = {};
      true === n3 && (n3 = ["FlateEncode"]);
      var c3 = t2.additionalKeyValues || [], l2 = (u3 = void 0 !== E$1.API.processDataByFilters ? E$1.API.processDataByFilters(e3, n3) : { data: e3, reverseChain: [] }).reverseChain + (Array.isArray(r3) ? r3.join(" ") : r3.toString());
      if (0 !== u3.data.length && (c3.push({ key: "Length", value: u3.data.length }), true === i2 && c3.push({ key: "Length1", value: a3 })), 0 != l2.length) if (l2.split("/").length - 1 == 1) c3.push({ key: "Filter", value: l2 });
      else {
        c3.push({ key: "Filter", value: "[" + l2 + "]" });
        for (var h2 = 0; h2 < c3.length; h2 += 1) if ("DecodeParms" === c3[h2].key) {
          for (var f3 = [], d2 = 0; d2 < u3.reverseChain.split("/").length - 1; d2 += 1) f3.push("null");
          f3.push(c3[h2].value), c3[h2].value = "[" + f3.join(" ") + "]";
        }
      }
      lt2("<<");
      for (var p3 = 0; p3 < c3.length; p3++) lt2("/" + c3[p3].key + " " + c3[p3].value);
      lt2(">>"), 0 !== u3.data.length && (lt2("stream"), lt2(s3(u3.data)), lt2("endstream"));
    }, ae2 = y2.__private__.putPage = function(t2) {
      var e3 = t2.number, n3 = t2.data, r3 = t2.objId, i2 = t2.contentsObjId;
      Zt2(r3, true), lt2("<</Type /Page"), lt2("/Parent " + t2.rootDictionaryObjId + " 0 R"), lt2("/Resources " + t2.resourceDictionaryObjId + " 0 R"), lt2("/MediaBox [" + parseFloat(B3(t2.mediaBox.bottomLeftX)) + " " + parseFloat(B3(t2.mediaBox.bottomLeftY)) + " " + B3(t2.mediaBox.topRightX) + " " + B3(t2.mediaBox.topRightY) + "]"), null !== t2.cropBox && lt2("/CropBox [" + B3(t2.cropBox.bottomLeftX) + " " + B3(t2.cropBox.bottomLeftY) + " " + B3(t2.cropBox.topRightX) + " " + B3(t2.cropBox.topRightY) + "]"), null !== t2.bleedBox && lt2("/BleedBox [" + B3(t2.bleedBox.bottomLeftX) + " " + B3(t2.bleedBox.bottomLeftY) + " " + B3(t2.bleedBox.topRightX) + " " + B3(t2.bleedBox.topRightY) + "]"), null !== t2.trimBox && lt2("/TrimBox [" + B3(t2.trimBox.bottomLeftX) + " " + B3(t2.trimBox.bottomLeftY) + " " + B3(t2.trimBox.topRightX) + " " + B3(t2.trimBox.topRightY) + "]"), null !== t2.artBox && lt2("/ArtBox [" + B3(t2.artBox.bottomLeftX) + " " + B3(t2.artBox.bottomLeftY) + " " + B3(t2.artBox.topRightX) + " " + B3(t2.artBox.topRightY) + "]"), "number" == typeof t2.userUnit && 1 !== t2.userUnit && lt2("/UserUnit " + t2.userUnit), Dt2.publish("putPage", { objId: r3, pageContext: Rt2[e3], pageNumber: e3, page: n3 }), lt2("/Contents " + i2 + " 0 R"), lt2(">>"), lt2("endobj");
      var a3 = n3.join("\n");
      return _2 === S2 && (a3 += "\nQ"), Zt2(i2, true), ie2({ data: a3, filters: re2(), objectId: i2 }), lt2("endobj"), r3;
    }, oe2 = y2.__private__.putPages = function() {
      var t2, e3, n3 = [];
      for (t2 = 1; t2 <= Et2; t2++) Rt2[t2].objId = Kt2(), Rt2[t2].contentsObjId = Kt2();
      for (t2 = 1; t2 <= Et2; t2++) n3.push(ae2({ number: t2, data: ot2[t2], objId: Rt2[t2].objId, contentsObjId: Rt2[t2].contentsObjId, mediaBox: Rt2[t2].mediaBox, cropBox: Rt2[t2].cropBox, bleedBox: Rt2[t2].bleedBox, trimBox: Rt2[t2].trimBox, artBox: Rt2[t2].artBox, userUnit: Rt2[t2].userUnit, rootDictionaryObjId: Qt2, resourceDictionaryObjId: te2 }));
      Zt2(Qt2, true), lt2("<</Type /Pages");
      var r3 = "/Kids [";
      for (e3 = 0; e3 < Et2; e3++) r3 += n3[e3] + " 0 R ";
      lt2(r3 + "]"), lt2("/Count " + Et2), lt2(">>"), lt2("endobj"), Dt2.publish("postPutPages");
    }, se2 = function(t2) {
      Dt2.publish("putFont", { font: t2, out: lt2, newObject: Xt2, putStream: ie2 }), true !== t2.isAlreadyPutted && (t2.objectNumber = Xt2(), lt2("<<"), lt2("/Type /Font"), lt2("/BaseFont /" + j(t2.postScriptName)), lt2("/Subtype /Type1"), "string" == typeof t2.encoding && lt2("/Encoding /" + t2.encoding), lt2("/FirstChar 32"), lt2("/LastChar 255"), lt2(">>"), lt2("endobj"));
    }, ue2 = function(t2) {
      t2.objectNumber = Xt2();
      var e3 = [];
      e3.push({ key: "Type", value: "/XObject" }), e3.push({ key: "Subtype", value: "/Form" }), e3.push({ key: "BBox", value: "[" + [B3(t2.x), B3(t2.y), B3(t2.x + t2.width), B3(t2.y + t2.height)].join(" ") + "]" }), e3.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" });
      var n3 = t2.pages[1].join("\n");
      ie2({ data: n3, additionalKeyValues: e3, objectId: t2.objectNumber }), lt2("endobj");
    }, ce2 = function(t2, e3) {
      e3 || (e3 = 21);
      var n3 = Xt2(), r3 = (function(t3, e4) {
        var n4, r4 = [], i3 = 1 / (e4 - 1);
        for (n4 = 0; n4 < 1; n4 += i3) r4.push(n4);
        if (r4.push(1), 0 != t3[0].offset) {
          var a4 = { offset: 0, color: t3[0].color };
          t3.unshift(a4);
        }
        if (1 != t3[t3.length - 1].offset) {
          var o2 = { offset: 1, color: t3[t3.length - 1].color };
          t3.push(o2);
        }
        for (var s3 = "", u3 = 0, c3 = 0; c3 < r4.length; c3++) {
          for (n4 = r4[c3]; n4 > t3[u3 + 1].offset; ) u3++;
          var l2 = t3[u3].offset, h2 = (n4 - l2) / (t3[u3 + 1].offset - l2), f3 = t3[u3].color, d2 = t3[u3 + 1].color;
          s3 += tt2(Math.round((1 - h2) * f3[0] + h2 * d2[0]).toString(16)) + tt2(Math.round((1 - h2) * f3[1] + h2 * d2[1]).toString(16)) + tt2(Math.round((1 - h2) * f3[2] + h2 * d2[2]).toString(16));
        }
        return s3.trim();
      })(t2.colors, e3), i2 = [];
      i2.push({ key: "FunctionType", value: "0" }), i2.push({ key: "Domain", value: "[0.0 1.0]" }), i2.push({ key: "Size", value: "[" + e3 + "]" }), i2.push({ key: "BitsPerSample", value: "8" }), i2.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), i2.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ie2({ data: r3, additionalKeyValues: i2, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: n3 }), lt2("endobj"), t2.objectNumber = Xt2(), lt2("<< /ShadingType " + t2.type), lt2("/ColorSpace /DeviceRGB");
      var a3 = "/Coords [" + B3(parseFloat(t2.coords[0])) + " " + B3(parseFloat(t2.coords[1])) + " ";
      2 === t2.type ? a3 += B3(parseFloat(t2.coords[2])) + " " + B3(parseFloat(t2.coords[3])) : a3 += B3(parseFloat(t2.coords[2])) + " " + B3(parseFloat(t2.coords[3])) + " " + B3(parseFloat(t2.coords[4])) + " " + B3(parseFloat(t2.coords[5])), lt2(a3 += "]"), t2.matrix && lt2("/Matrix [" + t2.matrix.toString() + "]"), lt2("/Function " + n3 + " 0 R"), lt2("/Extend [true true]"), lt2(">>"), lt2("endobj");
    }, le2 = function(t2, e3) {
      var n3 = Kt2(), r3 = Xt2();
      e3.push({ resourcesOid: n3, objectOid: r3 }), t2.objectNumber = r3;
      var i2 = [];
      i2.push({ key: "Type", value: "/Pattern" }), i2.push({ key: "PatternType", value: "1" }), i2.push({ key: "PaintType", value: "1" }), i2.push({ key: "TilingType", value: "1" }), i2.push({ key: "BBox", value: "[" + t2.boundingBox.map(B3).join(" ") + "]" }), i2.push({ key: "XStep", value: B3(t2.xStep) }), i2.push({ key: "YStep", value: B3(t2.yStep) }), i2.push({ key: "Resources", value: n3 + " 0 R" }), t2.matrix && i2.push({ key: "Matrix", value: "[" + t2.matrix.toString() + "]" }), ie2({ data: t2.stream, additionalKeyValues: i2, objectId: t2.objectNumber }), lt2("endobj");
    }, he2 = function(t2) {
      for (var e3 in t2.objectNumber = Xt2(), lt2("<<"), t2) switch (e3) {
        case "opacity":
          lt2("/ca " + T2(t2[e3]));
          break;
        case "stroke-opacity":
          lt2("/CA " + T2(t2[e3]));
      }
      lt2(">>"), lt2("endobj");
    }, fe2 = function(t2) {
      Zt2(t2.resourcesOid, true), lt2("<<"), lt2("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), (function() {
        for (var t3 in lt2("/Font <<"), Ft2) Ft2.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && lt2("/" + t3 + " " + Ft2[t3].objectNumber + " 0 R");
        lt2(">>");
      })(), (function() {
        if (Object.keys(Ct2).length > 0) {
          for (var t3 in lt2("/Shading <<"), Ct2) Ct2.hasOwnProperty(t3) && Ct2[t3] instanceof M && Ct2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Ct2[t3].objectNumber + " 0 R");
          Dt2.publish("putShadingPatternDict"), lt2(">>");
        }
      })(), (function(t3) {
        if (Object.keys(Ct2).length > 0) {
          for (var e3 in lt2("/Pattern <<"), Ct2) Ct2.hasOwnProperty(e3) && Ct2[e3] instanceof y2.TilingPattern && Ct2[e3].objectNumber >= 0 && Ct2[e3].objectNumber < t3 && lt2("/" + e3 + " " + Ct2[e3].objectNumber + " 0 R");
          Dt2.publish("putTilingPatternDict"), lt2(">>");
        }
      })(t2.objectOid), (function() {
        if (Object.keys(Bt2).length > 0) {
          var t3;
          for (t3 in lt2("/ExtGState <<"), Bt2) Bt2.hasOwnProperty(t3) && Bt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + Bt2[t3].objectNumber + " 0 R");
          Dt2.publish("putGStateDict"), lt2(">>");
        }
      })(), (function() {
        for (var t3 in lt2("/XObject <<"), zt2) zt2.hasOwnProperty(t3) && zt2[t3].objectNumber >= 0 && lt2("/" + t3 + " " + zt2[t3].objectNumber + " 0 R");
        Dt2.publish("putXobjectDict"), lt2(">>");
      })(), lt2(">>"), lt2("endobj");
    }, de2 = function(t2) {
      It2[t2.fontName] = It2[t2.fontName] || {}, It2[t2.fontName][t2.fontStyle] = t2.id;
    }, pe2 = function(t2, e3, n3, r3, i2) {
      var a3 = { id: "F" + (Object.keys(Ft2).length + 1).toString(10), postScriptName: t2, fontName: e3, fontStyle: n3, encoding: r3, isStandardFont: i2 || false, metadata: {} };
      return Dt2.publish("addFont", { font: a3, instance: this }), Ft2[a3.id] = a3, de2(a3), a3.id;
    }, ge2 = y2.__private__.pdfEscape = y2.pdfEscape = function(t2, e3) {
      return (function(t3, e4) {
        var n3, r3, i2, a3, o2, s3, u3, c3, l2;
        if (i2 = (e4 = e4 || {}).sourceEncoding || "Unicode", o2 = e4.outputEncoding, (e4.autoencode || o2) && Ft2[At2].metadata && Ft2[At2].metadata[i2] && Ft2[At2].metadata[i2].encoding && (a3 = Ft2[At2].metadata[i2].encoding, !o2 && Ft2[At2].encoding && (o2 = Ft2[At2].encoding), !o2 && a3.codePages && (o2 = a3.codePages[0]), "string" == typeof o2 && (o2 = a3[o2]), o2)) {
          for (u3 = false, s3 = [], n3 = 0, r3 = t3.length; n3 < r3; n3++) (c3 = o2[t3.charCodeAt(n3)]) ? s3.push(String.fromCharCode(c3)) : s3.push(t3[n3]), s3[n3].charCodeAt(0) >> 8 && (u3 = true);
          t3 = s3.join("");
        }
        for (n3 = t3.length; void 0 === u3 && 0 !== n3; ) t3.charCodeAt(n3 - 1) >> 8 && (u3 = true), n3--;
        if (!u3) return t3;
        for (s3 = e4.noBOM ? [] : [254, 255], n3 = 0, r3 = t3.length; n3 < r3; n3++) {
          if ((l2 = (c3 = t3.charCodeAt(n3)) >> 8) >> 8) throw new Error("Character at position " + n3 + " of string '" + t3 + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
          s3.push(l2), s3.push(c3 - (l2 << 8));
        }
        return String.fromCharCode.apply(void 0, s3);
      })(t2, e3).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
    }, me2 = y2.__private__.beginPage = function(t2) {
      ot2[++Et2] = [], Rt2[Et2] = { objId: 0, contentsObjId: 0, userUnit: Number(f2), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(t2[0]), topRightY: Number(t2[1]) } }, ye2(Et2), ct2(ot2[$2]);
    }, ve2 = function(t2, e3) {
      var n3, i2, a3;
      switch (r2 = e3 || r2, "string" == typeof t2 && (n3 = x2(t2.toLowerCase()), Array.isArray(n3) && (i2 = n3[0], a3 = n3[1])), Array.isArray(t2) && (i2 = t2[0] * St, a3 = t2[1] * St), isNaN(i2) && (i2 = s2[0], a3 = s2[1]), (i2 > 14400 || a3 > 14400) && (o$1.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), i2 = Math.min(14400, i2), a3 = Math.min(14400, a3)), s2 = [i2, a3], r2.substr(0, 1)) {
        case "l":
          a3 > i2 && (s2 = [a3, i2]);
          break;
        case "p":
          i2 > a3 && (s2 = [a3, i2]);
      }
      me2(s2), Ze(Xe), lt2(on), 0 !== fn && lt2(fn + " J"), 0 !== dn && lt2(dn + " j"), Dt2.publish("addPage", { pageNumber: Et2 });
    }, be2 = function(t2) {
      t2 > 0 && t2 <= Et2 && (ot2.splice(t2, 1), Rt2.splice(t2, 1), Et2--, $2 > Et2 && ($2 = Et2), this.setPage($2));
    }, ye2 = function(t2) {
      t2 > 0 && t2 <= Et2 && ($2 = t2);
    }, we2 = y2.__private__.getNumberOfPages = y2.getNumberOfPages = function() {
      return ot2.length - 1;
    }, Ne2 = function(t2, e3, n3) {
      var r3, i2 = void 0;
      return n3 = n3 || {}, t2 = void 0 !== t2 ? t2 : Ft2[At2].fontName, e3 = void 0 !== e3 ? e3 : Ft2[At2].fontStyle, r3 = t2.toLowerCase(), void 0 !== It2[r3] && void 0 !== It2[r3][e3] ? i2 = It2[r3][e3] : void 0 !== It2[t2] && void 0 !== It2[t2][e3] ? i2 = It2[t2][e3] : false === n3.disableWarning && o$1.warn("Unable to look up font label for font '" + t2 + "', '" + e3 + "'. Refer to getFontList() for available fonts."), i2 || n3.noFallback || null == (i2 = It2.times[e3]) && (i2 = It2.times.normal), i2;
    }, Le2 = y2.__private__.putInfo = function() {
      var t2 = Xt2(), e3 = function(t3) {
        return t3;
      };
      for (var n3 in null !== m2 && (e3 = je2.encryptor(t2, 0)), lt2("<<"), lt2("/Producer (" + ge2(e3("jsPDF " + E$1.version)) + ")"), xt2) xt2.hasOwnProperty(n3) && xt2[n3] && lt2("/" + n3.substr(0, 1).toUpperCase() + n3.substr(1) + " (" + ge2(e3(xt2[n3])) + ")");
      lt2("/CreationDate (" + ge2(e3(W2)) + ")"), lt2(">>"), lt2("endobj");
    }, xe2 = y2.__private__.putCatalog = function(t2) {
      var e3 = (t2 = t2 || {}).rootDictionaryObjId || Qt2;
      switch (Xt2(), lt2("<<"), lt2("/Type /Catalog"), lt2("/Pages " + e3 + " 0 R"), gt2 || (gt2 = "fullwidth"), gt2) {
        case "fullwidth":
          lt2("/OpenAction [3 0 R /FitH null]");
          break;
        case "fullheight":
          lt2("/OpenAction [3 0 R /FitV null]");
          break;
        case "fullpage":
          lt2("/OpenAction [3 0 R /Fit]");
          break;
        case "original":
          lt2("/OpenAction [3 0 R /XYZ null null 1]");
          break;
        default:
          var n3 = "" + gt2;
          "%" === n3.substr(n3.length - 1) && (gt2 = parseInt(gt2) / 100), "number" == typeof gt2 && lt2("/OpenAction [3 0 R /XYZ null null " + T2(gt2) + "]");
      }
      switch (wt2 || (wt2 = "continuous"), wt2) {
        case "continuous":
          lt2("/PageLayout /OneColumn");
          break;
        case "single":
          lt2("/PageLayout /SinglePage");
          break;
        case "two":
        case "twoleft":
          lt2("/PageLayout /TwoColumnLeft");
          break;
        case "tworight":
          lt2("/PageLayout /TwoColumnRight");
      }
      bt2 && lt2("/PageMode /" + bt2), Dt2.publish("putCatalog"), lt2(">>"), lt2("endobj");
    }, Ae2 = y2.__private__.putTrailer = function() {
      lt2("trailer"), lt2("<<"), lt2("/Size " + (et2 + 1)), lt2("/Root " + et2 + " 0 R"), lt2("/Info " + (et2 - 1) + " 0 R"), null !== m2 && lt2("/Encrypt " + je2.oid + " 0 R"), lt2("/ID [ <" + V2 + "> <" + V2 + "> ]"), lt2(">>");
    }, Se2 = y2.__private__.putHeader = function() {
      lt2("%PDF-" + w2), lt2("%");
    }, _e2 = y2.__private__.putXRef = function() {
      var t2 = "0000000000";
      lt2("xref"), lt2("0 " + (et2 + 1)), lt2("0000000000 65535 f ");
      for (var e3 = 1; e3 <= et2; e3++) "function" == typeof nt2[e3] ? lt2((t2 + nt2[e3]()).slice(-10) + " 00000 n ") : void 0 !== nt2[e3] ? lt2((t2 + nt2[e3]).slice(-10) + " 00000 n ") : lt2("0000000000 00000 n ");
    }, Pe2 = y2.__private__.buildDocument = function() {
      var t2;
      et2 = 0, it2 = 0, rt2 = [], nt2 = [], at2 = [], Qt2 = Kt2(), te2 = Kt2(), ct2(rt2), Dt2.publish("buildDocument"), Se2(), oe2(), (function() {
        Dt2.publish("putAdditionalObjects");
        for (var t3 = 0; t3 < at2.length; t3++) {
          var e4 = at2[t3];
          Zt2(e4.objId, true), lt2(e4.content), lt2("endobj");
        }
        Dt2.publish("postPutAdditionalObjects");
      })(), t2 = [], (function() {
        for (var t3 in Ft2) Ft2.hasOwnProperty(t3) && (false === v2 || true === v2 && b2.hasOwnProperty(t3)) && se2(Ft2[t3]);
      })(), (function() {
        var t3;
        for (t3 in Bt2) Bt2.hasOwnProperty(t3) && he2(Bt2[t3]);
      })(), (function() {
        for (var t3 in zt2) zt2.hasOwnProperty(t3) && ue2(zt2[t3]);
      })(), (function(t3) {
        var e4;
        for (e4 in Ct2) Ct2.hasOwnProperty(e4) && (Ct2[e4] instanceof M ? ce2(Ct2[e4]) : Ct2[e4] instanceof q && le2(Ct2[e4], t3));
      })(t2), Dt2.publish("putResources"), t2.forEach(fe2), fe2({ resourcesOid: te2, objectOid: Number.MAX_SAFE_INTEGER }), Dt2.publish("postPutResources"), null !== m2 && (je2.oid = Xt2(), lt2("<<"), lt2("/Filter /Standard"), lt2("/V " + je2.v), lt2("/R " + je2.r), lt2("/U <" + je2.toHexString(je2.U) + ">"), lt2("/O <" + je2.toHexString(je2.O) + ">"), lt2("/P " + je2.P), lt2(">>"), lt2("endobj")), Le2(), xe2();
      var e3 = it2;
      return _e2(), Ae2(), lt2("startxref"), lt2("" + e3), lt2("%%EOF"), ct2(ot2[$2]), rt2.join("\n");
    }, ke2 = y2.__private__.getBlob = function(t2) {
      return new Blob([ft2(t2)], { type: "application/pdf" });
    }, Fe2 = y2.output = y2.__private__.output = (Jt2 = function(t2, e3) {
      switch ("string" == typeof (e3 = e3 || {}) ? e3 = { filename: e3 } : e3.filename = e3.filename || "generated.pdf", t2) {
        case void 0:
          return Pe2();
        case "save":
          y2.save(e3.filename);
          break;
        case "arraybuffer":
          return ft2(Pe2());
        case "blob":
          return ke2(Pe2());
        case "bloburi":
        case "bloburl":
          if (void 0 !== i$5.URL && "function" == typeof i$5.URL.createObjectURL) return i$5.URL && i$5.URL.createObjectURL(ke2(Pe2())) || void 0;
          o$1.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser.");
          break;
        case "datauristring":
        case "dataurlstring":
          var n3 = "", r3 = Pe2();
          try {
            n3 = d(r3);
          } catch (m3) {
            n3 = d(unescape(encodeURIComponent(r3)));
          }
          return "data:application/pdf;filename=" + e3.filename + ";base64," + n3;
        case "pdfobjectnewwindow":
          if ("[object Window]" === Object.prototype.toString.call(i$5)) {
            var a3 = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", s3 = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"';
            e3.pdfObjectUrl && (a3 = e3.pdfObjectUrl, s3 = "");
            var u3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + a3 + '"' + s3 + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(e3) + ");<\/script></body></html>", c3 = i$5.open();
            return null !== c3 && c3.document.write(u3), c3;
          }
          throw new Error("The option pdfobjectnewwindow just works in a browser-environment.");
        case "pdfjsnewwindow":
          if ("[object Window]" === Object.prototype.toString.call(i$5)) {
            var l2 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (e3.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + e3.filename + '" width="500px" height="400px" /></body></html>', h2 = i$5.open();
            if (null !== h2) {
              h2.document.write(l2);
              var f3 = this;
              h2.document.documentElement.querySelector("#pdfViewer").onload = function() {
                h2.document.title = e3.filename, h2.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(f3.output("bloburl"));
              };
            }
            return h2;
          }
          throw new Error("The option pdfjsnewwindow just works in a browser-environment.");
        case "dataurlnewwindow":
          if ("[object Window]" !== Object.prototype.toString.call(i$5)) throw new Error("The option dataurlnewwindow just works in a browser-environment.");
          var p3 = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", e3) + '"></iframe></body></html>', g3 = i$5.open();
          if (null !== g3 && (g3.document.write(p3), g3.document.title = e3.filename), g3 || "undefined" == typeof safari) return g3;
          break;
        case "datauri":
        case "dataurl":
          return i$5.document.location.href = this.output("datauristring", e3);
        default:
          return null;
      }
    }, Jt2.foo = function() {
      try {
        return Jt2.apply(this, arguments);
      } catch (n3) {
        var t2 = n3.stack || "";
        ~t2.indexOf(" at ") && (t2 = t2.split(" at ")[1]);
        var e3 = "Error in function " + t2.split("\n")[0].split("<")[0] + ": " + n3.message;
        if (!i$5.console) throw new Error(e3);
        i$5.console.error(e3, n3), i$5.alert && alert(e3);
      }
    }, Jt2.foo.bar = Jt2, Jt2.foo), Ie2 = function(t2) {
      return true === Array.isArray(Tt2) && Tt2.indexOf(t2) > -1;
    };
    switch (a2) {
      case "pt":
        St = 1;
        break;
      case "mm":
        St = 72 / 25.4;
        break;
      case "cm":
        St = 72 / 2.54;
        break;
      case "in":
        St = 72;
        break;
      case "px":
        St = 1 == Ie2("px_scaling") ? 0.75 : 96 / 72;
        break;
      case "pc":
      case "em":
        St = 12;
        break;
      case "ex":
        St = 6;
        break;
      default:
        if ("number" != typeof a2) throw new Error("Invalid unit: " + a2);
        St = a2;
    }
    var je2 = null;
    K2(), Y2();
    var Ce = y2.__private__.getPageInfo = y2.getPageInfo = function(t2) {
      if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo");
      return { objId: Rt2[t2].objId, pageNumber: t2, pageContext: Rt2[t2] };
    }, Oe = y2.__private__.getPageInfoByObjId = function(t2) {
      if (isNaN(t2) || t2 % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId");
      for (var e3 in Rt2) if (Rt2[e3].objId === t2) break;
      return Ce(e3);
    }, Be = y2.__private__.getCurrentPageInfo = y2.getCurrentPageInfo = function() {
      return { objId: Rt2[$2].objId, pageNumber: $2, pageContext: Rt2[$2] };
    };
    y2.addPage = function() {
      return ve2.apply(this, arguments), this;
    }, y2.setPage = function() {
      return ye2.apply(this, arguments), ct2.call(this, ot2[$2]), this;
    }, y2.insertPage = function(t2) {
      return this.addPage(), this.movePage($2, t2), this;
    }, y2.movePage = function(t2, e3) {
      var n3, r3;
      if (t2 > e3) {
        n3 = ot2[t2], r3 = Rt2[t2];
        for (var i2 = t2; i2 > e3; i2--) ot2[i2] = ot2[i2 - 1], Rt2[i2] = Rt2[i2 - 1];
        ot2[e3] = n3, Rt2[e3] = r3, this.setPage(e3);
      } else if (t2 < e3) {
        n3 = ot2[t2], r3 = Rt2[t2];
        for (var a3 = t2; a3 < e3; a3++) ot2[a3] = ot2[a3 + 1], Rt2[a3] = Rt2[a3 + 1];
        ot2[e3] = n3, Rt2[e3] = r3, this.setPage(e3);
      }
      return this;
    }, y2.deletePage = function() {
      return be2.apply(this, arguments), this;
    }, y2.__private__.text = y2.text = function(e3, n3, r3, i2, a3) {
      var o2, s3, u3, c3, l2, h2, f3, d2, p3, g3 = (i2 = i2 || {}).scope || this;
      if ("number" == typeof e3 && "number" == typeof n3 && ("string" == typeof r3 || Array.isArray(r3))) {
        var m3 = r3;
        r3 = n3, n3 = e3, e3 = m3;
      }
      if (arguments[3] instanceof Wt2 == 0 ? (u3 = arguments[4], c3 = arguments[5], "object" === _typeof$1(f3 = arguments[3]) && null !== f3 || ("string" == typeof u3 && (c3 = u3, u3 = null), "string" == typeof f3 && (c3 = f3, f3 = null), "number" == typeof f3 && (u3 = f3, f3 = null), i2 = { flags: f3, angle: u3, align: c3 })) : (R2("The transform parameter of text() with a Matrix value"), p3 = a3), isNaN(n3) || isNaN(r3) || null == e3) throw new Error("Invalid arguments passed to jsPDF.text");
      if (0 === e3.length) return g3;
      var v3, y3 = "", w3 = "number" == typeof i2.lineHeightFactor ? i2.lineHeightFactor : Je, N3 = g3.internal.scaleFactor;
      function L3(t2) {
        return t2 = t2.split("	").join(Array(i2.TabLen || 9).join(" ")), ge2(t2, f3);
      }
      function x3(t2) {
        for (var e4, n4 = t2.concat(), r4 = [], i3 = n4.length; i3--; ) "string" == typeof (e4 = n4.shift()) ? r4.push(e4) : Array.isArray(t2) && (1 === e4.length || void 0 === e4[1] && void 0 === e4[2]) ? r4.push(e4[0]) : r4.push([e4[0], e4[1], e4[2]]);
        return r4;
      }
      function A3(t2, e4) {
        var n4;
        if ("string" == typeof t2) n4 = e4(t2)[0];
        else if (Array.isArray(t2)) {
          for (var r4, i3, a4 = t2.concat(), o3 = [], s4 = a4.length; s4--; ) "string" == typeof (r4 = a4.shift()) ? o3.push(e4(r4)[0]) : Array.isArray(r4) && "string" == typeof r4[0] && (i3 = e4(r4[0], r4[1], r4[2]), o3.push([i3[0], i3[1], i3[2]]));
          n4 = o3;
        }
        return n4;
      }
      var P3 = false, k3 = true;
      if ("string" == typeof e3) P3 = true;
      else if (Array.isArray(e3)) {
        var F3 = e3.concat();
        s3 = [];
        for (var I2, j2 = F3.length; j2--; ) ("string" != typeof (I2 = F3.shift()) || Array.isArray(I2) && "string" != typeof I2[0]) && (k3 = false);
        P3 = k3;
      }
      if (false === P3) throw new Error('Type of text must be string or Array. "' + e3 + '" is not recognized.');
      "string" == typeof e3 && (e3 = e3.match(/[\r?\n]/) ? e3.split(/\r\n|\r|\n/g) : [e3]);
      var C2 = pt2 / g3.internal.scaleFactor, O2 = C2 * (w3 - 1);
      switch (i2.baseline) {
        case "bottom":
          r3 -= O2;
          break;
        case "top":
          r3 += C2 - O2;
          break;
        case "hanging":
          r3 += C2 - 2 * O2;
          break;
        case "middle":
          r3 += C2 / 2 - O2;
      }
      if ((h2 = i2.maxWidth || 0) > 0 && ("string" == typeof e3 ? e3 = g3.splitTextToSize(e3, h2) : "[object Array]" === Object.prototype.toString.call(e3) && (e3 = e3.reduce(function(t2, e4) {
        return t2.concat(g3.splitTextToSize(e4, h2));
      }, []))), o2 = { text: e3, x: n3, y: r3, options: i2, mutex: { pdfEscape: ge2, activeFontKey: At2, fonts: Ft2, activeFontSize: pt2 } }, Dt2.publish("preProcessText", o2), e3 = o2.text, u3 = (i2 = o2.options).angle, p3 instanceof Wt2 == 0 && u3 && "number" == typeof u3) {
        u3 *= Math.PI / 180, 0 === i2.rotationDirection && (u3 = -u3), _2 === S2 && (u3 = -u3);
        var M2 = Math.cos(u3), q2 = Math.sin(u3);
        p3 = new Wt2(M2, q2, -q2, M2, 0, 0);
      } else u3 && u3 instanceof Wt2 && (p3 = u3);
      _2 !== S2 || p3 || (p3 = Gt2), void 0 !== (l2 = i2.charSpace || ln2) && (y3 += B3(U2(l2)) + " Tc\n", this.setCharSpace(this.getCharSpace() || 0)), void 0 !== (d2 = i2.horizontalScale) && (y3 += B3(100 * d2) + " Tz\n"), i2.lang;
      var E2 = -1, D3 = void 0 !== i2.renderingMode ? i2.renderingMode : i2.stroke, T3 = g3.internal.getCurrentPageInfo().pageContext;
      switch (D3) {
        case 0:
        case false:
        case "fill":
          E2 = 0;
          break;
        case 1:
        case true:
        case "stroke":
          E2 = 1;
          break;
        case 2:
        case "fillThenStroke":
          E2 = 2;
          break;
        case 3:
        case "invisible":
          E2 = 3;
          break;
        case 4:
        case "fillAndAddForClipping":
          E2 = 4;
          break;
        case 5:
        case "strokeAndAddPathForClipping":
          E2 = 5;
          break;
        case 6:
        case "fillThenStrokeAndAddToPathForClipping":
          E2 = 6;
          break;
        case 7:
        case "addToPathForClipping":
          E2 = 7;
      }
      var z3 = void 0 !== T3.usedRenderingMode ? T3.usedRenderingMode : -1;
      -1 !== E2 ? y3 += E2 + " Tr\n" : -1 !== z3 && (y3 += "0 Tr\n"), -1 !== E2 && (T3.usedRenderingMode = E2), c3 = i2.align || "left";
      var H5, W3 = pt2 * w3, V3 = g3.internal.pageSize.getWidth(), G3 = Ft2[At2];
      l2 = i2.charSpace || ln2, h2 = i2.maxWidth || 0, f3 = Object.assign({ autoencode: true, noBOM: true }, i2.flags);
      var Y3 = [], J3 = function(t2) {
        return g3.getStringUnitWidth(t2, { font: G3, charSpace: l2, fontSize: pt2, doKerning: false }) * pt2 / N3;
      };
      if ("[object Array]" === Object.prototype.toString.call(e3)) {
        var X3;
        s3 = x3(e3), "left" !== c3 && (H5 = s3.map(J3));
        var K3, Z3 = 0;
        if ("right" === c3) {
          n3 -= H5[0], e3 = [], j2 = s3.length;
          for (var $3 = 0; $3 < j2; $3++) 0 === $3 ? (K3 = en(n3), X3 = nn(r3)) : (K3 = U2(Z3 - H5[$3]), X3 = -W3), e3.push([s3[$3], K3, X3]), Z3 = H5[$3];
        } else if ("center" === c3) {
          n3 -= H5[0] / 2, e3 = [], j2 = s3.length;
          for (var Q3 = 0; Q3 < j2; Q3++) 0 === Q3 ? (K3 = en(n3), X3 = nn(r3)) : (K3 = U2((Z3 - H5[Q3]) / 2), X3 = -W3), e3.push([s3[Q3], K3, X3]), Z3 = H5[Q3];
        } else if ("left" === c3) {
          e3 = [], j2 = s3.length;
          for (var tt3 = 0; tt3 < j2; tt3++) e3.push(s3[tt3]);
        } else if ("justify" === c3 && "Identity-H" === G3.encoding) {
          e3 = [], j2 = s3.length, h2 = 0 !== h2 ? h2 : V3;
          for (var et3 = 0, nt3 = 0; nt3 < j2; nt3++) if (X3 = 0 === nt3 ? nn(r3) : -W3, K3 = 0 === nt3 ? en(n3) : et3, nt3 < j2 - 1) {
            var rt3 = U2((h2 - H5[nt3]) / (s3[nt3].split(" ").length - 1)), it3 = s3[nt3].split(" ");
            e3.push([it3[0] + " ", K3, X3]), et3 = 0;
            for (var at3 = 1; at3 < it3.length; at3++) {
              var ot3 = (J3(it3[at3 - 1] + " " + it3[at3]) - J3(it3[at3])) * N3 + rt3;
              at3 == it3.length - 1 ? e3.push([it3[at3], ot3, 0]) : e3.push([it3[at3] + " ", ot3, 0]), et3 -= ot3;
            }
          } else e3.push([s3[nt3], K3, X3]);
          e3.push(["", et3, 0]);
        } else {
          if ("justify" !== c3) throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".');
          for (e3 = [], j2 = s3.length, h2 = 0 !== h2 ? h2 : V3, nt3 = 0; nt3 < j2; nt3++) {
            X3 = 0 === nt3 ? nn(r3) : -W3, K3 = 0 === nt3 ? en(n3) : 0;
            var st3 = s3[nt3].split(" ").length - 1, ut3 = st3 > 0 ? (h2 - H5[nt3]) / st3 : 0;
            nt3 < j2 - 1 ? Y3.push(B3(U2(ut3))) : Y3.push(0), e3.push([s3[nt3], K3, X3]);
          }
        }
      }
      true === ("boolean" == typeof i2.R2L ? i2.R2L : vt2) && (e3 = A3(e3, function(t2, e4, n4) {
        return [t2.split("").reverse().join(""), e4, n4];
      })), o2 = { text: e3, x: n3, y: r3, options: i2, mutex: { pdfEscape: ge2, activeFontKey: At2, fonts: Ft2, activeFontSize: pt2 } }, Dt2.publish("postProcessText", o2), e3 = o2.text, v3 = o2.mutex.isHex || false;
      var ct3 = Ft2[At2].encoding;
      "WinAnsiEncoding" !== ct3 && "StandardEncoding" !== ct3 || (e3 = A3(e3, function(t2, e4, n4) {
        return [L3(t2), e4, n4];
      })), s3 = x3(e3), e3 = [];
      for (var ht3, ft3, dt3, gt3 = Array.isArray(s3[0]) ? 1 : 0, mt3 = "", bt3 = function(t2, e4, n4) {
        var r4 = "";
        return n4 instanceof Wt2 ? (n4 = "number" == typeof i2.angle ? Vt2(n4, new Wt2(1, 0, 0, 1, t2, e4)) : Vt2(new Wt2(1, 0, 0, 1, t2, e4), n4), _2 === S2 && (n4 = Vt2(new Wt2(1, 0, 0, -1, 0, 0), n4)), r4 = n4.join(" ") + " Tm\n") : r4 = B3(t2) + " " + B3(e4) + " Td\n", r4;
      }, yt3 = 0; yt3 < s3.length; yt3++) {
        switch (mt3 = "", gt3) {
          case 1:
            dt3 = (v3 ? "<" : "(") + s3[yt3][0] + (v3 ? ">" : ")"), ht3 = parseFloat(s3[yt3][1]), ft3 = parseFloat(s3[yt3][2]);
            break;
          case 0:
            dt3 = (v3 ? "<" : "(") + s3[yt3] + (v3 ? ">" : ")"), ht3 = en(n3), ft3 = nn(r3);
        }
        void 0 !== Y3 && void 0 !== Y3[yt3] && (mt3 = Y3[yt3] + " Tw\n"), 0 === yt3 ? e3.push(mt3 + bt3(ht3, ft3, p3) + dt3) : 0 === gt3 ? e3.push(mt3 + dt3) : 1 === gt3 && e3.push(mt3 + bt3(ht3, ft3, p3) + dt3);
      }
      e3 = 0 === gt3 ? e3.join(" Tj\nT* ") : e3.join(" Tj\n"), e3 += " Tj\n";
      var wt3 = "BT\n/";
      return wt3 += At2 + " " + pt2 + " Tf\n", wt3 += B3(pt2 * w3) + " TL\n", wt3 += un + "\n", wt3 += y3, wt3 += e3, lt2(wt3 += "ET"), b2[At2] = true, g3;
    };
    var Me = y2.__private__.clip = y2.clip = function(t2) {
      return lt2("evenodd" === t2 ? "W*" : "W"), this;
    };
    y2.clipEvenOdd = function() {
      return Me("evenodd");
    }, y2.__private__.discardPath = y2.discardPath = function() {
      return lt2("n"), this;
    };
    var qe = y2.__private__.isValidStyle = function(t2) {
      var e3 = false;
      return -1 !== [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(t2) && (e3 = true), e3;
    };
    y2.__private__.setDefaultPathOperation = y2.setDefaultPathOperation = function(t2) {
      return qe(t2) && (g2 = t2), this;
    };
    var Ee = y2.__private__.getStyle = y2.getStyle = function(t2) {
      var e3 = g2;
      switch (t2) {
        case "D":
        case "S":
          e3 = "S";
          break;
        case "F":
          e3 = "f";
          break;
        case "FD":
        case "DF":
          e3 = "B";
          break;
        case "f":
        case "f*":
        case "B":
        case "B*":
          e3 = t2;
      }
      return e3;
    }, Re = y2.close = function() {
      return lt2("h"), this;
    };
    y2.stroke = function() {
      return lt2("S"), this;
    }, y2.fill = function(t2) {
      return De("f", t2), this;
    }, y2.fillEvenOdd = function(t2) {
      return De("f*", t2), this;
    }, y2.fillStroke = function(t2) {
      return De("B", t2), this;
    }, y2.fillStrokeEvenOdd = function(t2) {
      return De("B*", t2), this;
    };
    var De = function(e3, n3) {
      "object" === _typeof$1(n3) ? Ue(n3, e3) : lt2(e3);
    }, Te = function(t2) {
      null === t2 || _2 === S2 && void 0 === t2 || (t2 = Ee(t2), lt2(t2));
    };
    function ze(t2, e3, n3, r3, i2) {
      var a3 = new q(e3 || this.boundingBox, n3 || this.xStep, r3 || this.yStep, this.gState, i2 || this.matrix);
      a3.stream = this.stream;
      var o2 = t2 + "$$" + this.cloneIndex++ + "$$";
      return Yt2(o2, a3), a3;
    }
    var Ue = function(t2, e3) {
      var n3 = Ot2[t2.key], r3 = Ct2[n3];
      if (r3 instanceof M) lt2("q"), lt2(He(e3)), r3.gState && y2.setGState(r3.gState), lt2(t2.matrix.toString() + " cm"), lt2("/" + n3 + " sh"), lt2("Q");
      else if (r3 instanceof q) {
        var i2 = new Wt2(1, 0, 0, -1, 0, _n());
        t2.matrix && (i2 = i2.multiply(t2.matrix || Gt2), n3 = ze.call(r3, t2.key, t2.boundingBox, t2.xStep, t2.yStep, i2).id), lt2("q"), lt2("/Pattern cs"), lt2("/" + n3 + " scn"), r3.gState && y2.setGState(r3.gState), lt2(e3), lt2("Q");
      }
    }, He = function(t2) {
      switch (t2) {
        case "f":
        case "F":
        case "n":
          return "W n";
        case "f*":
          return "W* n";
        case "B":
        case "S":
          return "W S";
        case "B*":
          return "W* S";
      }
    }, We = y2.moveTo = function(t2, e3) {
      return lt2(B3(U2(t2)) + " " + B3(H4(e3)) + " m"), this;
    }, Ve = y2.lineTo = function(t2, e3) {
      return lt2(B3(U2(t2)) + " " + B3(H4(e3)) + " l"), this;
    }, Ge = y2.curveTo = function(t2, e3, n3, r3, i2, a3) {
      return lt2([B3(U2(t2)), B3(H4(e3)), B3(U2(n3)), B3(H4(r3)), B3(U2(i2)), B3(H4(a3)), "c"].join(" ")), this;
    };
    y2.__private__.line = y2.line = function(t2, e3, n3, r3, i2) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.line");
      return _2 === A2 ? this.lines([[n3 - t2, r3 - e3]], t2, e3, [1, 1], i2 || "S") : this.lines([[n3 - t2, r3 - e3]], t2, e3, [1, 1]).stroke();
    }, y2.__private__.lines = y2.lines = function(t2, e3, n3, r3, i2, a3) {
      var o2, s3, u3, c3, l2, h2, f3, d2, p3, g3, m3, v3;
      if ("number" == typeof t2 && (v3 = n3, n3 = e3, e3 = t2, t2 = v3), r3 = r3 || [1, 1], a3 = a3 || false, isNaN(e3) || isNaN(n3) || !Array.isArray(t2) || !Array.isArray(r3) || !qe(i2) || "boolean" != typeof a3) throw new Error("Invalid arguments passed to jsPDF.lines");
      for (We(e3, n3), o2 = r3[0], s3 = r3[1], c3 = t2.length, g3 = e3, m3 = n3, u3 = 0; u3 < c3; u3++) 2 === (l2 = t2[u3]).length ? (g3 = l2[0] * o2 + g3, m3 = l2[1] * s3 + m3, Ve(g3, m3)) : (h2 = l2[0] * o2 + g3, f3 = l2[1] * s3 + m3, d2 = l2[2] * o2 + g3, p3 = l2[3] * s3 + m3, g3 = l2[4] * o2 + g3, m3 = l2[5] * s3 + m3, Ge(h2, f3, d2, p3, g3, m3));
      return a3 && Re(), Te(i2), this;
    }, y2.path = function(t2) {
      for (var e3 = 0; e3 < t2.length; e3++) {
        var n3 = t2[e3], r3 = n3.c;
        switch (n3.op) {
          case "m":
            We(r3[0], r3[1]);
            break;
          case "l":
            Ve(r3[0], r3[1]);
            break;
          case "c":
            Ge.apply(this, r3);
            break;
          case "h":
            Re();
        }
      }
      return this;
    }, y2.__private__.rect = y2.rect = function(t2, e3, n3, r3, i2) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.rect");
      return _2 === A2 && (r3 = -r3), lt2([B3(U2(t2)), B3(H4(e3)), B3(U2(n3)), B3(U2(r3)), "re"].join(" ")), Te(i2), this;
    }, y2.__private__.triangle = y2.triangle = function(t2, e3, n3, r3, i2, a3, o2) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i2) || isNaN(a3) || !qe(o2)) throw new Error("Invalid arguments passed to jsPDF.triangle");
      return this.lines([[n3 - t2, r3 - e3], [i2 - n3, a3 - r3], [t2 - i2, e3 - a3]], t2, e3, [1, 1], o2, true), this;
    }, y2.__private__.roundedRect = y2.roundedRect = function(t2, e3, n3, r3, i2, a3, o2) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i2) || isNaN(a3) || !qe(o2)) throw new Error("Invalid arguments passed to jsPDF.roundedRect");
      var s3 = 4 / 3 * (Math.SQRT2 - 1);
      return i2 = Math.min(i2, 0.5 * n3), a3 = Math.min(a3, 0.5 * r3), this.lines([[n3 - 2 * i2, 0], [i2 * s3, 0, i2, a3 - a3 * s3, i2, a3], [0, r3 - 2 * a3], [0, a3 * s3, -i2 * s3, a3, -i2, a3], [2 * i2 - n3, 0], [-i2 * s3, 0, -i2, -a3 * s3, -i2, -a3], [0, 2 * a3 - r3], [0, -a3 * s3, i2 * s3, -a3, i2, -a3]], t2 + i2, e3, [1, 1], o2, true), this;
    }, y2.__private__.ellipse = y2.ellipse = function(t2, e3, n3, r3, i2) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || !qe(i2)) throw new Error("Invalid arguments passed to jsPDF.ellipse");
      var a3 = 4 / 3 * (Math.SQRT2 - 1) * n3, o2 = 4 / 3 * (Math.SQRT2 - 1) * r3;
      return We(t2 + n3, e3), Ge(t2 + n3, e3 - o2, t2 + a3, e3 - r3, t2, e3 - r3), Ge(t2 - a3, e3 - r3, t2 - n3, e3 - o2, t2 - n3, e3), Ge(t2 - n3, e3 + o2, t2 - a3, e3 + r3, t2, e3 + r3), Ge(t2 + a3, e3 + r3, t2 + n3, e3 + o2, t2 + n3, e3), Te(i2), this;
    }, y2.__private__.circle = y2.circle = function(t2, e3, n3, r3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || !qe(r3)) throw new Error("Invalid arguments passed to jsPDF.circle");
      return this.ellipse(t2, e3, n3, n3, r3);
    }, y2.setFont = function(t2, e3, n3) {
      return n3 && (e3 = F2(e3, n3)), At2 = Ne2(t2, e3, { disableWarning: false }), this;
    };
    var Ye = y2.__private__.getFont = y2.getFont = function() {
      return Ft2[Ne2.apply(y2, arguments)];
    };
    y2.__private__.getFontList = y2.getFontList = function() {
      var t2, e3, n3 = {};
      for (t2 in It2) if (It2.hasOwnProperty(t2)) for (e3 in n3[t2] = [], It2[t2]) It2[t2].hasOwnProperty(e3) && n3[t2].push(e3);
      return n3;
    }, y2.addFont = function(t2, e3, n3, r3, i2) {
      var a3 = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"];
      return arguments[3] && -1 !== a3.indexOf(arguments[3]) ? i2 = arguments[3] : arguments[3] && -1 == a3.indexOf(arguments[3]) && (n3 = F2(n3, r3)), pe2.call(this, t2, e3, n3, i2 = i2 || "Identity-H");
    };
    var Je, Xe = e2.lineWidth || 0.200025, Ke = y2.__private__.getLineWidth = y2.getLineWidth = function() {
      return Xe;
    }, Ze = y2.__private__.setLineWidth = y2.setLineWidth = function(t2) {
      return Xe = t2, lt2(B3(U2(t2)) + " w"), this;
    };
    y2.__private__.setLineDash = E$1.API.setLineDash = E$1.API.setLineDashPattern = function(t2, e3) {
      if (t2 = t2 || [], e3 = e3 || 0, isNaN(e3) || !Array.isArray(t2)) throw new Error("Invalid arguments passed to jsPDF.setLineDash");
      return t2 = t2.map(function(t3) {
        return B3(U2(t3));
      }).join(" "), e3 = B3(U2(e3)), lt2("[" + t2 + "] " + e3 + " d"), this;
    };
    var $e = y2.__private__.getLineHeight = y2.getLineHeight = function() {
      return pt2 * Je;
    };
    y2.__private__.getLineHeight = y2.getLineHeight = function() {
      return pt2 * Je;
    };
    var Qe = y2.__private__.setLineHeightFactor = y2.setLineHeightFactor = function(t2) {
      return "number" == typeof (t2 = t2 || 1.15) && (Je = t2), this;
    }, tn = y2.__private__.getLineHeightFactor = y2.getLineHeightFactor = function() {
      return Je;
    };
    Qe(e2.lineHeight);
    var en = y2.__private__.getHorizontalCoordinate = function(t2) {
      return U2(t2);
    }, nn = y2.__private__.getVerticalCoordinate = function(t2) {
      return _2 === S2 ? t2 : Rt2[$2].mediaBox.topRightY - Rt2[$2].mediaBox.bottomLeftY - U2(t2);
    }, rn = y2.__private__.getHorizontalCoordinateString = y2.getHorizontalCoordinateString = function(t2) {
      return B3(en(t2));
    }, an = y2.__private__.getVerticalCoordinateString = y2.getVerticalCoordinateString = function(t2) {
      return B3(nn(t2));
    }, on = e2.strokeColor || "0 G";
    y2.__private__.getStrokeColor = y2.getDrawColor = function() {
      return ee2(on);
    }, y2.__private__.setStrokeColor = y2.setDrawColor = function(t2, e3, n3, r3) {
      return on = ne2({ ch1: t2, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "draw", precision: 2 }), lt2(on), this;
    };
    var sn = e2.fillColor || "0 g";
    y2.__private__.getFillColor = y2.getFillColor = function() {
      return ee2(sn);
    }, y2.__private__.setFillColor = y2.setFillColor = function(t2, e3, n3, r3) {
      return sn = ne2({ ch1: t2, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "fill", precision: 2 }), lt2(sn), this;
    };
    var un = e2.textColor || "0 g", cn = y2.__private__.getTextColor = y2.getTextColor = function() {
      return ee2(un);
    };
    y2.__private__.setTextColor = y2.setTextColor = function(t2, e3, n3, r3) {
      return un = ne2({ ch1: t2, ch2: e3, ch3: n3, ch4: r3, pdfColorType: "text", precision: 3 }), this;
    };
    var ln2 = e2.charSpace, hn = y2.__private__.getCharSpace = y2.getCharSpace = function() {
      return parseFloat(ln2 || 0);
    };
    y2.__private__.setCharSpace = y2.setCharSpace = function(t2) {
      if (isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setCharSpace");
      return ln2 = t2, this;
    };
    var fn = 0;
    y2.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, y2.__private__.setLineCap = y2.setLineCap = function(t2) {
      var e3 = y2.CapJoinStyles[t2];
      if (void 0 === e3) throw new Error("Line cap style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
      return fn = e3, lt2(e3 + " J"), this;
    };
    var dn = 0;
    y2.__private__.setLineJoin = y2.setLineJoin = function(t2) {
      var e3 = y2.CapJoinStyles[t2];
      if (void 0 === e3) throw new Error("Line join style of '" + t2 + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
      return dn = e3, lt2(e3 + " j"), this;
    }, y2.__private__.setLineMiterLimit = y2.__private__.setMiterLimit = y2.setLineMiterLimit = y2.setMiterLimit = function(t2) {
      if (t2 = t2 || 0, isNaN(t2)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit");
      return lt2(B3(U2(t2)) + " M"), this;
    }, y2.GState = O$1, y2.setGState = function(t2) {
      (t2 = "string" == typeof t2 ? Bt2[Mt2[t2]] : pn(null, t2)).equals(qt2) || (lt2("/" + t2.id + " gs"), qt2 = t2);
    };
    var pn = function(t2, e3) {
      if (!t2 || !Mt2[t2]) {
        var n3 = false;
        for (var r3 in Bt2) if (Bt2.hasOwnProperty(r3) && Bt2[r3].equals(e3)) {
          n3 = true;
          break;
        }
        if (n3) e3 = Bt2[r3];
        else {
          var i2 = "GS" + (Object.keys(Bt2).length + 1).toString(10);
          Bt2[i2] = e3, e3.id = i2;
        }
        return t2 && (Mt2[t2] = e3.id), Dt2.publish("addGState", e3), e3;
      }
    };
    y2.addGState = function(t2, e3) {
      return pn(t2, e3), this;
    }, y2.saveGraphicsState = function() {
      return lt2("q"), jt2.push({ key: At2, size: pt2, color: un }), this;
    }, y2.restoreGraphicsState = function() {
      lt2("Q");
      var t2 = jt2.pop();
      return At2 = t2.key, pt2 = t2.size, un = t2.color, qt2 = null, this;
    }, y2.setCurrentTransformationMatrix = function(t2) {
      return lt2(t2.toString() + " cm"), this;
    }, y2.comment = function(t2) {
      return lt2("#" + t2), this;
    };
    var gn = function(t2, e3) {
      var n3 = t2 || 0;
      Object.defineProperty(this, "x", { enumerable: true, get: function() {
        return n3;
      }, set: function(t3) {
        isNaN(t3) || (n3 = parseFloat(t3));
      } });
      var r3 = e3 || 0;
      Object.defineProperty(this, "y", { enumerable: true, get: function() {
        return r3;
      }, set: function(t3) {
        isNaN(t3) || (r3 = parseFloat(t3));
      } });
      var i2 = "pt";
      return Object.defineProperty(this, "type", { enumerable: true, get: function() {
        return i2;
      }, set: function(t3) {
        i2 = t3.toString();
      } }), this;
    }, mn = function(t2, e3, n3, r3) {
      gn.call(this, t2, e3), this.type = "rect";
      var i2 = n3 || 0;
      Object.defineProperty(this, "w", { enumerable: true, get: function() {
        return i2;
      }, set: function(t3) {
        isNaN(t3) || (i2 = parseFloat(t3));
      } });
      var a3 = r3 || 0;
      return Object.defineProperty(this, "h", { enumerable: true, get: function() {
        return a3;
      }, set: function(t3) {
        isNaN(t3) || (a3 = parseFloat(t3));
      } }), this;
    }, vn = function() {
      this.page = Et2, this.currentPage = $2, this.pages = ot2.slice(0), this.pagesContext = Rt2.slice(0), this.x = _t2, this.y = Pt2, this.matrix = kt2, this.width = wn($2), this.height = Ln($2), this.outputDestination = ut2, this.id = "", this.objectNumber = -1;
    };
    vn.prototype.restore = function() {
      Et2 = this.page, $2 = this.currentPage, Rt2 = this.pagesContext, ot2 = this.pages, _t2 = this.x, Pt2 = this.y, kt2 = this.matrix, Nn($2, this.width), xn($2, this.height), ut2 = this.outputDestination;
    };
    var bn = function(t2, e3, n3, r3, i2) {
      Ht2.push(new vn()), Et2 = $2 = 0, ot2 = [], _t2 = t2, Pt2 = e3, kt2 = i2, me2([n3, r3]);
    };
    for (var yn in y2.beginFormObject = function(t2, e3, n3, r3, i2) {
      return bn(t2, e3, n3, r3, i2), this;
    }, y2.endFormObject = function(t2) {
      return (function(t3) {
        if (Ut2[t3]) Ht2.pop().restore();
        else {
          var e3 = new vn(), n3 = "Xo" + (Object.keys(zt2).length + 1).toString(10);
          e3.id = n3, Ut2[t3] = n3, zt2[n3] = e3, Dt2.publish("addFormObject", e3), Ht2.pop().restore();
        }
      })(t2), this;
    }, y2.doFormObject = function(t2, e3) {
      var n3 = zt2[Ut2[t2]];
      return lt2("q"), lt2(e3.toString() + " cm"), lt2("/" + n3.id + " Do"), lt2("Q"), this;
    }, y2.getFormObject = function(t2) {
      var e3 = zt2[Ut2[t2]];
      return { x: e3.x, y: e3.y, width: e3.width, height: e3.height, matrix: e3.matrix };
    }, y2.save = function(t2, e3) {
      return t2 = t2 || "generated.pdf", (e3 = e3 || {}).returnPromise = e3.returnPromise || false, false === e3.returnPromise ? (l$1(ke2(Pe2()), t2), "function" == typeof l$1.unload && i$5.setTimeout && setTimeout(l$1.unload, 911), this) : new Promise(function(e4, n3) {
        try {
          var r3 = l$1(ke2(Pe2()), t2);
          "function" == typeof l$1.unload && i$5.setTimeout && setTimeout(l$1.unload, 911), e4(r3);
        } catch (a3) {
          n3(a3.message);
        }
      });
    }, E$1.API) E$1.API.hasOwnProperty(yn) && ("events" === yn && E$1.API.events.length ? (function(t2, e3) {
      var n3, r3, i2;
      for (i2 = e3.length - 1; -1 !== i2; i2--) n3 = e3[i2][0], r3 = e3[i2][1], t2.subscribe.apply(t2, [n3].concat("function" == typeof r3 ? [r3] : r3));
    })(Dt2, E$1.API.events) : y2[yn] = E$1.API[yn]);
    function wn(t2) {
      return Rt2[t2].mediaBox.topRightX - Rt2[t2].mediaBox.bottomLeftX;
    }
    function Nn(t2, e3) {
      Rt2[t2].mediaBox.topRightX = e3 + Rt2[t2].mediaBox.bottomLeftX;
    }
    function Ln(t2) {
      return Rt2[t2].mediaBox.topRightY - Rt2[t2].mediaBox.bottomLeftY;
    }
    function xn(t2, e3) {
      Rt2[t2].mediaBox.topRightY = e3 + Rt2[t2].mediaBox.bottomLeftY;
    }
    var An = y2.getPageWidth = function(t2) {
      return wn(t2 = t2 || $2) / St;
    }, Sn = y2.setPageWidth = function(t2, e3) {
      Nn(t2, e3 * St);
    }, _n = y2.getPageHeight = function(t2) {
      return Ln(t2 = t2 || $2) / St;
    }, Pn = y2.setPageHeight = function(t2, e3) {
      xn(t2, e3 * St);
    };
    return y2.internal = { pdfEscape: ge2, getStyle: Ee, getFont: Ye, getFontSize: mt2, getCharSpace: hn, getTextColor: cn, getLineHeight: $e, getLineHeightFactor: tn, getLineWidth: Ke, write: ht2, getHorizontalCoordinate: en, getVerticalCoordinate: nn, getCoordinateString: rn, getVerticalCoordinateString: an, collections: {}, newObject: Xt2, newAdditionalObject: $t2, newObjectDeferred: Kt2, newObjectDeferredBegin: Zt2, getFilters: re2, putStream: ie2, events: Dt2, scaleFactor: St, pageSize: { getWidth: function() {
      return An($2);
    }, setWidth: function(t2) {
      Sn($2, t2);
    }, getHeight: function() {
      return _n($2);
    }, setHeight: function(t2) {
      Pn($2, t2);
    } }, encryptionOptions: m2, encryption: je2, getEncryptor: function(t2) {
      return null !== m2 ? je2.encryptor(t2, 0) : function(t3) {
        return t3;
      };
    }, output: Fe2, getNumberOfPages: we2, get pages() {
      return ot2;
    }, out: lt2, f2: T2, f3: z2, getPageInfo: Ce, getPageInfoByObjId: Oe, getCurrentPageInfo: Be, getPDFVersion: N2, Point: gn, Rectangle: mn, Matrix: Wt2, hasHotfix: Ie2 }, Object.defineProperty(y2.internal.pageSize, "width", { get: function() {
      return An($2);
    }, set: function(t2) {
      Sn($2, t2);
    }, enumerable: true, configurable: true }), Object.defineProperty(y2.internal.pageSize, "height", { get: function() {
      return _n($2);
    }, set: function(t2) {
      Pn($2, t2);
    }, enumerable: true, configurable: true }), (function(t2) {
      for (var e3 = 0, n3 = dt2.length; e3 < n3; e3++) {
        var r3 = pe2.call(this, t2[e3][0], t2[e3][1], t2[e3][2], dt2[e3][3], true);
        false === v2 && (b2[r3] = true);
        var i2 = t2[e3][0].split("-");
        de2({ id: r3, fontName: i2[0], fontStyle: i2[1] || "" });
      }
      Dt2.publish("addFonts", { fonts: Ft2, dictionary: It2 });
    }).call(y2, dt2), At2 = "F1", ve2(s2, r2), Dt2.publish("initialized"), y2;
  }
  I.prototype.lsbFirstWord = function(t2) {
    return String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, t2 >> 24 & 255);
  }, I.prototype.toHexString = function(t2) {
    return t2.split("").map(function(t3) {
      return ("0" + (255 & t3.charCodeAt(0)).toString(16)).slice(-2);
    }).join("");
  }, I.prototype.hexToBytes = function(t2) {
    for (var e2 = [], n2 = 0; n2 < t2.length; n2 += 2) e2.push(String.fromCharCode(parseInt(t2.substr(n2, 2), 16)));
    return e2.join("");
  }, I.prototype.processOwnerPassword = function(t2, e2) {
    return k(S(e2).substr(0, 5), t2);
  }, I.prototype.encryptor = function(t2, e2) {
    var n2 = S(this.encryptionKey + String.fromCharCode(255 & t2, t2 >> 8 & 255, t2 >> 16 & 255, 255 & e2, e2 >> 8 & 255)).substr(0, 10);
    return function(t3) {
      return k(n2, t3);
    };
  }, O$1.prototype.equals = function(e2) {
    var n2, r2 = "id,objectNumber,equals";
    if (!e2 || _typeof$1(e2) !== _typeof$1(this)) return false;
    var i2 = 0;
    for (n2 in this) if (!(r2.indexOf(n2) >= 0)) {
      if (this.hasOwnProperty(n2) && !e2.hasOwnProperty(n2)) return false;
      if (this[n2] !== e2[n2]) return false;
      i2++;
    }
    for (n2 in e2) e2.hasOwnProperty(n2) && r2.indexOf(n2) < 0 && i2--;
    return 0 === i2;
  }, E$1.API = { events: [] }, E$1.version = "4.0.0";
  var R = E$1.API, D = 1, T$2 = function(t2) {
    return t2.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)");
  }, z$1 = function(t2) {
    return t2.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
  }, U$1 = function(t2) {
    return t2.toFixed(2);
  }, H = function(t2) {
    return t2.toFixed(5);
  };
  R.__acroform__ = {};
  var W = function(t2, e2) {
    t2.prototype = Object.create(e2.prototype), t2.prototype.constructor = t2;
  }, V$1 = function(t2) {
    return t2 * D;
  }, G = function(t2) {
    var e2 = new ct(), n2 = xt.internal.getHeight(t2) || 0, r2 = xt.internal.getWidth(t2) || 0;
    return e2.BBox = [0, 0, Number(U$1(r2)), Number(U$1(n2))], e2;
  }, Y = R.__acroform__.setBit = function(t2, e2) {
    if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit");
    return t2 | 1 << e2;
  }, J = R.__acroform__.clearBit = function(t2, e2) {
    if (t2 = t2 || 0, e2 = e2 || 0, isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit");
    return t2 & ~(1 << e2);
  }, X = R.__acroform__.getBit = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit");
    return t2 & 1 << e2 ? 1 : 0;
  }, K = R.__acroform__.getBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf");
    return X(t2, e2 - 1);
  }, Z$1 = R.__acroform__.setBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf");
    return Y(t2, e2 - 1);
  }, $ = R.__acroform__.clearBitForPdf = function(t2, e2) {
    if (isNaN(t2) || isNaN(e2)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf");
    return J(t2, e2 - 1);
  }, Q = R.__acroform__.calculateCoordinates = function(t2, e2) {
    var n2 = e2.internal.getHorizontalCoordinate, r2 = e2.internal.getVerticalCoordinate, i2 = t2[0], a2 = t2[1], o2 = t2[2], s2 = t2[3], u2 = {};
    return u2.lowerLeft_X = n2(i2) || 0, u2.lowerLeft_Y = r2(a2 + s2) || 0, u2.upperRight_X = n2(i2 + o2) || 0, u2.upperRight_Y = r2(a2) || 0, [Number(U$1(u2.lowerLeft_X)), Number(U$1(u2.lowerLeft_Y)), Number(U$1(u2.upperRight_X)), Number(U$1(u2.upperRight_Y))];
  }, tt = function(t2) {
    if (t2.appearanceStreamContent) return t2.appearanceStreamContent;
    if (t2.V || t2.DV) {
      var e2 = [], n2 = t2._V || t2.DV, r2 = et(t2, n2), i2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id;
      e2.push("/Tx BMC"), e2.push("q"), e2.push("BT"), e2.push(t2.scope.__private__.encodeColorString(t2.color)), e2.push("/" + i2 + " " + U$1(r2.fontSize) + " Tf"), e2.push("1 0 0 1 0 0 Tm"), e2.push(r2.text), e2.push("ET"), e2.push("Q"), e2.push("EMC");
      var a2 = G(t2);
      return a2.scope = t2.scope, a2.stream = e2.join("\n"), a2;
    }
  }, et = function(t2, e2) {
    var n2 = 0 === t2.fontSize ? t2.maxFontSize : t2.fontSize, r2 = { text: "", fontSize: "" }, i2 = (e2 = ")" == (e2 = "(" == e2.substr(0, 1) ? e2.substr(1) : e2).substr(e2.length - 1) ? e2.substr(0, e2.length - 1) : e2).split(" ");
    i2 = t2.multiline ? i2.map(function(t3) {
      return t3.split("\n");
    }) : i2.map(function(t3) {
      return [t3];
    });
    var a2 = n2, o2 = xt.internal.getHeight(t2) || 0;
    o2 = o2 < 0 ? -o2 : o2;
    var s2 = xt.internal.getWidth(t2) || 0;
    s2 = s2 < 0 ? -s2 : s2;
    var u2 = function(e3, n3, r3) {
      if (e3 + 1 < i2.length) {
        var a3 = n3 + " " + i2[e3 + 1][0];
        return nt(a3, t2, r3).width <= s2 - 4;
      }
      return false;
    };
    a2++;
    t: for (; a2 > 0; ) {
      e2 = "", a2--;
      var c2, l2, h2 = nt("3", t2, a2).height, f2 = t2.multiline ? o2 - a2 : (o2 - h2) / 2, d2 = f2 += 2, p2 = 0, g2 = 0, m2 = 0;
      if (a2 <= 0) {
        e2 = "(...) Tj\n", e2 += "% Width of Text: " + nt(e2, t2, a2 = 12).width + ", FieldWidth:" + s2 + "\n";
        break;
      }
      for (var v2 = "", b2 = 0, y2 = 0; y2 < i2.length; y2++) if (i2.hasOwnProperty(y2)) {
        var w2 = false;
        if (1 !== i2[y2].length && m2 !== i2[y2].length - 1) {
          if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
          v2 += i2[y2][m2], w2 = true, g2 = y2, y2--;
        } else {
          v2 = " " == (v2 += i2[y2][m2] + " ").substr(v2.length - 1) ? v2.substr(0, v2.length - 1) : v2;
          var N2 = parseInt(y2), L2 = u2(N2, v2, a2), x2 = y2 >= i2.length - 1;
          if (L2 && !x2) {
            v2 += " ", m2 = 0;
            continue;
          }
          if (L2 || x2) {
            if (x2) g2 = N2;
            else if (t2.multiline && (h2 + 2) * (b2 + 2) + 2 > o2) continue t;
          } else {
            if (!t2.multiline) continue t;
            if ((h2 + 2) * (b2 + 2) + 2 > o2) continue t;
            g2 = N2;
          }
        }
        for (var A2 = "", S2 = p2; S2 <= g2; S2++) {
          var _2 = i2[S2];
          if (t2.multiline) {
            if (S2 === g2) {
              A2 += _2[m2] + " ", m2 = (m2 + 1) % _2.length;
              continue;
            }
            if (S2 === p2) {
              A2 += _2[_2.length - 1] + " ";
              continue;
            }
          }
          A2 += _2[0] + " ";
        }
        switch (A2 = " " == A2.substr(A2.length - 1) ? A2.substr(0, A2.length - 1) : A2, l2 = nt(A2, t2, a2).width, t2.textAlign) {
          case "right":
            c2 = s2 - l2 - 2;
            break;
          case "center":
            c2 = (s2 - l2) / 2;
            break;
          default:
            c2 = 2;
        }
        e2 += U$1(c2) + " " + U$1(d2) + " Td\n", e2 += "(" + T$2(A2) + ") Tj\n", e2 += -U$1(c2) + " 0 Td\n", d2 = -(a2 + 2), l2 = 0, p2 = w2 ? g2 : g2 + 1, b2++, v2 = "";
      }
      break;
    }
    return r2.text = e2, r2.fontSize = a2, r2;
  }, nt = function(t2, e2, n2) {
    var r2 = e2.scope.internal.getFont(e2.fontName, e2.fontStyle), i2 = e2.scope.getStringUnitWidth(t2, { font: r2, fontSize: parseFloat(n2), charSpace: 0 }) * parseFloat(n2);
    return { height: e2.scope.getStringUnitWidth("3", { font: r2, fontSize: parseFloat(n2), charSpace: 0 }) * parseFloat(n2) * 1.5, width: i2 };
  }, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: false, internal: null, isInitialized: false }, it = function(t2, e2) {
    var n2 = { type: "reference", object: t2 };
    void 0 === e2.internal.getPageInfo(t2.page).pageContext.annotations.find(function(t3) {
      return t3.type === n2.type && t3.object === n2.object;
    }) && e2.internal.getPageInfo(t2.page).pageContext.annotations.push(n2);
  }, at = function(e2, n2) {
    if (n2.scope = e2, void 0 !== e2.internal && (void 0 === e2.internal.acroformPlugin || false === e2.internal.acroformPlugin.isInitialized)) {
      if (ht.FieldNum = 0, e2.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary");
      D = e2.internal.scaleFactor, e2.internal.acroformPlugin.acroFormDictionaryRoot = new lt(), e2.internal.acroformPlugin.acroFormDictionaryRoot.scope = e2, e2.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e2.internal.events.subscribe("postPutResources", function() {
        !(function(t2) {
          t2.internal.events.unsubscribe(t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete t2.internal.acroformPlugin.acroFormDictionaryRoot._eventID, t2.internal.acroformPlugin.printedOut = true;
        })(e2);
      }), e2.internal.events.subscribe("buildDocument", function() {
        !(function(t2) {
          t2.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0;
          var e3 = t2.internal.acroformPlugin.acroFormDictionaryRoot.Fields;
          for (var n3 in e3) if (e3.hasOwnProperty(n3)) {
            var r2 = e3[n3];
            r2.objId = void 0, r2.hasAnnotation && it(r2, t2);
          }
        })(e2);
      }), e2.internal.events.subscribe("putCatalog", function() {
        !(function(t2) {
          if (void 0 === t2.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("putCatalogCallback: Root missing.");
          t2.internal.write("/AcroForm " + t2.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R");
        })(e2);
      }), e2.internal.events.subscribe("postPutPages", function(n3) {
        !(function(e3, n4) {
          var r2 = !e3;
          for (var i2 in e3 || (n4.internal.newObjectDeferredBegin(n4.internal.acroformPlugin.acroFormDictionaryRoot.objId, true), n4.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), e3 = e3 || n4.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (e3.hasOwnProperty(i2)) {
            var a2 = e3[i2], o2 = [], s2 = a2.Rect;
            if (a2.Rect && (a2.Rect = Q(a2.Rect, n4)), n4.internal.newObjectDeferredBegin(a2.objId, true), a2.DA = xt.createDefaultAppearanceStream(a2), "object" === _typeof$1(a2) && "function" == typeof a2.getKeyValueListForStream && (o2 = a2.getKeyValueListForStream()), a2.Rect = s2, a2.hasAppearanceStream && !a2.appearanceStreamContent) {
              var u2 = tt(a2);
              o2.push({ key: "AP", value: "<</N " + u2 + ">>" }), n4.internal.acroformPlugin.xForms.push(u2);
            }
            if (a2.appearanceStreamContent) {
              var c2 = "";
              for (var l2 in a2.appearanceStreamContent) if (a2.appearanceStreamContent.hasOwnProperty(l2)) {
                var h2 = a2.appearanceStreamContent[l2];
                if (c2 += "/" + l2 + " ", c2 += "<<", Object.keys(h2).length >= 1 || Array.isArray(h2)) {
                  for (var i2 in h2) if (h2.hasOwnProperty(i2)) {
                    var f2 = h2[i2];
                    "function" == typeof f2 && (f2 = f2.call(n4, a2)), c2 += "/" + i2 + " " + f2 + " ", n4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n4.internal.acroformPlugin.xForms.push(f2);
                  }
                } else "function" == typeof (f2 = h2) && (f2 = f2.call(n4, a2)), c2 += "/" + i2 + " " + f2, n4.internal.acroformPlugin.xForms.indexOf(f2) >= 0 || n4.internal.acroformPlugin.xForms.push(f2);
                c2 += ">>";
              }
              o2.push({ key: "AP", value: "<<\n" + c2 + ">>" });
            }
            n4.internal.putStream({ additionalKeyValues: o2, objectId: a2.objId }), n4.internal.out("endobj");
          }
          r2 && (function(e4, n5) {
            for (var r3 in e4) if (e4.hasOwnProperty(r3)) {
              var i3 = r3, a3 = e4[r3];
              n5.internal.newObjectDeferredBegin(a3.objId, true), "object" === _typeof$1(a3) && "function" == typeof a3.putStream && a3.putStream(), delete e4[i3];
            }
          })(n4.internal.acroformPlugin.xForms, n4);
        })(n3, e2);
      }), e2.internal.acroformPlugin.isInitialized = true;
    }
  }, ot = R.__acroform__.arrayToPdfArray = function(e2, n2, r2) {
    var i2 = function(t2) {
      return t2;
    };
    if (Array.isArray(e2)) {
      for (var a2 = "[", o2 = 0; o2 < e2.length; o2++) switch (0 !== o2 && (a2 += " "), _typeof$1(e2[o2])) {
        case "boolean":
        case "number":
        case "object":
          a2 += e2[o2].toString();
          break;
        case "string":
          "/" !== e2[o2].substr(0, 1) ? (void 0 !== n2 && r2 && (i2 = r2.internal.getEncryptor(n2)), a2 += "(" + T$2(i2(e2[o2].toString())) + ")") : a2 += e2[o2].toString();
      }
      return a2 + "]";
    }
    throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray");
  }, st = function(t2, e2, n2) {
    var r2 = function(t3) {
      return t3;
    };
    return void 0 !== e2 && n2 && (r2 = n2.internal.getEncryptor(e2)), (t2 = t2 || "").toString(), "(" + T$2(r2(t2)) + ")";
  }, ut = function() {
    this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function() {
      if (void 0 === this._objId) {
        if (void 0 === this.scope) return;
        this._objId = this.scope.internal.newObjectDeferred();
      }
      return this._objId;
    }, set: function(t2) {
      this._objId = t2;
    } }), Object.defineProperty(this, "scope", { value: this._scope, writable: true });
  };
  ut.prototype.toString = function() {
    return this.objId + " 0 R";
  }, ut.prototype.putStream = function() {
    var t2 = this.getKeyValueListForStream();
    this.scope.internal.putStream({ data: this.stream, additionalKeyValues: t2, objectId: this.objId }), this.scope.internal.out("endobj");
  }, ut.prototype.getKeyValueListForStream = function() {
    var t2 = [], e2 = Object.getOwnPropertyNames(this).filter(function(t3) {
      return "content" != t3 && "appearanceStreamContent" != t3 && "scope" != t3 && "objId" != t3 && "_" != t3.substring(0, 1);
    });
    for (var n2 in e2) if (false === Object.getOwnPropertyDescriptor(this, e2[n2]).configurable) {
      var r2 = e2[n2], i2 = this[r2];
      i2 && (Array.isArray(i2) ? t2.push({ key: r2, value: ot(i2, this.objId, this.scope) }) : i2 instanceof ut ? (i2.scope = this.scope, t2.push({ key: r2, value: i2.objId + " 0 R" })) : "function" != typeof i2 && t2.push({ key: r2, value: i2 }));
    }
    return t2;
  };
  var ct = function() {
    ut.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: false, writable: true }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: false, writable: true }), Object.defineProperty(this, "FormType", { value: 1, configurable: false, writable: true });
    var t2, e2 = [];
    Object.defineProperty(this, "BBox", { configurable: false, get: function() {
      return e2;
    }, set: function(t3) {
      e2 = t3;
    } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: false, writable: true }), Object.defineProperty(this, "stream", { enumerable: false, configurable: true, set: function(e3) {
      t2 = e3.trim();
    }, get: function() {
      return t2 || null;
    } });
  };
  W(ct, ut);
  var lt = function() {
    ut.call(this);
    var t2, e2 = [];
    Object.defineProperty(this, "Kids", { enumerable: false, configurable: true, get: function() {
      return e2.length > 0 ? e2 : void 0;
    } }), Object.defineProperty(this, "Fields", { enumerable: false, configurable: false, get: function() {
      return e2;
    } }), Object.defineProperty(this, "DA", { enumerable: false, configurable: false, get: function() {
      if (t2) {
        var e3 = function(t3) {
          return t3;
        };
        return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + T$2(e3(t2)) + ")";
      }
    }, set: function(e3) {
      t2 = e3;
    } });
  };
  W(lt, ut);
  var ht = function t2() {
    ut.call(this);
    var e2 = 4;
    Object.defineProperty(this, "F", { enumerable: false, configurable: false, get: function() {
      return e2;
    }, set: function(t3) {
      if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute F supplied.');
      e2 = t3;
    } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(e2, 3));
    }, set: function(t3) {
      true === Boolean(t3) ? this.F = Z$1(e2, 3) : this.F = $(e2, 3);
    } });
    var n2 = 0;
    Object.defineProperty(this, "Ff", { enumerable: false, configurable: false, get: function() {
      return n2;
    }, set: function(t3) {
      if (isNaN(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Ff supplied.');
      n2 = t3;
    } });
    var r2 = [];
    Object.defineProperty(this, "Rect", { enumerable: false, configurable: false, get: function() {
      if (0 !== r2.length) return r2;
    }, set: function(t3) {
      r2 = void 0 !== t3 ? t3 : [];
    } }), Object.defineProperty(this, "x", { enumerable: true, configurable: true, get: function() {
      return !r2 || isNaN(r2[0]) ? 0 : r2[0];
    }, set: function(t3) {
      r2[0] = t3;
    } }), Object.defineProperty(this, "y", { enumerable: true, configurable: true, get: function() {
      return !r2 || isNaN(r2[1]) ? 0 : r2[1];
    }, set: function(t3) {
      r2[1] = t3;
    } }), Object.defineProperty(this, "width", { enumerable: true, configurable: true, get: function() {
      return !r2 || isNaN(r2[2]) ? 0 : r2[2];
    }, set: function(t3) {
      r2[2] = t3;
    } }), Object.defineProperty(this, "height", { enumerable: true, configurable: true, get: function() {
      return !r2 || isNaN(r2[3]) ? 0 : r2[3];
    }, set: function(t3) {
      r2[3] = t3;
    } });
    var i2 = "";
    Object.defineProperty(this, "FT", { enumerable: true, configurable: false, get: function() {
      return i2;
    }, set: function(t3) {
      switch (t3) {
        case "/Btn":
        case "/Tx":
        case "/Ch":
        case "/Sig":
          i2 = t3;
          break;
        default:
          throw new Error('Invalid value "' + t3 + '" for attribute FT supplied.');
      }
    } });
    var a2 = null;
    Object.defineProperty(this, "T", { enumerable: true, configurable: false, get: function() {
      if (!a2 || a2.length < 1) {
        if (this instanceof yt) return;
        a2 = "FieldObject" + t2.FieldNum++;
      }
      var e3 = function(t3) {
        return t3;
      };
      return this.scope && (e3 = this.scope.internal.getEncryptor(this.objId)), "(" + T$2(e3(a2)) + ")";
    }, set: function(t3) {
      a2 = t3.toString();
    } }), Object.defineProperty(this, "fieldName", { configurable: true, enumerable: true, get: function() {
      return a2;
    }, set: function(t3) {
      a2 = t3;
    } });
    var o2 = "helvetica";
    Object.defineProperty(this, "fontName", { enumerable: true, configurable: true, get: function() {
      return o2;
    }, set: function(t3) {
      o2 = t3;
    } });
    var s2 = "normal";
    Object.defineProperty(this, "fontStyle", { enumerable: true, configurable: true, get: function() {
      return s2;
    }, set: function(t3) {
      s2 = t3;
    } });
    var u2 = 0;
    Object.defineProperty(this, "fontSize", { enumerable: true, configurable: true, get: function() {
      return u2;
    }, set: function(t3) {
      u2 = t3;
    } });
    var c2 = void 0;
    Object.defineProperty(this, "maxFontSize", { enumerable: true, configurable: true, get: function() {
      return void 0 === c2 ? 50 / D : c2;
    }, set: function(t3) {
      c2 = t3;
    } });
    var l2 = "black";
    Object.defineProperty(this, "color", { enumerable: true, configurable: true, get: function() {
      return l2;
    }, set: function(t3) {
      l2 = t3;
    } });
    var h2 = "/F1 0 Tf 0 g";
    Object.defineProperty(this, "DA", { enumerable: true, configurable: false, get: function() {
      if (!(!h2 || this instanceof yt || this instanceof Nt)) return st(h2, this.objId, this.scope);
    }, set: function(t3) {
      t3 = t3.toString(), h2 = t3;
    } });
    var f2 = null;
    Object.defineProperty(this, "DV", { enumerable: false, configurable: false, get: function() {
      if (f2) return this instanceof mt == 0 ? st(f2, this.objId, this.scope) : f2;
    }, set: function(t3) {
      t3 = t3.toString(), f2 = this instanceof mt == 0 ? "(" === t3.substr(0, 1) ? z$1(t3.substr(1, t3.length - 2)) : z$1(t3) : t3;
    } }), Object.defineProperty(this, "defaultValue", { enumerable: true, configurable: true, get: function() {
      return this instanceof mt == 1 ? z$1(f2.substr(1, f2.length - 1)) : f2;
    }, set: function(t3) {
      t3 = t3.toString(), f2 = this instanceof mt == 1 ? "/" + t3 : t3;
    } });
    var d2 = null;
    Object.defineProperty(this, "_V", { enumerable: false, configurable: false, get: function() {
      if (d2) return d2;
    }, set: function(t3) {
      this.V = t3;
    } }), Object.defineProperty(this, "V", { enumerable: false, configurable: false, get: function() {
      if (d2) return this instanceof mt == 0 ? st(d2, this.objId, this.scope) : d2;
    }, set: function(t3) {
      t3 = t3.toString(), d2 = this instanceof mt == 0 ? "(" === t3.substr(0, 1) ? z$1(t3.substr(1, t3.length - 2)) : z$1(t3) : t3;
    } }), Object.defineProperty(this, "value", { enumerable: true, configurable: true, get: function() {
      return this instanceof mt == 1 ? z$1(d2.substr(1, d2.length - 1)) : d2;
    }, set: function(t3) {
      t3 = t3.toString(), d2 = this instanceof mt == 1 ? "/" + t3 : t3;
    } }), Object.defineProperty(this, "hasAnnotation", { enumerable: true, configurable: true, get: function() {
      return this.Rect;
    } }), Object.defineProperty(this, "Type", { enumerable: true, configurable: false, get: function() {
      return this.hasAnnotation ? "/Annot" : null;
    } }), Object.defineProperty(this, "Subtype", { enumerable: true, configurable: false, get: function() {
      return this.hasAnnotation ? "/Widget" : null;
    } });
    var p2, g2 = false;
    Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
      return g2;
    }, set: function(t3) {
      t3 = Boolean(t3), g2 = t3;
    } }), Object.defineProperty(this, "page", { enumerable: true, configurable: true, get: function() {
      if (p2) return p2;
    }, set: function(t3) {
      p2 = t3;
    } }), Object.defineProperty(this, "readOnly", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 1));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 1) : this.Ff = $(this.Ff, 1);
    } }), Object.defineProperty(this, "required", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 2));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 2) : this.Ff = $(this.Ff, 2);
    } }), Object.defineProperty(this, "noExport", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 3));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 3) : this.Ff = $(this.Ff, 3);
    } });
    var m2 = null;
    Object.defineProperty(this, "Q", { enumerable: true, configurable: false, get: function() {
      if (null !== m2) return m2;
    }, set: function(t3) {
      if (-1 === [0, 1, 2].indexOf(t3)) throw new Error('Invalid value "' + t3 + '" for attribute Q supplied.');
      m2 = t3;
    } }), Object.defineProperty(this, "textAlign", { get: function() {
      var t3;
      switch (m2) {
        case 0:
        default:
          t3 = "left";
          break;
        case 1:
          t3 = "center";
          break;
        case 2:
          t3 = "right";
      }
      return t3;
    }, configurable: true, enumerable: true, set: function(t3) {
      switch (t3) {
        case "right":
        case 2:
          m2 = 2;
          break;
        case "center":
        case 1:
          m2 = 1;
          break;
        default:
          m2 = 0;
      }
    } });
  };
  W(ht, ut);
  var ft = function() {
    ht.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats";
    var t2 = 0;
    Object.defineProperty(this, "TI", { enumerable: true, configurable: false, get: function() {
      return t2;
    }, set: function(e3) {
      t2 = e3;
    } }), Object.defineProperty(this, "topIndex", { enumerable: true, configurable: true, get: function() {
      return t2;
    }, set: function(e3) {
      t2 = e3;
    } });
    var e2 = [];
    Object.defineProperty(this, "Opt", { enumerable: true, configurable: false, get: function() {
      return ot(e2, this.objId, this.scope);
    }, set: function(t3) {
      var n2, r2;
      r2 = [], "string" == typeof (n2 = t3) && (r2 = (function(t4, e3, n3) {
        n3 || (n3 = 1);
        for (var r3, i2 = []; r3 = e3.exec(t4); ) i2.push(r3[n3]);
        return i2;
      })(n2, /\((.*?)\)/g)), e2 = r2;
    } }), this.getOptions = function() {
      return e2;
    }, this.setOptions = function(t3) {
      e2 = t3, this.sort && e2.sort();
    }, this.addOption = function(t3) {
      t3 = (t3 = t3 || "").toString(), e2.push(t3), this.sort && e2.sort();
    }, this.removeOption = function(t3, n2) {
      for (n2 = n2 || false, t3 = (t3 = t3 || "").toString(); -1 !== e2.indexOf(t3) && (e2.splice(e2.indexOf(t3), 1), false !== n2); ) ;
    }, Object.defineProperty(this, "combo", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 18));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 18) : this.Ff = $(this.Ff, 18);
    } }), Object.defineProperty(this, "edit", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 19));
    }, set: function(t3) {
      true === this.combo && (true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 19) : this.Ff = $(this.Ff, 19));
    } }), Object.defineProperty(this, "sort", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 20));
    }, set: function(t3) {
      true === Boolean(t3) ? (this.Ff = Z$1(this.Ff, 20), e2.sort()) : this.Ff = $(this.Ff, 20);
    } }), Object.defineProperty(this, "multiSelect", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 22));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 22) : this.Ff = $(this.Ff, 22);
    } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 23));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 23) : this.Ff = $(this.Ff, 23);
    } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 27));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 27) : this.Ff = $(this.Ff, 27);
    } }), this.hasAppearanceStream = false;
  };
  W(ft, ht);
  var dt = function() {
    ft.call(this), this.fontName = "helvetica", this.combo = false;
  };
  W(dt, ft);
  var pt = function() {
    dt.call(this), this.combo = true;
  };
  W(pt, dt);
  var gt = function() {
    pt.call(this), this.edit = true;
  };
  W(gt, pt);
  var mt = function() {
    ht.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 15));
    }, set: function(t2) {
      true === Boolean(t2) ? this.Ff = Z$1(this.Ff, 15) : this.Ff = $(this.Ff, 15);
    } }), Object.defineProperty(this, "radio", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 16));
    }, set: function(t2) {
      true === Boolean(t2) ? this.Ff = Z$1(this.Ff, 16) : this.Ff = $(this.Ff, 16);
    } }), Object.defineProperty(this, "pushButton", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 17));
    }, set: function(t2) {
      true === Boolean(t2) ? this.Ff = Z$1(this.Ff, 17) : this.Ff = $(this.Ff, 17);
    } }), Object.defineProperty(this, "radioIsUnison", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 26));
    }, set: function(t2) {
      true === Boolean(t2) ? this.Ff = Z$1(this.Ff, 26) : this.Ff = $(this.Ff, 26);
    } });
    var e2, n2 = {};
    Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
      var t2 = function(t3) {
        return t3;
      };
      if (this.scope && (t2 = this.scope.internal.getEncryptor(this.objId)), 0 !== Object.keys(n2).length) {
        var e3, r2 = [];
        for (e3 in r2.push("<<"), n2) r2.push("/" + e3 + " (" + T$2(t2(n2[e3])) + ")");
        return r2.push(">>"), r2.join("\n");
      }
    }, set: function(e3) {
      "object" === _typeof$1(e3) && (n2 = e3);
    } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
      return n2.CA || "";
    }, set: function(t2) {
      "string" == typeof t2 && (n2.CA = t2);
    } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
      return e2;
    }, set: function(t2) {
      e2 = t2;
    } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
      return e2.substr(1, e2.length - 1);
    }, set: function(t2) {
      e2 = "/" + t2;
    } });
  };
  W(mt, ht);
  var vt = function() {
    mt.call(this), this.pushButton = true;
  };
  W(vt, mt);
  var bt = function() {
    mt.call(this), this.radio = true, this.pushButton = false;
    var t2 = [];
    Object.defineProperty(this, "Kids", { enumerable: true, configurable: false, get: function() {
      return t2;
    }, set: function(e2) {
      t2 = void 0 !== e2 ? e2 : [];
    } });
  };
  W(bt, mt);
  var yt = function() {
    var e2, n2;
    ht.call(this), Object.defineProperty(this, "Parent", { enumerable: false, configurable: false, get: function() {
      return e2;
    }, set: function(t2) {
      e2 = t2;
    } }), Object.defineProperty(this, "optionName", { enumerable: false, configurable: true, get: function() {
      return n2;
    }, set: function(t2) {
      n2 = t2;
    } });
    var r2, i2 = {};
    Object.defineProperty(this, "MK", { enumerable: false, configurable: false, get: function() {
      var t2 = function(t3) {
        return t3;
      };
      this.scope && (t2 = this.scope.internal.getEncryptor(this.objId));
      var e3, n3 = [];
      for (e3 in n3.push("<<"), i2) n3.push("/" + e3 + " (" + T$2(t2(i2[e3])) + ")");
      return n3.push(">>"), n3.join("\n");
    }, set: function(e3) {
      "object" === _typeof$1(e3) && (i2 = e3);
    } }), Object.defineProperty(this, "caption", { enumerable: true, configurable: true, get: function() {
      return i2.CA || "";
    }, set: function(t2) {
      "string" == typeof t2 && (i2.CA = t2);
    } }), Object.defineProperty(this, "AS", { enumerable: false, configurable: false, get: function() {
      return r2;
    }, set: function(t2) {
      r2 = t2;
    } }), Object.defineProperty(this, "appearanceState", { enumerable: true, configurable: true, get: function() {
      return r2.substr(1, r2.length - 1);
    }, set: function(t2) {
      r2 = "/" + t2;
    } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = xt.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName);
  };
  W(yt, ht), bt.prototype.setAppearance = function(t2) {
    if (!("createAppearanceStream" in t2) || !("getCA" in t2)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
    for (var e2 in this.Kids) if (this.Kids.hasOwnProperty(e2)) {
      var n2 = this.Kids[e2];
      n2.appearanceStreamContent = t2.createAppearanceStream(n2.optionName), n2.caption = t2.getCA();
    }
  }, bt.prototype.createOption = function(t2) {
    var e2 = new yt();
    return e2.Parent = this, e2.optionName = t2, this.Kids.push(e2), At.call(this.scope, e2), e2;
  };
  var wt = function() {
    mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = xt.CheckBox.createAppearanceStream();
  };
  W(wt, mt);
  var Nt = function() {
    ht.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 13));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 13) : this.Ff = $(this.Ff, 13);
    } }), Object.defineProperty(this, "fileSelect", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 21));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 21) : this.Ff = $(this.Ff, 21);
    } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 23));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 23) : this.Ff = $(this.Ff, 23);
    } }), Object.defineProperty(this, "doNotScroll", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 24));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 24) : this.Ff = $(this.Ff, 24);
    } }), Object.defineProperty(this, "comb", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 25));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 25) : this.Ff = $(this.Ff, 25);
    } }), Object.defineProperty(this, "richText", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 26));
    }, set: function(t3) {
      true === Boolean(t3) ? this.Ff = Z$1(this.Ff, 26) : this.Ff = $(this.Ff, 26);
    } });
    var t2 = null;
    Object.defineProperty(this, "MaxLen", { enumerable: true, configurable: false, get: function() {
      return t2;
    }, set: function(e2) {
      t2 = e2;
    } }), Object.defineProperty(this, "maxLength", { enumerable: true, configurable: true, get: function() {
      return t2;
    }, set: function(e2) {
      Number.isInteger(e2) && (t2 = e2);
    } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: true, configurable: true, get: function() {
      return this.V || this.DV;
    } });
  };
  W(Nt, ht);
  var Lt = function() {
    Nt.call(this), Object.defineProperty(this, "password", { enumerable: true, configurable: true, get: function() {
      return Boolean(K(this.Ff, 14));
    }, set: function(t2) {
      true === Boolean(t2) ? this.Ff = Z$1(this.Ff, 14) : this.Ff = $(this.Ff, 14);
    } }), this.password = true;
  };
  W(Lt, Nt);
  var xt = { CheckBox: { createAppearanceStream: function() {
    return { N: { On: xt.CheckBox.YesNormal }, D: { On: xt.CheckBox.YesPushDown, Off: xt.CheckBox.OffPushDown } };
  }, YesPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [], r2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, i2 = t2.scope.__private__.encodeColorString(t2.color), a2 = et(t2, t2.caption);
    return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t2)) + " " + U$1(xt.internal.getHeight(t2)) + " re"), n2.push("f"), n2.push("BMC"), n2.push("q"), n2.push("0 0 1 rg"), n2.push("/" + r2 + " " + U$1(a2.fontSize) + " Tf " + i2), n2.push("BT"), n2.push(a2.text), n2.push("ET"), n2.push("Q"), n2.push("EMC"), e2.stream = n2.join("\n"), e2;
  }, YesNormal: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, r2 = t2.scope.__private__.encodeColorString(t2.color), i2 = [], a2 = xt.internal.getHeight(t2), o2 = xt.internal.getWidth(t2), s2 = et(t2, t2.caption);
    return i2.push("1 g"), i2.push("0 0 " + U$1(o2) + " " + U$1(a2) + " re"), i2.push("f"), i2.push("q"), i2.push("0 0 1 rg"), i2.push("0 0 " + U$1(o2 - 1) + " " + U$1(a2 - 1) + " re"), i2.push("W"), i2.push("n"), i2.push("0 g"), i2.push("BT"), i2.push("/" + n2 + " " + U$1(s2.fontSize) + " Tf " + r2), i2.push(s2.text), i2.push("ET"), i2.push("Q"), e2.stream = i2.join("\n"), e2;
  }, OffPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [];
    return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t2)) + " " + U$1(xt.internal.getHeight(t2)) + " re"), n2.push("f"), e2.stream = n2.join("\n"), e2;
  } }, RadioButton: { Circle: { createAppearanceStream: function(t2) {
    var e2 = { D: { Off: xt.RadioButton.Circle.OffPushDown }, N: {} };
    return e2.N[t2] = xt.RadioButton.Circle.YesNormal, e2.D[t2] = xt.RadioButton.Circle.YesPushDown, e2;
  }, getCA: function() {
    return "l";
  }, YesNormal: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [], r2 = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
    r2 = Number((0.9 * r2).toFixed(5));
    var i2 = xt.internal.Bezier_C, a2 = Number((r2 * i2).toFixed(5));
    return n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t2) / 2) + " " + H(xt.internal.getHeight(t2) / 2) + " cm"), n2.push(r2 + " 0 m"), n2.push(r2 + " " + a2 + " " + a2 + " " + r2 + " 0 " + r2 + " c"), n2.push("-" + a2 + " " + r2 + " -" + r2 + " " + a2 + " -" + r2 + " 0 c"), n2.push("-" + r2 + " -" + a2 + " -" + a2 + " -" + r2 + " 0 -" + r2 + " c"), n2.push(a2 + " -" + r2 + " " + r2 + " -" + a2 + " " + r2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
  }, YesPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [], r2 = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
    r2 = Number((0.9 * r2).toFixed(5));
    var i2 = Number((2 * r2).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5)), o2 = Number((r2 * xt.internal.Bezier_C).toFixed(5));
    return n2.push("0.749023 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t2) / 2) + " " + H(xt.internal.getHeight(t2) / 2) + " cm"), n2.push(i2 + " 0 m"), n2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n2.push("f"), n2.push("Q"), n2.push("0 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t2) / 2) + " " + H(xt.internal.getHeight(t2) / 2) + " cm"), n2.push(r2 + " 0 m"), n2.push(r2 + " " + o2 + " " + o2 + " " + r2 + " 0 " + r2 + " c"), n2.push("-" + o2 + " " + r2 + " -" + r2 + " " + o2 + " -" + r2 + " 0 c"), n2.push("-" + r2 + " -" + o2 + " -" + o2 + " -" + r2 + " 0 -" + r2 + " c"), n2.push(o2 + " -" + r2 + " " + r2 + " -" + o2 + " " + r2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
  }, OffPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [], r2 = xt.internal.getWidth(t2) <= xt.internal.getHeight(t2) ? xt.internal.getWidth(t2) / 4 : xt.internal.getHeight(t2) / 4;
    r2 = Number((0.9 * r2).toFixed(5));
    var i2 = Number((2 * r2).toFixed(5)), a2 = Number((i2 * xt.internal.Bezier_C).toFixed(5));
    return n2.push("0.749023 g"), n2.push("q"), n2.push("1 0 0 1 " + H(xt.internal.getWidth(t2) / 2) + " " + H(xt.internal.getHeight(t2) / 2) + " cm"), n2.push(i2 + " 0 m"), n2.push(i2 + " " + a2 + " " + a2 + " " + i2 + " 0 " + i2 + " c"), n2.push("-" + a2 + " " + i2 + " -" + i2 + " " + a2 + " -" + i2 + " 0 c"), n2.push("-" + i2 + " -" + a2 + " -" + a2 + " -" + i2 + " 0 -" + i2 + " c"), n2.push(a2 + " -" + i2 + " " + i2 + " -" + a2 + " " + i2 + " 0 c"), n2.push("f"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
  } }, Cross: { createAppearanceStream: function(t2) {
    var e2 = { D: { Off: xt.RadioButton.Cross.OffPushDown }, N: {} };
    return e2.N[t2] = xt.RadioButton.Cross.YesNormal, e2.D[t2] = xt.RadioButton.Cross.YesPushDown, e2;
  }, getCA: function() {
    return "8";
  }, YesNormal: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [], r2 = xt.internal.calculateCross(t2);
    return n2.push("q"), n2.push("1 1 " + U$1(xt.internal.getWidth(t2) - 2) + " " + U$1(xt.internal.getHeight(t2) - 2) + " re"), n2.push("W"), n2.push("n"), n2.push(U$1(r2.x1.x) + " " + U$1(r2.x1.y) + " m"), n2.push(U$1(r2.x2.x) + " " + U$1(r2.x2.y) + " l"), n2.push(U$1(r2.x4.x) + " " + U$1(r2.x4.y) + " m"), n2.push(U$1(r2.x3.x) + " " + U$1(r2.x3.y) + " l"), n2.push("s"), n2.push("Q"), e2.stream = n2.join("\n"), e2;
  }, YesPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = xt.internal.calculateCross(t2), r2 = [];
    return r2.push("0.749023 g"), r2.push("0 0 " + U$1(xt.internal.getWidth(t2)) + " " + U$1(xt.internal.getHeight(t2)) + " re"), r2.push("f"), r2.push("q"), r2.push("1 1 " + U$1(xt.internal.getWidth(t2) - 2) + " " + U$1(xt.internal.getHeight(t2) - 2) + " re"), r2.push("W"), r2.push("n"), r2.push(U$1(n2.x1.x) + " " + U$1(n2.x1.y) + " m"), r2.push(U$1(n2.x2.x) + " " + U$1(n2.x2.y) + " l"), r2.push(U$1(n2.x4.x) + " " + U$1(n2.x4.y) + " m"), r2.push(U$1(n2.x3.x) + " " + U$1(n2.x3.y) + " l"), r2.push("s"), r2.push("Q"), e2.stream = r2.join("\n"), e2;
  }, OffPushDown: function(t2) {
    var e2 = G(t2);
    e2.scope = t2.scope;
    var n2 = [];
    return n2.push("0.749023 g"), n2.push("0 0 " + U$1(xt.internal.getWidth(t2)) + " " + U$1(xt.internal.getHeight(t2)) + " re"), n2.push("f"), e2.stream = n2.join("\n"), e2;
  } } }, createDefaultAppearanceStream: function(t2) {
    var e2 = t2.scope.internal.getFont(t2.fontName, t2.fontStyle).id, n2 = t2.scope.__private__.encodeColorString(t2.color);
    return "/" + e2 + " " + t2.fontSize + " Tf " + n2;
  } };
  xt.internal = { Bezier_C: 0.551915024494, calculateCross: function(t2) {
    var e2 = xt.internal.getWidth(t2), n2 = xt.internal.getHeight(t2), r2 = Math.min(e2, n2);
    return { x1: { x: (e2 - r2) / 2, y: (n2 - r2) / 2 + r2 }, x2: { x: (e2 - r2) / 2 + r2, y: (n2 - r2) / 2 }, x3: { x: (e2 - r2) / 2, y: (n2 - r2) / 2 }, x4: { x: (e2 - r2) / 2 + r2, y: (n2 - r2) / 2 + r2 } };
  } }, xt.internal.getWidth = function(e2) {
    var n2 = 0;
    return "object" === _typeof$1(e2) && (n2 = V$1(e2.Rect[2])), n2;
  }, xt.internal.getHeight = function(e2) {
    var n2 = 0;
    return "object" === _typeof$1(e2) && (n2 = V$1(e2.Rect[3])), n2;
  };
  var At = R.addField = function(t2) {
    if (at(this, t2), !(t2 instanceof ht)) throw new Error("Invalid argument passed to jsPDF.addField.");
    var e2;
    return (e2 = t2).scope.internal.acroformPlugin.printedOut && (e2.scope.internal.acroformPlugin.printedOut = false, e2.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), e2.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(e2), t2.page = t2.scope.internal.getCurrentPageInfo().pageNumber, this;
  };
  R.AcroFormChoiceField = ft, R.AcroFormListBox = dt, R.AcroFormComboBox = pt, R.AcroFormEditBox = gt, R.AcroFormButton = mt, R.AcroFormPushButton = vt, R.AcroFormRadioButton = bt, R.AcroFormCheckBox = wt, R.AcroFormTextField = Nt, R.AcroFormPasswordField = Lt, R.AcroFormAppearance = xt, R.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: xt }, E$1.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: xt };
  E$1.AcroForm;
  function _t(t2) {
    return t2.reduce(function(t3, e2, n2) {
      return t3[e2] = n2, t3;
    }, {});
  }
  !(function(e2) {
    var n2 = "addImage_";
    e2.__addimage__ = {};
    var r2 = "UNKNOWN", i2 = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, a2 = e2.__addimage__.getImageFileTypeByImageData = function(t2, e3) {
      var n3, a3, o3, s3, u3, c3 = r2;
      if ("RGBA" === (e3 = e3 || r2) || void 0 !== t2.data && t2.data instanceof Uint8ClampedArray && "height" in t2 && "width" in t2) return "RGBA";
      if (A2(t2)) for (u3 in i2) for (o3 = i2[u3], n3 = 0; n3 < o3.length; n3 += 1) {
        for (s3 = true, a3 = 0; a3 < o3[n3].length; a3 += 1) if (void 0 !== o3[n3][a3] && o3[n3][a3] !== t2[a3]) {
          s3 = false;
          break;
        }
        if (true === s3) {
          c3 = u3;
          break;
        }
      }
      else for (u3 in i2) for (o3 = i2[u3], n3 = 0; n3 < o3.length; n3 += 1) {
        for (s3 = true, a3 = 0; a3 < o3[n3].length; a3 += 1) if (void 0 !== o3[n3][a3] && o3[n3][a3] !== t2.charCodeAt(a3)) {
          s3 = false;
          break;
        }
        if (true === s3) {
          c3 = u3;
          break;
        }
      }
      return c3 === r2 && e3 !== r2 && (c3 = e3), c3;
    }, o2 = function t2(e3) {
      for (var n3 = this.internal.write, r3 = this.internal.putStream, i3 = (0, this.internal.getFilters)(); -1 !== i3.indexOf("FlateEncode"); ) i3.splice(i3.indexOf("FlateEncode"), 1);
      e3.objectId = this.internal.newObject();
      var a3 = [];
      if (a3.push({ key: "Type", value: "/XObject" }), a3.push({ key: "Subtype", value: "/Image" }), a3.push({ key: "Width", value: e3.width }), a3.push({ key: "Height", value: e3.height }), e3.colorSpace === y2.INDEXED ? a3.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (e3.palette.length / 3 - 1) + " " + ("sMask" in e3 && void 0 !== e3.sMask ? e3.objectId + 2 : e3.objectId + 1) + " 0 R]" }) : (a3.push({ key: "ColorSpace", value: "/" + e3.colorSpace }), e3.colorSpace === y2.DEVICE_CMYK && a3.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), a3.push({ key: "BitsPerComponent", value: e3.bitsPerComponent }), "decodeParameters" in e3 && void 0 !== e3.decodeParameters && a3.push({ key: "DecodeParms", value: "<<" + e3.decodeParameters + ">>" }), "transparency" in e3 && Array.isArray(e3.transparency) && e3.transparency.length > 0) {
        for (var o3 = "", s3 = 0, u3 = e3.transparency.length; s3 < u3; s3++) o3 += e3.transparency[s3] + " " + e3.transparency[s3] + " ";
        a3.push({ key: "Mask", value: "[" + o3 + "]" });
      }
      void 0 !== e3.sMask && a3.push({ key: "SMask", value: e3.objectId + 1 + " 0 R" });
      var c3 = void 0 !== e3.filter ? ["/" + e3.filter] : void 0;
      if (r3({ data: e3.data, additionalKeyValues: a3, alreadyAppliedFilters: c3, objectId: e3.objectId }), n3("endobj"), "sMask" in e3 && void 0 !== e3.sMask) {
        var l3, h3 = null !== (l3 = e3.sMaskBitsPerComponent) && void 0 !== l3 ? l3 : e3.bitsPerComponent, f2 = { width: e3.width, height: e3.height, colorSpace: "DeviceGray", bitsPerComponent: h3, data: e3.sMask };
        "filter" in e3 && (f2.decodeParameters = "/Predictor ".concat(e3.predictor, " /Colors 1 /BitsPerComponent ").concat(h3, " /Columns ").concat(e3.width), f2.filter = e3.filter), t2.call(this, f2);
      }
      if (e3.colorSpace === y2.INDEXED) {
        var d3 = this.internal.newObject();
        r3({ data: _2(new Uint8Array(e3.palette)), objectId: d3 }), n3("endobj");
      }
    }, s2 = function() {
      var t2 = this.internal.collections[n2 + "images"];
      for (var e3 in t2) o2.call(this, t2[e3]);
    }, u2 = function() {
      var t2, e3 = this.internal.collections[n2 + "images"], r3 = this.internal.write;
      for (var i3 in e3) r3("/I" + (t2 = e3[i3]).index, t2.objectId, "0", "R");
    }, c2 = function() {
      this.internal.collections[n2 + "images"] || (this.internal.collections[n2 + "images"] = {}, this.internal.events.subscribe("putResources", s2), this.internal.events.subscribe("putXobjectDict", u2));
    }, l2 = function() {
      var t2 = this.internal.collections[n2 + "images"];
      return c2.call(this), t2;
    }, h2 = function() {
      return Object.keys(this.internal.collections[n2 + "images"]).length;
    }, d2 = function(t2) {
      return "function" == typeof e2["process" + t2.toUpperCase()];
    }, p2 = function(e3) {
      return "object" === _typeof$1(e3) && 1 === e3.nodeType;
    }, g2 = function(t2, n3) {
      if ("IMG" === t2.nodeName && t2.hasAttribute("src")) {
        var r3 = "" + t2.getAttribute("src");
        if (0 === r3.indexOf("data:image/")) return f$2(unescape(r3).split("base64,").pop());
        var i3 = e2.loadFile(r3, true);
        if (void 0 !== i3) return i3;
      }
      if ("CANVAS" === t2.nodeName) {
        if (0 === t2.width || 0 === t2.height) throw new Error("Given canvas must have data. Canvas width: " + t2.width + ", height: " + t2.height);
        var a3;
        switch (n3) {
          case "PNG":
            a3 = "image/png";
            break;
          case "WEBP":
            a3 = "image/webp";
            break;
          default:
            a3 = "image/jpeg";
        }
        return f$2(t2.toDataURL(a3, 1).split("base64,").pop());
      }
    }, m2 = function(t2) {
      var e3 = this.internal.collections[n2 + "images"];
      if (e3) {
        for (var r3 in e3) if (t2 === e3[r3].alias) return e3[r3];
      }
    }, v2 = function(t2, e3, n3) {
      return t2 || e3 || (t2 = -96, e3 = -96), t2 < 0 && (t2 = -1 * n3.width * 72 / t2 / this.internal.scaleFactor), e3 < 0 && (e3 = -1 * n3.height * 72 / e3 / this.internal.scaleFactor), 0 === t2 && (t2 = e3 * n3.width / n3.height), 0 === e3 && (e3 = t2 * n3.height / n3.width), [t2, e3];
    }, b2 = function(t2, e3, n3, r3, i3, a3) {
      var o3 = v2.call(this, n3, r3, i3), s3 = this.internal.getCoordinateString, u3 = this.internal.getVerticalCoordinateString, c3 = l2.call(this);
      if (n3 = o3[0], r3 = o3[1], c3[i3.index] = i3, a3) {
        a3 *= Math.PI / 180;
        var h3 = Math.cos(a3), f2 = Math.sin(a3), d3 = function(t3) {
          return t3.toFixed(4);
        }, p3 = [d3(h3), d3(f2), d3(-1 * f2), d3(h3), 0, 0, "cm"];
      }
      this.internal.write("q"), a3 ? (this.internal.write([1, "0", "0", 1, s3(t2), u3(e3 + r3), "cm"].join(" ")), this.internal.write(p3.join(" ")), this.internal.write([s3(n3), "0", "0", s3(r3), "0", "0", "cm"].join(" "))) : this.internal.write([s3(n3), "0", "0", s3(r3), s3(t2), u3(e3 + r3), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + i3.index + " Do"), this.internal.write("Q");
    }, y2 = e2.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" };
    e2.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" };
    var w2 = e2.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, N2 = e2.__addimage__.sHashCode = function(t2) {
      var e3, n3, r3 = 0;
      if ("string" == typeof t2) for (n3 = t2.length, e3 = 0; e3 < n3; e3++) r3 = (r3 << 5) - r3 + t2.charCodeAt(e3), r3 |= 0;
      else if (A2(t2)) for (n3 = t2.byteLength / 2, e3 = 0; e3 < n3; e3++) r3 = (r3 << 5) - r3 + t2[e3], r3 |= 0;
      return r3;
    }, L2 = e2.__addimage__.validateStringAsBase64 = function(t2) {
      (t2 = t2 || "").toString().trim();
      var e3 = true;
      return 0 === t2.length && (e3 = false), t2.length % 4 != 0 && (e3 = false), false === /^[A-Za-z0-9+/]+$/.test(t2.substr(0, t2.length - 2)) && (e3 = false), false === /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(t2.substr(-2)) && (e3 = false), e3;
    }, x2 = e2.__addimage__.extractImageFromDataUrl = function(t2) {
      if (null == t2) return null;
      if (!(t2 = t2.trim()).startsWith("data:")) return null;
      var e3 = t2.indexOf(",");
      return e3 < 0 ? null : t2.substring(0, e3).trim().endsWith("base64") ? t2.substring(e3 + 1) : null;
    };
    e2.__addimage__.isArrayBuffer = function(t2) {
      return t2 instanceof ArrayBuffer;
    };
    var A2 = e2.__addimage__.isArrayBufferView = function(t2) {
      return t2 instanceof Int8Array || t2 instanceof Uint8Array || t2 instanceof Uint8ClampedArray || t2 instanceof Int16Array || t2 instanceof Uint16Array || t2 instanceof Int32Array || t2 instanceof Uint32Array || t2 instanceof Float32Array || t2 instanceof Float64Array;
    }, S2 = e2.__addimage__.binaryStringToUint8Array = function(t2) {
      for (var e3 = t2.length, n3 = new Uint8Array(e3), r3 = 0; r3 < e3; r3++) n3[r3] = t2.charCodeAt(r3);
      return n3;
    }, _2 = e2.__addimage__.arrayBufferToBinaryString = function(t2) {
      for (var e3 = "", n3 = A2(t2) ? t2 : new Uint8Array(t2), r3 = 0; r3 < n3.length; r3 += 8192) e3 += String.fromCharCode.apply(null, n3.subarray(r3, r3 + 8192));
      return e3;
    };
    e2.addImage = function() {
      var e3, n3, i3, a3, o3, s3, u3, l3, h3;
      if ("number" == typeof arguments[1] ? (n3 = r2, i3 = arguments[1], a3 = arguments[2], o3 = arguments[3], s3 = arguments[4], u3 = arguments[5], l3 = arguments[6], h3 = arguments[7]) : (n3 = arguments[1], i3 = arguments[2], a3 = arguments[3], o3 = arguments[4], s3 = arguments[5], u3 = arguments[6], l3 = arguments[7], h3 = arguments[8]), "object" === _typeof$1(e3 = arguments[0]) && !p2(e3) && "imageData" in e3) {
        var f2 = e3;
        e3 = f2.imageData, n3 = f2.format || n3 || r2, i3 = f2.x || i3 || 0, a3 = f2.y || a3 || 0, o3 = f2.w || f2.width || o3, s3 = f2.h || f2.height || s3, u3 = f2.alias || u3, l3 = f2.compression || l3, h3 = f2.rotation || f2.angle || h3;
      }
      var d3 = this.internal.getFilters();
      if (void 0 === l3 && -1 !== d3.indexOf("FlateEncode") && (l3 = "SLOW"), isNaN(i3) || isNaN(a3)) throw new Error("Invalid coordinates passed to jsPDF.addImage");
      c2.call(this);
      var g3 = P2.call(this, e3, n3, u3, l3);
      return b2.call(this, i3, a3, o3, s3, g3, h3), this;
    };
    var P2 = function(t2, n3, i3, o3) {
      var s3, u3, c3;
      if ("string" == typeof t2 && a2(t2) === r2) {
        t2 = unescape(t2);
        var l3 = k2(t2, false);
        ("" !== l3 || void 0 !== (l3 = e2.loadFile(t2, true))) && (t2 = l3);
      }
      if (p2(t2) && (t2 = g2(t2, n3)), n3 = a2(t2, n3), !d2(n3)) throw new Error("addImage does not support files of type '" + n3 + "', please ensure that a plugin for '" + n3 + "' support is added.");
      if ((null == (c3 = i3) || 0 === c3.length) && (i3 = (function(t3) {
        return "string" == typeof t3 || A2(t3) ? N2(t3) : A2(t3.data) ? N2(t3.data) : null;
      })(t2)), (s3 = m2.call(this, i3)) || (t2 instanceof Uint8Array || "RGBA" === n3 || (u3 = t2, t2 = S2(t2)), s3 = this["process" + n3.toUpperCase()](t2, h2.call(this), i3, (function(t3) {
        return t3 && "string" == typeof t3 && (t3 = t3.toUpperCase()), t3 in e2.image_compression ? t3 : w2.NONE;
      })(o3), u3)), !s3) throw new Error("An unknown error occurred whilst processing the image.");
      return s3;
    }, k2 = e2.__addimage__.convertBase64ToBinaryString = function(t2, e3) {
      e3 = "boolean" != typeof e3 || e3;
      var n3, r3 = "";
      if ("string" == typeof t2) {
        var i3;
        n3 = null !== (i3 = x2(t2)) && void 0 !== i3 ? i3 : t2;
        try {
          r3 = f$2(n3);
        } catch (a3) {
          if (e3) throw L2(n3) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + a3.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ");
        }
      }
      return r3;
    };
    e2.getImageProperties = function(t2) {
      var n3, i3, o3 = "";
      if (p2(t2) && (t2 = g2(t2)), "string" == typeof t2 && a2(t2) === r2 && ("" === (o3 = k2(t2, false)) && (o3 = e2.loadFile(t2) || ""), t2 = o3), i3 = a2(t2), !d2(i3)) throw new Error("addImage does not support files of type '" + i3 + "', please ensure that a plugin for '" + i3 + "' support is added.");
      if (t2 instanceof Uint8Array || (t2 = S2(t2)), !(n3 = this["process" + i3.toUpperCase()](t2))) throw new Error("An unknown error occurred whilst processing the image");
      return n3.fileType = i3, n3;
    };
  })(E$1.API), /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = function(t3) {
      if (void 0 !== t3 && "" != t3) return true;
    };
    E$1.API.events.push(["addPage", function(t3) {
      this.internal.getPageInfo(t3.pageNumber).pageContext.annotations = [];
    }]), t2.events.push(["putPage", function(t3) {
      for (var n2, r2, i2, a2 = this.internal.getCoordinateString, o2 = this.internal.getVerticalCoordinateString, s2 = this.internal.getPageInfoByObjId(t3.objId), u2 = t3.pageContext.annotations, c2 = false, l2 = 0; l2 < u2.length && !c2; l2++) switch ((n2 = u2[l2]).type) {
        case "link":
          (e2(n2.options.url) || e2(n2.options.pageNumber)) && (c2 = true);
          break;
        case "reference":
        case "text":
        case "freetext":
          c2 = true;
      }
      if (0 != c2) {
        this.internal.write("/Annots [");
        for (var h2 = 0; h2 < u2.length; h2++) {
          n2 = u2[h2];
          var f2 = this.internal.pdfEscape, d2 = this.internal.getEncryptor(t3.objId);
          switch (n2.type) {
            case "reference":
              this.internal.write(" " + n2.object.objId + " 0 R ");
              break;
            case "text":
              var p2 = this.internal.newAdditionalObject(), g2 = this.internal.newAdditionalObject(), m2 = this.internal.getEncryptor(p2.objId), v2 = n2.title || "Note";
              i2 = "<</Type /Annot /Subtype /Text " + (r2 = "/Rect [" + a2(n2.bounds.x) + " " + o2(n2.bounds.y + n2.bounds.h) + " " + a2(n2.bounds.x + n2.bounds.w) + " " + o2(n2.bounds.y) + "] ") + "/Contents (" + f2(m2(n2.contents)) + ")", i2 += " /Popup " + g2.objId + " 0 R", i2 += " /P " + s2.objId + " 0 R", i2 += " /T (" + f2(m2(v2)) + ") >>", p2.content = i2;
              var b2 = p2.objId + " 0 R";
              i2 = "<</Type /Annot /Subtype /Popup " + (r2 = "/Rect [" + a2(n2.bounds.x + 30) + " " + o2(n2.bounds.y + n2.bounds.h) + " " + a2(n2.bounds.x + n2.bounds.w + 30) + " " + o2(n2.bounds.y) + "] ") + " /Parent " + b2, n2.open && (i2 += " /Open true"), i2 += " >>", g2.content = i2, this.internal.write(p2.objId, "0 R", g2.objId, "0 R");
              break;
            case "freetext":
              r2 = "/Rect [" + a2(n2.bounds.x) + " " + o2(n2.bounds.y) + " " + a2(n2.bounds.x + n2.bounds.w) + " " + o2(n2.bounds.y + n2.bounds.h) + "] ";
              var y2 = n2.color || "#000000";
              i2 = "<</Type /Annot /Subtype /FreeText " + r2 + "/Contents (" + f2(d2(n2.contents)) + ")", i2 += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + y2 + ")", i2 += " /Border [0 0 0]", i2 += " >>", this.internal.write(i2);
              break;
            case "link":
              if (n2.options.name) {
                var w2 = this.annotations._nameMap[n2.options.name];
                n2.options.pageNumber = w2.page, n2.options.top = w2.y;
              } else n2.options.top || (n2.options.top = 0);
              if (r2 = "/Rect [" + n2.finalBounds.x + " " + n2.finalBounds.y + " " + n2.finalBounds.w + " " + n2.finalBounds.h + "] ", i2 = "", n2.options.url) i2 = "<</Type /Annot /Subtype /Link " + r2 + "/Border [0 0 0] /A <</S /URI /URI (" + f2(d2(n2.options.url)) + ") >>";
              else if (n2.options.pageNumber) switch (i2 = "<</Type /Annot /Subtype /Link " + r2 + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(n2.options.pageNumber).objId + " 0 R", n2.options.magFactor = n2.options.magFactor || "XYZ", n2.options.magFactor) {
                case "Fit":
                  i2 += " /Fit]";
                  break;
                case "FitH":
                  i2 += " /FitH " + n2.options.top + "]";
                  break;
                case "FitV":
                  n2.options.left = n2.options.left || 0, i2 += " /FitV " + n2.options.left + "]";
                  break;
                default:
                  var N2 = o2(n2.options.top);
                  n2.options.left = n2.options.left || 0, void 0 === n2.options.zoom && (n2.options.zoom = 0), i2 += " /XYZ " + n2.options.left + " " + N2 + " " + n2.options.zoom + "]";
              }
              "" != i2 && (i2 += " >>", this.internal.write(i2));
          }
        }
        this.internal.write("]");
      }
    }]), t2.createAnnotation = function(t3) {
      var e3 = this.internal.getCurrentPageInfo();
      switch (t3.type) {
        case "link":
          this.link(t3.bounds.x, t3.bounds.y, t3.bounds.w, t3.bounds.h, t3);
          break;
        case "text":
        case "freetext":
          e3.pageContext.annotations.push(t3);
      }
    }, t2.link = function(t3, e3, n2, r2, i2) {
      var a2 = this.internal.getCurrentPageInfo(), o2 = this.internal.getCoordinateString, s2 = this.internal.getVerticalCoordinateString;
      a2.pageContext.annotations.push({ finalBounds: { x: o2(t3), y: s2(e3), w: o2(t3 + n2), h: s2(e3 + r2) }, options: i2, type: "link" });
    }, t2.textWithLink = function(t3, e3, n2, r2) {
      var i2, a2, o2 = this.getTextWidth(t3), s2 = this.internal.getLineHeight() / this.internal.scaleFactor;
      if (void 0 !== r2.maxWidth) {
        a2 = r2.maxWidth;
        var u2 = this.splitTextToSize(t3, a2).length;
        i2 = Math.ceil(s2 * u2);
      } else a2 = o2, i2 = s2;
      return this.text(t3, e3, n2, r2), n2 += 0.2 * s2, "center" === r2.align && (e3 -= o2 / 2), "right" === r2.align && (e3 -= o2), this.link(e3, n2 - s2, a2, i2, r2), o2;
    }, t2.getTextWidth = function(t3) {
      var e3 = this.internal.getFontSize();
      return this.getStringUnitWidth(t3) * e3 / this.internal.scaleFactor;
    };
  })(E$1.API), /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, n2 = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, r2 = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, i2 = [1570, 1571, 1573, 1575];
    t2.__arabicParser__ = {};
    var a2 = t2.__arabicParser__.isInArabicSubstitutionA = function(t3) {
      return void 0 !== e2[t3.charCodeAt(0)];
    }, o2 = t2.__arabicParser__.isArabicLetter = function(t3) {
      return "string" == typeof t3 && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(t3);
    }, s2 = t2.__arabicParser__.isArabicEndLetter = function(t3) {
      return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length <= 2;
    }, u2 = t2.__arabicParser__.isArabicAlfLetter = function(t3) {
      return o2(t3) && i2.indexOf(t3.charCodeAt(0)) >= 0;
    };
    t2.__arabicParser__.arabicLetterHasIsolatedForm = function(t3) {
      return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 1;
    };
    var c2 = t2.__arabicParser__.arabicLetterHasFinalForm = function(t3) {
      return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 2;
    };
    t2.__arabicParser__.arabicLetterHasInitialForm = function(t3) {
      return o2(t3) && a2(t3) && e2[t3.charCodeAt(0)].length >= 3;
    };
    var l2 = t2.__arabicParser__.arabicLetterHasMedialForm = function(t3) {
      return o2(t3) && a2(t3) && 4 == e2[t3.charCodeAt(0)].length;
    }, h2 = t2.__arabicParser__.resolveLigatures = function(t3) {
      var e3 = 0, r3 = n2, i3 = "", a3 = 0;
      for (e3 = 0; e3 < t3.length; e3 += 1) void 0 !== r3[t3.charCodeAt(e3)] ? (a3++, "number" == typeof (r3 = r3[t3.charCodeAt(e3)]) && (i3 += String.fromCharCode(r3), r3 = n2, a3 = 0), e3 === t3.length - 1 && (r3 = n2, i3 += t3.charAt(e3 - (a3 - 1)), e3 -= a3 - 1, a3 = 0)) : (r3 = n2, i3 += t3.charAt(e3 - a3), e3 -= a3, a3 = 0);
      return i3;
    };
    t2.__arabicParser__.isArabicDiacritic = function(t3) {
      return void 0 !== t3 && void 0 !== r2[t3.charCodeAt(0)];
    };
    var f2 = t2.__arabicParser__.getCorrectForm = function(t3, e3, n3) {
      return o2(t3) ? false === a2(t3) ? -1 : !c2(t3) || !o2(e3) && !o2(n3) || !o2(n3) && s2(e3) || s2(t3) && !o2(e3) || s2(t3) && u2(e3) || s2(t3) && s2(e3) ? 0 : l2(t3) && o2(e3) && !s2(e3) && o2(n3) && c2(n3) ? 3 : s2(t3) || !o2(n3) ? 1 : 2 : -1;
    }, d2 = function(t3) {
      var n3 = 0, r3 = 0, i3 = 0, a3 = "", s3 = "", u3 = "", c3 = (t3 = t3 || "").split("\\s+"), l3 = [];
      for (n3 = 0; n3 < c3.length; n3 += 1) {
        for (l3.push(""), r3 = 0; r3 < c3[n3].length; r3 += 1) a3 = c3[n3][r3], s3 = c3[n3][r3 - 1], u3 = c3[n3][r3 + 1], o2(a3) ? (i3 = f2(a3, s3, u3), l3[n3] += -1 !== i3 ? String.fromCharCode(e2[a3.charCodeAt(0)][i3]) : a3) : l3[n3] += a3;
        l3[n3] = h2(l3[n3]);
      }
      return l3.join(" ");
    }, p2 = t2.__arabicParser__.processArabic = t2.processArabic = function() {
      var t3, e3 = "string" == typeof arguments[0] ? arguments[0] : arguments[0].text, n3 = [];
      if (Array.isArray(e3)) {
        var r3 = 0;
        for (n3 = [], r3 = 0; r3 < e3.length; r3 += 1) Array.isArray(e3[r3]) ? n3.push([d2(e3[r3][0]), e3[r3][1], e3[r3][2]]) : n3.push([d2(e3[r3])]);
        t3 = n3;
      } else t3 = d2(e3);
      return "string" == typeof arguments[0] ? t3 : (arguments[0].text = t3, arguments[0]);
    };
    t2.events.push(["preProcessText", p2]);
  })(E$1.API), E$1.API.autoPrint = function(t2) {
    var e2;
    return (t2 = t2 || {}).variant = t2.variant || "non-conform", "javascript" === t2.variant ? this.addJS("print({});") : (this.internal.events.subscribe("postPutResources", function() {
      e2 = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function() {
      this.internal.out("/OpenAction " + e2 + " 0 R");
    })), this;
  }, /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = function() {
      var t3 = void 0;
      Object.defineProperty(this, "pdf", { get: function() {
        return t3;
      }, set: function(e4) {
        t3 = e4;
      } });
      var e3 = 150;
      Object.defineProperty(this, "width", { get: function() {
        return e3;
      }, set: function(t4) {
        e3 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 150 : t4, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = e3 + 1);
      } });
      var n2 = 300;
      Object.defineProperty(this, "height", { get: function() {
        return n2;
      }, set: function(t4) {
        n2 = isNaN(t4) || false === Number.isInteger(t4) || t4 < 0 ? 300 : t4, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = n2 + 1);
      } });
      var r2 = [];
      Object.defineProperty(this, "childNodes", { get: function() {
        return r2;
      }, set: function(t4) {
        r2 = t4;
      } });
      var i2 = {};
      Object.defineProperty(this, "style", { get: function() {
        return i2;
      }, set: function(t4) {
        i2 = t4;
      } }), Object.defineProperty(this, "parentNode", {});
    };
    e2.prototype.getContext = function(t3, e3) {
      var n2;
      if ("2d" !== (t3 = t3 || "2d")) return null;
      for (n2 in e3) this.pdf.context2d.hasOwnProperty(n2) && (this.pdf.context2d[n2] = e3[n2]);
      return this.pdf.context2d._canvas = this, this.pdf.context2d;
    }, e2.prototype.toDataURL = function() {
      throw new Error("toDataURL is not implemented.");
    }, t2.events.push(["initialized", function() {
      this.canvas = new e2(), this.canvas.pdf = this;
    }]);
  })(E$1.API), (function(e2) {
    var n2 = { left: 0, top: 0, bottom: 0, right: 0 }, r2 = false, i2 = function() {
      void 0 === this.internal.__cell__ && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, n2), this.internal.__cell__.margins.width = this.getPageWidth(), a2.call(this));
    }, a2 = function() {
      this.internal.__cell__.lastCell = new o2(), this.internal.__cell__.pages = 1;
    }, o2 = function() {
      var t2 = arguments[0];
      Object.defineProperty(this, "x", { enumerable: true, get: function() {
        return t2;
      }, set: function(e4) {
        t2 = e4;
      } });
      var e3 = arguments[1];
      Object.defineProperty(this, "y", { enumerable: true, get: function() {
        return e3;
      }, set: function(t3) {
        e3 = t3;
      } });
      var n3 = arguments[2];
      Object.defineProperty(this, "width", { enumerable: true, get: function() {
        return n3;
      }, set: function(t3) {
        n3 = t3;
      } });
      var r3 = arguments[3];
      Object.defineProperty(this, "height", { enumerable: true, get: function() {
        return r3;
      }, set: function(t3) {
        r3 = t3;
      } });
      var i3 = arguments[4];
      Object.defineProperty(this, "text", { enumerable: true, get: function() {
        return i3;
      }, set: function(t3) {
        i3 = t3;
      } });
      var a3 = arguments[5];
      Object.defineProperty(this, "lineNumber", { enumerable: true, get: function() {
        return a3;
      }, set: function(t3) {
        a3 = t3;
      } });
      var o3 = arguments[6];
      return Object.defineProperty(this, "align", { enumerable: true, get: function() {
        return o3;
      }, set: function(t3) {
        o3 = t3;
      } }), this;
    };
    o2.prototype.clone = function() {
      return new o2(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align);
    }, o2.prototype.toArray = function() {
      return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align];
    }, e2.setHeaderFunction = function(t2) {
      return i2.call(this), this.internal.__cell__.headerFunction = "function" == typeof t2 ? t2 : void 0, this;
    }, e2.getTextDimensions = function(t2, e3) {
      i2.call(this);
      var n3 = (e3 = e3 || {}).fontSize || this.getFontSize(), r3 = e3.font || this.getFont(), a3 = e3.scaleFactor || this.internal.scaleFactor, o3 = 0, s3 = 0, u3 = 0, c2 = this;
      if (!Array.isArray(t2) && "string" != typeof t2) {
        if ("number" != typeof t2) throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings.");
        t2 = String(t2);
      }
      var l2 = e3.maxWidth;
      l2 > 0 ? "string" == typeof t2 ? t2 = this.splitTextToSize(t2, l2) : "[object Array]" === Object.prototype.toString.call(t2) && (t2 = t2.reduce(function(t3, e4) {
        return t3.concat(c2.splitTextToSize(e4, l2));
      }, [])) : t2 = Array.isArray(t2) ? t2 : [t2];
      for (var h2 = 0; h2 < t2.length; h2++) o3 < (u3 = this.getStringUnitWidth(t2[h2], { font: r3 }) * n3) && (o3 = u3);
      return 0 !== o3 && (s3 = t2.length), { w: o3 /= a3, h: Math.max((s3 * n3 * this.getLineHeightFactor() - n3 * (this.getLineHeightFactor() - 1)) / a3, 0) };
    }, e2.cellAddPage = function() {
      i2.call(this), this.addPage();
      var t2 = this.internal.__cell__.margins || n2;
      return this.internal.__cell__.lastCell = new o2(t2.left, t2.top, void 0, void 0), this.internal.__cell__.pages += 1, this;
    };
    var s2 = e2.cell = function() {
      var t2;
      t2 = arguments[0] instanceof o2 ? arguments[0] : new o2(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6]), i2.call(this);
      var e3 = this.internal.__cell__.lastCell, a3 = this.internal.__cell__.padding, s3 = this.internal.__cell__.margins || n2, u3 = this.internal.__cell__.tableHeaderRow, c2 = this.internal.__cell__.printHeaders;
      return void 0 !== e3.lineNumber && (e3.lineNumber === t2.lineNumber ? (t2.x = (e3.x || 0) + (e3.width || 0), t2.y = e3.y || 0) : e3.y + e3.height + t2.height + s3.bottom > this.getPageHeight() ? (this.cellAddPage(), t2.y = s3.top, c2 && u3 && (this.printHeaderRow(t2.lineNumber, true), t2.y += u3[0].height)) : t2.y = e3.y + e3.height || t2.y), void 0 !== t2.text[0] && (this.rect(t2.x, t2.y, t2.width, t2.height, true === r2 ? "FD" : void 0), "right" === t2.align ? this.text(t2.text, t2.x + t2.width - a3, t2.y + a3, { align: "right", baseline: "top" }) : "center" === t2.align ? this.text(t2.text, t2.x + t2.width / 2, t2.y + a3, { align: "center", baseline: "top", maxWidth: t2.width - a3 - a3 }) : this.text(t2.text, t2.x + a3, t2.y + a3, { align: "left", baseline: "top", maxWidth: t2.width - a3 - a3 })), this.internal.__cell__.lastCell = t2, this;
    };
    e2.table = function(e3, r3, c2, l2, h2) {
      if (i2.call(this), !c2) throw new Error("No data for PDF table.");
      var f2, d2, p2, g2, m2 = [], v2 = [], b2 = [], y2 = {}, w2 = {}, N2 = [], L2 = [], x2 = (h2 = h2 || {}).autoSize || false, A2 = false !== h2.printHeaders, S2 = h2.css && void 0 !== h2.css["font-size"] ? 16 * h2.css["font-size"] : h2.fontSize || 12, _2 = h2.margins || Object.assign({ width: this.getPageWidth() }, n2), P2 = "number" == typeof h2.padding ? h2.padding : 3, k2 = h2.headerBackgroundColor || "#c8c8c8", F2 = h2.headerTextColor || "#000";
      if (a2.call(this), this.internal.__cell__.printHeaders = A2, this.internal.__cell__.margins = _2, this.internal.__cell__.table_font_size = S2, this.internal.__cell__.padding = P2, this.internal.__cell__.headerBackgroundColor = k2, this.internal.__cell__.headerTextColor = F2, this.setFontSize(S2), null == l2) v2 = m2 = Object.keys(c2[0]), b2 = m2.map(function() {
        return "left";
      });
      else if (Array.isArray(l2) && "object" === _typeof$1(l2[0])) for (m2 = l2.map(function(t2) {
        return t2.name;
      }), v2 = l2.map(function(t2) {
        return t2.prompt || t2.name || "";
      }), b2 = l2.map(function(t2) {
        return t2.align || "left";
      }), f2 = 0; f2 < l2.length; f2 += 1) w2[l2[f2].name] = 0.7499990551181103 * l2[f2].width;
      else Array.isArray(l2) && "string" == typeof l2[0] && (v2 = m2 = l2, b2 = m2.map(function() {
        return "left";
      }));
      if (x2 || Array.isArray(l2) && "string" == typeof l2[0]) for (f2 = 0; f2 < m2.length; f2 += 1) {
        for (y2[g2 = m2[f2]] = c2.map(function(t2) {
          return t2[g2];
        }), this.setFont(void 0, "bold"), N2.push(this.getTextDimensions(v2[f2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), d2 = y2[g2], this.setFont(void 0, "normal"), p2 = 0; p2 < d2.length; p2 += 1) N2.push(this.getTextDimensions(d2[p2], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w);
        w2[g2] = Math.max.apply(null, N2) + P2 + P2, N2 = [];
      }
      if (A2) {
        var I2 = {};
        for (f2 = 0; f2 < m2.length; f2 += 1) I2[m2[f2]] = {}, I2[m2[f2]].text = v2[f2], I2[m2[f2]].align = b2[f2];
        var j2 = u2.call(this, I2, w2);
        L2 = m2.map(function(t2) {
          return new o2(e3, r3, w2[t2], j2, I2[t2].text, void 0, I2[t2].align);
        }), this.setTableHeaderRow(L2), this.printHeaderRow(1, false);
      }
      var C2 = l2.reduce(function(t2, e4) {
        return t2[e4.name] = e4.align, t2;
      }, {});
      for (f2 = 0; f2 < c2.length; f2 += 1) {
        "rowStart" in h2 && h2.rowStart instanceof Function && h2.rowStart({ row: f2, data: c2[f2] }, this);
        var O2 = u2.call(this, c2[f2], w2);
        for (p2 = 0; p2 < m2.length; p2 += 1) {
          var B3 = c2[f2][m2[p2]];
          "cellStart" in h2 && h2.cellStart instanceof Function && h2.cellStart({ row: f2, col: p2, data: B3 }, this), s2.call(this, new o2(e3, r3, w2[m2[p2]], O2, B3, f2 + 2, C2[m2[p2]]));
        }
      }
      return this.internal.__cell__.table_x = e3, this.internal.__cell__.table_y = r3, this;
    };
    var u2 = function(t2, e3) {
      var n3 = this.internal.__cell__.padding, r3 = this.internal.__cell__.table_font_size, i3 = this.internal.scaleFactor;
      return Object.keys(t2).map(function(r4) {
        var i4 = t2[r4];
        return this.splitTextToSize(i4.hasOwnProperty("text") ? i4.text : i4, e3[r4] - n3 - n3);
      }, this).map(function(t3) {
        return this.getLineHeightFactor() * t3.length * r3 / i3 + n3 + n3;
      }, this).reduce(function(t3, e4) {
        return Math.max(t3, e4);
      }, 0);
    };
    e2.setTableHeaderRow = function(t2) {
      i2.call(this), this.internal.__cell__.tableHeaderRow = t2;
    }, e2.printHeaderRow = function(t2, e3) {
      if (i2.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist.");
      var n3;
      if (r2 = true, "function" == typeof this.internal.__cell__.headerFunction) {
        var a3 = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages);
        this.internal.__cell__.lastCell = new o2(a3[0], a3[1], a3[2], a3[3], void 0, -1);
      }
      this.setFont(void 0, "bold");
      for (var u3 = [], c2 = 0; c2 < this.internal.__cell__.tableHeaderRow.length; c2 += 1) {
        n3 = this.internal.__cell__.tableHeaderRow[c2].clone(), e3 && (n3.y = this.internal.__cell__.margins.top || 0, u3.push(n3)), n3.lineNumber = t2;
        var l2 = this.getTextColor();
        this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), s2.call(this, n3), this.setTextColor(l2);
      }
      u3.length > 0 && this.setTableHeaderRow(u3), this.setFont(void 0, "normal"), r2 = false;
    };
  })(E$1.API);
  var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], Ft = _t(kt), It = [100, 200, 300, 400, 500, 600, 700, 800, 900], jt = _t(It);
  function Ct(t2) {
    var e2 = t2.family.replace(/"|'/g, "").toLowerCase(), n2 = (function(t3) {
      return Pt[t3 = t3 || "normal"] ? t3 : "normal";
    })(t2.style), r2 = (function(t3) {
      return t3 ? "number" == typeof t3 ? t3 >= 100 && t3 <= 900 && t3 % 100 == 0 ? t3 : 400 : /^\d00$/.test(t3) ? parseInt(t3) : "bold" === t3 ? 700 : 400 : 400;
    })(t2.weight), i2 = (function(t3) {
      return "number" == typeof Ft[t3 = t3 || "normal"] ? t3 : "normal";
    })(t2.stretch);
    return { family: e2, style: n2, weight: r2, stretch: i2, src: t2.src || [], ref: t2.ref || { name: e2, style: [i2, n2, r2].join(" ") } };
  }
  function Ot(t2, e2, n2, r2) {
    var i2;
    for (i2 = n2; i2 >= 0 && i2 < e2.length; i2 += r2) if (t2[e2[i2]]) return t2[e2[i2]];
    for (i2 = n2; i2 >= 0 && i2 < e2.length; i2 -= r2) if (t2[e2[i2]]) return t2[e2[i2]];
  }
  var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" };
  function qt(t2) {
    return [t2.stretch, t2.style, t2.weight, t2.family].join(" ");
  }
  function Et(t2) {
    return t2.trimLeft();
  }
  function Rt(t2, e2) {
    for (var n2 = 0; n2 < t2.length; ) {
      if (t2.charAt(n2) === e2) return [t2.substring(0, n2), t2.substring(n2 + 1)];
      n2 += 1;
    }
    return null;
  }
  function Dt(t2) {
    var e2 = t2.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i);
    return null === e2 ? null : [e2[0], t2.substring(e2[0].length)];
  }
  var Tt, zt, Ut, Ht, Wt, Vt, Gt, Yt, Jt = ["times"];
  function Xt(t2, n2, r2, i2, a2) {
    var o2 = 4, s2 = $t;
    switch (a2) {
      case E$1.API.image_compression.FAST:
        o2 = 1, s2 = Zt;
        break;
      case E$1.API.image_compression.MEDIUM:
        o2 = 6, s2 = Qt;
        break;
      case E$1.API.image_compression.SLOW:
        o2 = 9, s2 = te;
    }
    t2 = (function(t3, e2, n3, r3) {
      for (var i3, a3 = t3.length / e2, o3 = new Uint8Array(t3.length + a3), s3 = [Kt, Zt, $t, Qt, te], u3 = 0; u3 < a3; u3 += 1) {
        var c2 = u3 * e2, l2 = t3.subarray(c2, c2 + e2);
        if (r3) o3.set(r3(l2, n3, i3), c2 + u3);
        else {
          for (var h2 = s3.length, f2 = [], d2 = 0; d2 < h2; d2 += 1) f2[d2] = s3[d2](l2, n3, i3);
          var p2 = ne(f2.concat());
          o3.set(f2[p2], c2 + u3);
        }
        i3 = l2;
      }
      return o3;
    })(t2, n2, Math.ceil(r2 * i2 / 8), s2);
    var u2 = zlibSync(t2, { level: o2 });
    return E$1.API.__addimage__.arrayBufferToBinaryString(u2);
  }
  function Kt(t2) {
    var e2 = Array.apply([], t2);
    return e2.unshift(0), e2;
  }
  function Zt(t2, e2) {
    var n2 = t2.length, r2 = [];
    r2[0] = 1;
    for (var i2 = 0; i2 < n2; i2 += 1) {
      var a2 = t2[i2 - e2] || 0;
      r2[i2 + 1] = t2[i2] - a2 + 256 & 255;
    }
    return r2;
  }
  function $t(t2, e2, n2) {
    var r2 = t2.length, i2 = [];
    i2[0] = 2;
    for (var a2 = 0; a2 < r2; a2 += 1) {
      var o2 = n2 && n2[a2] || 0;
      i2[a2 + 1] = t2[a2] - o2 + 256 & 255;
    }
    return i2;
  }
  function Qt(t2, e2, n2) {
    var r2 = t2.length, i2 = [];
    i2[0] = 3;
    for (var a2 = 0; a2 < r2; a2 += 1) {
      var o2 = t2[a2 - e2] || 0, s2 = n2 && n2[a2] || 0;
      i2[a2 + 1] = t2[a2] + 256 - (o2 + s2 >>> 1) & 255;
    }
    return i2;
  }
  function te(t2, e2, n2) {
    var r2 = t2.length, i2 = [];
    i2[0] = 4;
    for (var a2 = 0; a2 < r2; a2 += 1) {
      var o2 = ee(t2[a2 - e2] || 0, n2 && n2[a2] || 0, n2 && n2[a2 - e2] || 0);
      i2[a2 + 1] = t2[a2] - o2 + 256 & 255;
    }
    return i2;
  }
  function ee(t2, e2, n2) {
    if (t2 === e2 && e2 === n2) return t2;
    var r2 = Math.abs(e2 - n2), i2 = Math.abs(t2 - n2), a2 = Math.abs(t2 + e2 - n2 - n2);
    return r2 <= i2 && r2 <= a2 ? t2 : i2 <= a2 ? e2 : n2;
  }
  function ne(t2) {
    var e2 = t2.map(function(t3) {
      return t3.reduce(function(t4, e3) {
        return t4 + Math.abs(e3);
      }, 0);
    });
    return e2.indexOf(Math.min.apply(null, e2));
  }
  function re(t2, e2, n2) {
    var r2 = e2 * n2, i2 = Math.floor(r2 / 8), a2 = 16 - (r2 - 8 * i2 + n2), o2 = (1 << n2) - 1;
    return ae(t2, i2) >> a2 & o2;
  }
  function ie(t2, e2, n2, r2) {
    var i2 = n2 * r2, a2 = Math.floor(i2 / 8), o2 = 16 - (i2 - 8 * a2 + r2), s2 = (1 << r2) - 1, u2 = (e2 & s2) << o2;
    !(function(t3, e3, n3) {
      if (e3 + 1 < t3.byteLength) t3.setUint16(e3, n3, false);
      else {
        var r3 = n3 >> 8 & 255;
        t3.setUint8(e3, r3);
      }
    })(t2, a2, ae(t2, a2) & ~(s2 << o2) & 65535 | u2);
  }
  function ae(t2, e2) {
    return e2 + 1 < t2.byteLength ? t2.getUint16(e2, false) : t2.getUint8(e2) << 8;
  }
  function oe(t2) {
    var e2 = 0;
    if (71 !== t2[e2++] || 73 !== t2[e2++] || 70 !== t2[e2++] || 56 !== t2[e2++] || 56 != (t2[e2++] + 1 & 253) || 97 !== t2[e2++]) throw new Error("Invalid GIF 87a/89a header.");
    var n2 = t2[e2++] | t2[e2++] << 8, r2 = t2[e2++] | t2[e2++] << 8, i2 = t2[e2++], a2 = i2 >> 7, o2 = 1 << 1 + (7 & i2);
    t2[e2++], t2[e2++];
    var s2 = null, u2 = null;
    a2 && (s2 = e2, u2 = o2, e2 += 3 * o2);
    var c2 = true, l2 = [], h2 = 0, f2 = null, d2 = 0, p2 = null;
    for (this.width = n2, this.height = r2; c2 && e2 < t2.length; ) switch (t2[e2++]) {
      case 33:
        switch (t2[e2++]) {
          case 255:
            if (11 !== t2[e2] || 78 == t2[e2 + 1] && 69 == t2[e2 + 2] && 84 == t2[e2 + 3] && 83 == t2[e2 + 4] && 67 == t2[e2 + 5] && 65 == t2[e2 + 6] && 80 == t2[e2 + 7] && 69 == t2[e2 + 8] && 50 == t2[e2 + 9] && 46 == t2[e2 + 10] && 48 == t2[e2 + 11] && 3 == t2[e2 + 12] && 1 == t2[e2 + 13] && 0 == t2[e2 + 16]) e2 += 14, p2 = t2[e2++] | t2[e2++] << 8, e2++;
            else for (e2 += 12; ; ) {
              if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
              if (0 === P2) break;
              e2 += P2;
            }
            break;
          case 249:
            if (4 !== t2[e2++] || 0 !== t2[e2 + 4]) throw new Error("Invalid graphics extension block.");
            var g2 = t2[e2++];
            h2 = t2[e2++] | t2[e2++] << 8, f2 = t2[e2++], 1 & g2 || (f2 = null), d2 = g2 >> 2 & 7, e2++;
            break;
          case 254:
            for (; ; ) {
              if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
              if (0 === P2) break;
              e2 += P2;
            }
            break;
          default:
            throw new Error("Unknown graphic control label: 0x" + t2[e2 - 1].toString(16));
        }
        break;
      case 44:
        var m2 = t2[e2++] | t2[e2++] << 8, v2 = t2[e2++] | t2[e2++] << 8, b2 = t2[e2++] | t2[e2++] << 8, y2 = t2[e2++] | t2[e2++] << 8, w2 = t2[e2++], N2 = w2 >> 6 & 1, L2 = 1 << 1 + (7 & w2), x2 = s2, A2 = u2, S2 = false;
        w2 >> 7 && (S2 = true, x2 = e2, A2 = L2, e2 += 3 * L2);
        var _2 = e2;
        for (e2++; ; ) {
          var P2;
          if (!((P2 = t2[e2++]) >= 0)) throw Error("Invalid block size");
          if (0 === P2) break;
          e2 += P2;
        }
        l2.push({ x: m2, y: v2, width: b2, height: y2, has_local_palette: S2, palette_offset: x2, palette_size: A2, data_offset: _2, data_length: e2 - _2, transparent_index: f2, interlaced: !!N2, delay: h2, disposal: d2 });
        break;
      case 59:
        c2 = false;
        break;
      default:
        throw new Error("Unknown gif block: 0x" + t2[e2 - 1].toString(16));
    }
    this.numFrames = function() {
      return l2.length;
    }, this.loopCount = function() {
      return p2;
    }, this.frameInfo = function(t3) {
      if (t3 < 0 || t3 >= l2.length) throw new Error("Frame index out of range.");
      return l2[t3];
    }, this.decodeAndBlitFrameBGRA = function(e3, r3) {
      var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
      se(t2, i3.data_offset, o3, a3);
      var s3 = i3.palette_offset, u3 = i3.transparent_index;
      null === u3 && (u3 = 256);
      var c3 = i3.width, l3 = n2 - c3, h3 = c3, f3 = 4 * (i3.y * n2 + i3.x), d3 = 4 * ((i3.y + i3.height) * n2 + i3.x), p3 = f3, g3 = 4 * l3;
      true === i3.interlaced && (g3 += 4 * n2 * 7);
      for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
        var y3 = o3[v3];
        if (0 === h3 && (h3 = c3, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * n2 * (m3 - 1), p3 = f3 + (c3 + l3) * (m3 << 1), m3 >>= 1)), y3 === u3) p3 += 4;
        else {
          var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
          r3[p3++] = L3, r3[p3++] = N3, r3[p3++] = w3, r3[p3++] = 255;
        }
        --h3;
      }
    }, this.decodeAndBlitFrameRGBA = function(e3, r3) {
      var i3 = this.frameInfo(e3), a3 = i3.width * i3.height, o3 = new Uint8Array(a3);
      se(t2, i3.data_offset, o3, a3);
      var s3 = i3.palette_offset, u3 = i3.transparent_index;
      null === u3 && (u3 = 256);
      var c3 = i3.width, l3 = n2 - c3, h3 = c3, f3 = 4 * (i3.y * n2 + i3.x), d3 = 4 * ((i3.y + i3.height) * n2 + i3.x), p3 = f3, g3 = 4 * l3;
      true === i3.interlaced && (g3 += 4 * n2 * 7);
      for (var m3 = 8, v3 = 0, b3 = o3.length; v3 < b3; ++v3) {
        var y3 = o3[v3];
        if (0 === h3 && (h3 = c3, (p3 += g3) >= d3 && (g3 = 4 * l3 + 4 * n2 * (m3 - 1), p3 = f3 + (c3 + l3) * (m3 << 1), m3 >>= 1)), y3 === u3) p3 += 4;
        else {
          var w3 = t2[s3 + 3 * y3], N3 = t2[s3 + 3 * y3 + 1], L3 = t2[s3 + 3 * y3 + 2];
          r3[p3++] = w3, r3[p3++] = N3, r3[p3++] = L3, r3[p3++] = 255;
        }
        --h3;
      }
    };
  }
  function se(t2, e2, n2, r2) {
    for (var i2 = t2[e2++], a2 = 1 << i2, s2 = a2 + 1, u2 = s2 + 1, c2 = i2 + 1, l2 = (1 << c2) - 1, h2 = 0, f2 = 0, d2 = 0, p2 = t2[e2++], g2 = new Int32Array(4096), m2 = null; ; ) {
      for (; h2 < 16 && 0 !== p2; ) f2 |= t2[e2++] << h2, h2 += 8, 1 === p2 ? p2 = t2[e2++] : --p2;
      if (h2 < c2) break;
      var v2 = f2 & l2;
      if (f2 >>= c2, h2 -= c2, v2 !== a2) {
        if (v2 === s2) break;
        for (var b2 = v2 < u2 ? v2 : m2, y2 = 0, w2 = b2; w2 > a2; ) w2 = g2[w2] >> 8, ++y2;
        var N2 = w2;
        if (d2 + y2 + (b2 !== v2 ? 1 : 0) > r2) return void o$1.log("Warning, gif stream longer than expected.");
        n2[d2++] = N2;
        var L2 = d2 += y2;
        for (b2 !== v2 && (n2[d2++] = N2), w2 = b2; y2--; ) w2 = g2[w2], n2[--L2] = 255 & w2, w2 >>= 8;
        null !== m2 && u2 < 4096 && (g2[u2++] = m2 << 8 | N2, u2 >= l2 + 1 && c2 < 12 && (++c2, l2 = l2 << 1 | 1)), m2 = v2;
      } else u2 = s2 + 1, l2 = (1 << (c2 = i2 + 1)) - 1, m2 = null;
    }
    return d2 !== r2 && o$1.log("Warning, gif stream shorter than expected."), n2;
  }
  /**
     * @license
      Copyright (c) 2008, Adobe Systems Incorporated
      All rights reserved.
  
      Redistribution and use in source and binary forms, with or without 
      modification, are permitted provided that the following conditions are
      met:
  
      * Redistributions of source code must retain the above copyright notice, 
        this list of conditions and the following disclaimer.
      
      * Redistributions in binary form must reproduce the above copyright
        notice, this list of conditions and the following disclaimer in the 
        documentation and/or other materials provided with the distribution.
      
      * Neither the name of Adobe Systems Incorporated nor the names of its 
        contributors may be used to endorse or promote products derived from 
        this software without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
      IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
      PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
      CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
      EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
      PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
      PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
      LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
      NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
      SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
  function ue(t2) {
    var e2, n2, r2, i2, a2, o2 = Math.floor, s2 = new Array(64), u2 = new Array(64), c2 = new Array(64), l2 = new Array(64), h2 = new Array(65535), f2 = new Array(65535), d2 = new Array(64), p2 = new Array(64), g2 = [], m2 = 0, v2 = 7, b2 = new Array(64), y2 = new Array(64), w2 = new Array(64), N2 = new Array(256), L2 = new Array(2048), x2 = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], A2 = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], S2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], _2 = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], P2 = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], k2 = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], F2 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], I2 = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], j2 = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
    function C2(t3, e3) {
      for (var n3 = 0, r3 = 0, i3 = new Array(), a3 = 1; a3 <= 16; a3++) {
        for (var o3 = 1; o3 <= t3[a3]; o3++) i3[e3[r3]] = [], i3[e3[r3]][0] = n3, i3[e3[r3]][1] = a3, r3++, n3++;
        n3 *= 2;
      }
      return i3;
    }
    function O2(t3) {
      for (var e3 = t3[0], n3 = t3[1] - 1; n3 >= 0; ) e3 & 1 << n3 && (m2 |= 1 << v2), n3--, --v2 < 0 && (255 == m2 ? (B3(255), B3(0)) : B3(m2), v2 = 7, m2 = 0);
    }
    function B3(t3) {
      g2.push(t3);
    }
    function M2(t3) {
      B3(t3 >> 8 & 255), B3(255 & t3);
    }
    function q2(t3, e3, n3, r3, i3) {
      for (var a3, o3 = i3[0], s3 = i3[240], u3 = (function(t4, e4) {
        var n4, r4, i4, a4, o4, s4, u4, c4, l4, h3, f3 = 0;
        for (l4 = 0; l4 < 8; ++l4) {
          n4 = t4[f3], r4 = t4[f3 + 1], i4 = t4[f3 + 2], a4 = t4[f3 + 3], o4 = t4[f3 + 4], s4 = t4[f3 + 5], u4 = t4[f3 + 6];
          var p3 = n4 + (c4 = t4[f3 + 7]), g4 = n4 - c4, m4 = r4 + u4, v4 = r4 - u4, b4 = i4 + s4, y4 = i4 - s4, w4 = a4 + o4, N3 = a4 - o4, L3 = p3 + w4, x3 = p3 - w4, A3 = m4 + b4, S3 = m4 - b4;
          t4[f3] = L3 + A3, t4[f3 + 4] = L3 - A3;
          var _3 = 0.707106781 * (S3 + x3);
          t4[f3 + 2] = x3 + _3, t4[f3 + 6] = x3 - _3;
          var P3 = 0.382683433 * ((L3 = N3 + y4) - (S3 = v4 + g4)), k3 = 0.5411961 * L3 + P3, F3 = 1.306562965 * S3 + P3, I3 = 0.707106781 * (A3 = y4 + v4), j3 = g4 + I3, C3 = g4 - I3;
          t4[f3 + 5] = C3 + k3, t4[f3 + 3] = C3 - k3, t4[f3 + 1] = j3 + F3, t4[f3 + 7] = j3 - F3, f3 += 8;
        }
        for (f3 = 0, l4 = 0; l4 < 8; ++l4) {
          n4 = t4[f3], r4 = t4[f3 + 8], i4 = t4[f3 + 16], a4 = t4[f3 + 24], o4 = t4[f3 + 32], s4 = t4[f3 + 40], u4 = t4[f3 + 48];
          var O3 = n4 + (c4 = t4[f3 + 56]), B4 = n4 - c4, M3 = r4 + u4, q3 = r4 - u4, E3 = i4 + s4, R2 = i4 - s4, D2 = a4 + o4, T2 = a4 - o4, z2 = O3 + D2, U2 = O3 - D2, H4 = M3 + E3, W2 = M3 - E3;
          t4[f3] = z2 + H4, t4[f3 + 32] = z2 - H4;
          var V2 = 0.707106781 * (W2 + U2);
          t4[f3 + 16] = U2 + V2, t4[f3 + 48] = U2 - V2;
          var G2 = 0.382683433 * ((z2 = T2 + R2) - (W2 = q3 + B4)), Y2 = 0.5411961 * z2 + G2, J2 = 1.306562965 * W2 + G2, X2 = 0.707106781 * (H4 = R2 + q3), K2 = B4 + X2, Z2 = B4 - X2;
          t4[f3 + 40] = Z2 + Y2, t4[f3 + 24] = Z2 - Y2, t4[f3 + 8] = K2 + J2, t4[f3 + 56] = K2 - J2, f3++;
        }
        for (l4 = 0; l4 < 64; ++l4) h3 = t4[l4] * e4[l4], d2[l4] = h3 > 0 ? h3 + 0.5 | 0 : h3 - 0.5 | 0;
        return d2;
      })(t3, e3), c3 = 0; c3 < 64; ++c3) p2[x2[c3]] = u3[c3];
      var l3 = p2[0] - n3;
      n3 = p2[0], 0 == l3 ? O2(r3[0]) : (O2(r3[f2[a3 = 32767 + l3]]), O2(h2[a3]));
      for (var g3 = 63; g3 > 0 && 0 == p2[g3]; ) g3--;
      if (0 == g3) return O2(o3), n3;
      for (var m3, v3 = 1; v3 <= g3; ) {
        for (var b3 = v3; 0 == p2[v3] && v3 <= g3; ) ++v3;
        var y3 = v3 - b3;
        if (y3 >= 16) {
          m3 = y3 >> 4;
          for (var w3 = 1; w3 <= m3; ++w3) O2(s3);
          y3 &= 15;
        }
        a3 = 32767 + p2[v3], O2(i3[(y3 << 4) + f2[a3]]), O2(h2[a3]), v3++;
      }
      return 63 != g3 && O2(o3), n3;
    }
    function E2(t3) {
      t3 = Math.min(Math.max(t3, 1), 100), a2 != t3 && ((function(t4) {
        for (var e3 = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], n3 = 0; n3 < 64; n3++) {
          var r3 = o2((e3[n3] * t4 + 50) / 100);
          r3 = Math.min(Math.max(r3, 1), 255), s2[x2[n3]] = r3;
        }
        for (var i3 = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], a3 = 0; a3 < 64; a3++) {
          var h3 = o2((i3[a3] * t4 + 50) / 100);
          h3 = Math.min(Math.max(h3, 1), 255), u2[x2[a3]] = h3;
        }
        for (var f3 = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], d3 = 0, p3 = 0; p3 < 8; p3++) for (var g3 = 0; g3 < 8; g3++) c2[d3] = 1 / (s2[x2[d3]] * f3[p3] * f3[g3] * 8), l2[d3] = 1 / (u2[x2[d3]] * f3[p3] * f3[g3] * 8), d3++;
      })(t3 < 50 ? Math.floor(5e3 / t3) : Math.floor(200 - 2 * t3)), a2 = t3);
    }
    this.encode = function(t3, a3) {
      a3 && E2(a3), g2 = new Array(), m2 = 0, v2 = 7, M2(65496), M2(65504), M2(16), B3(74), B3(70), B3(73), B3(70), B3(0), B3(1), B3(1), B3(0), M2(1), M2(1), B3(0), B3(0), (function() {
        M2(65499), M2(132), B3(0);
        for (var t4 = 0; t4 < 64; t4++) B3(s2[t4]);
        B3(1);
        for (var e3 = 0; e3 < 64; e3++) B3(u2[e3]);
      })(), (function(t4, e3) {
        M2(65472), M2(17), B3(8), M2(e3), M2(t4), B3(3), B3(1), B3(17), B3(0), B3(2), B3(17), B3(1), B3(3), B3(17), B3(1);
      })(t3.width, t3.height), (function() {
        M2(65476), M2(418), B3(0);
        for (var t4 = 0; t4 < 16; t4++) B3(A2[t4 + 1]);
        for (var e3 = 0; e3 <= 11; e3++) B3(S2[e3]);
        B3(16);
        for (var n3 = 0; n3 < 16; n3++) B3(_2[n3 + 1]);
        for (var r3 = 0; r3 <= 161; r3++) B3(P2[r3]);
        B3(1);
        for (var i3 = 0; i3 < 16; i3++) B3(k2[i3 + 1]);
        for (var a4 = 0; a4 <= 11; a4++) B3(F2[a4]);
        B3(17);
        for (var o4 = 0; o4 < 16; o4++) B3(I2[o4 + 1]);
        for (var s3 = 0; s3 <= 161; s3++) B3(j2[s3]);
      })(), M2(65498), M2(12), B3(3), B3(1), B3(0), B3(2), B3(17), B3(3), B3(17), B3(0), B3(63), B3(0);
      var o3 = 0, h3 = 0, f3 = 0;
      m2 = 0, v2 = 7, this.encode.displayName = "_encode_";
      for (var d3, p3, N3, x3, C3, R2, D2, T2, z2, U2 = t3.data, H4 = t3.width, W2 = t3.height, V2 = 4 * H4, G2 = 0; G2 < W2; ) {
        for (d3 = 0; d3 < V2; ) {
          for (C3 = V2 * G2 + d3, D2 = -1, T2 = 0, z2 = 0; z2 < 64; z2++) R2 = C3 + (T2 = z2 >> 3) * V2 + (D2 = 4 * (7 & z2)), G2 + T2 >= W2 && (R2 -= V2 * (G2 + 1 + T2 - W2)), d3 + D2 >= V2 && (R2 -= d3 + D2 - V2 + 4), p3 = U2[R2++], N3 = U2[R2++], x3 = U2[R2++], b2[z2] = (L2[p3] + L2[N3 + 256 | 0] + L2[x3 + 512 | 0] >> 16) - 128, y2[z2] = (L2[p3 + 768 | 0] + L2[N3 + 1024 | 0] + L2[x3 + 1280 | 0] >> 16) - 128, w2[z2] = (L2[p3 + 1280 | 0] + L2[N3 + 1536 | 0] + L2[x3 + 1792 | 0] >> 16) - 128;
          o3 = q2(b2, c2, o3, e2, r2), h3 = q2(y2, l2, h3, n2, i2), f3 = q2(w2, l2, f3, n2, i2), d3 += 32;
        }
        G2 += 8;
      }
      if (v2 >= 0) {
        var Y2 = [];
        Y2[1] = v2 + 1, Y2[0] = (1 << v2 + 1) - 1, O2(Y2);
      }
      return M2(65497), new Uint8Array(g2);
    }, t2 = t2 || 50, (function() {
      for (var t3 = String.fromCharCode, e3 = 0; e3 < 256; e3++) N2[e3] = t3(e3);
    })(), e2 = C2(A2, S2), n2 = C2(k2, F2), r2 = C2(_2, P2), i2 = C2(I2, j2), (function() {
      for (var t3 = 1, e3 = 2, n3 = 1; n3 <= 15; n3++) {
        for (var r3 = t3; r3 < e3; r3++) f2[32767 + r3] = n3, h2[32767 + r3] = [], h2[32767 + r3][1] = n3, h2[32767 + r3][0] = r3;
        for (var i3 = -(e3 - 1); i3 <= -t3; i3++) f2[32767 + i3] = n3, h2[32767 + i3] = [], h2[32767 + i3][1] = n3, h2[32767 + i3][0] = e3 - 1 + i3;
        t3 <<= 1, e3 <<= 1;
      }
    })(), (function() {
      for (var t3 = 0; t3 < 256; t3++) L2[t3] = 19595 * t3, L2[t3 + 256 | 0] = 38470 * t3, L2[t3 + 512 | 0] = 7471 * t3 + 32768, L2[t3 + 768 | 0] = -11059 * t3, L2[t3 + 1024 | 0] = -21709 * t3, L2[t3 + 1280 | 0] = 32768 * t3 + 8421375, L2[t3 + 1536 | 0] = -27439 * t3, L2[t3 + 1792 | 0] = -5329 * t3;
    })(), E2(t2);
  }
  /**
   * @license
   * Copyright (c) 2017 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  function ce(t2, e2) {
    if (this.pos = 0, this.buffer = t2, this.datav = new DataView(t2.buffer), this.is_with_alpha = !!e2, this.bottom_up = true, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, -1 === ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag)) throw new Error("Invalid BMP File");
    this.parseHeader(), this.parseBGR();
  }
  function le(t2) {
    function e2(t3) {
      if (!t3) throw Error("assert :P");
    }
    function n2(t3, e3, n3) {
      for (var r3 = 0; 4 > r3; r3++) if (t3[e3 + r3] != n3.charCodeAt(r3)) return true;
      return false;
    }
    function r2(t3, e3, n3, r3, i3) {
      for (var a3 = 0; a3 < i3; a3++) t3[e3 + a3] = n3[r3 + a3];
    }
    function i2(t3, e3, n3, r3) {
      for (var i3 = 0; i3 < r3; i3++) t3[e3 + i3] = n3;
    }
    function a2(t3) {
      return new Int32Array(t3);
    }
    function o2(t3, e3) {
      for (var n3 = [], r3 = 0; r3 < t3; r3++) n3.push(new e3());
      return n3;
    }
    function s2(t3, e3) {
      var n3 = [];
      return (function t4(n4, r3, i3) {
        for (var a3 = i3[r3], o3 = 0; o3 < a3 && (n4.push(i3.length > r3 + 1 ? [] : new e3()), !(i3.length < r3 + 1)); o3++) t4(n4[o3], r3 + 1, i3);
      })(n3, 0, t3), n3;
    }
    var u2 = function() {
      var t3 = this;
      function u3(t4, e3) {
        for (var n3 = 1 << e3 - 1 >>> 0; t4 & n3; ) n3 >>>= 1;
        return n3 ? (t4 & n3 - 1) + n3 : t4;
      }
      function c3(t4, n3, r3, i3, a3) {
        e2(!(i3 % r3));
        do {
          t4[n3 + (i3 -= r3)] = a3;
        } while (0 < i3);
      }
      function l3(t4, n3, r3, i3, o3) {
        if (e2(2328 >= o3), 512 >= o3) var s3 = a2(512);
        else if (null == (s3 = a2(o3))) return 0;
        return (function(t5, n4, r4, i4, o4, s4) {
          var l4, f4, d4 = n4, p4 = 1 << r4, g4 = a2(16), m4 = a2(16);
          for (e2(0 != o4), e2(null != i4), e2(null != t5), e2(0 < r4), f4 = 0; f4 < o4; ++f4) {
            if (15 < i4[f4]) return 0;
            ++g4[i4[f4]];
          }
          if (g4[0] == o4) return 0;
          for (m4[1] = 0, l4 = 1; 15 > l4; ++l4) {
            if (g4[l4] > 1 << l4) return 0;
            m4[l4 + 1] = m4[l4] + g4[l4];
          }
          for (f4 = 0; f4 < o4; ++f4) l4 = i4[f4], 0 < i4[f4] && (s4[m4[l4]++] = f4);
          if (1 == m4[15]) return (i4 = new h3()).g = 0, i4.value = s4[0], c3(t5, d4, 1, p4, i4), p4;
          var v4, b4 = -1, y4 = p4 - 1, w4 = 0, N4 = 1, L4 = 1, x4 = 1 << r4;
          for (f4 = 0, l4 = 1, o4 = 2; l4 <= r4; ++l4, o4 <<= 1) {
            if (N4 += L4 <<= 1, 0 > (L4 -= g4[l4])) return 0;
            for (; 0 < g4[l4]; --g4[l4]) (i4 = new h3()).g = l4, i4.value = s4[f4++], c3(t5, d4 + w4, o4, x4, i4), w4 = u3(w4, l4);
          }
          for (l4 = r4 + 1, o4 = 2; 15 >= l4; ++l4, o4 <<= 1) {
            if (N4 += L4 <<= 1, 0 > (L4 -= g4[l4])) return 0;
            for (; 0 < g4[l4]; --g4[l4]) {
              if (i4 = new h3(), (w4 & y4) != b4) {
                for (d4 += x4, v4 = 1 << (b4 = l4) - r4; 15 > b4 && !(0 >= (v4 -= g4[b4])); ) ++b4, v4 <<= 1;
                p4 += x4 = 1 << (v4 = b4 - r4), t5[n4 + (b4 = w4 & y4)].g = v4 + r4, t5[n4 + b4].value = d4 - n4 - b4;
              }
              i4.g = l4 - r4, i4.value = s4[f4++], c3(t5, d4 + (w4 >> r4), o4, x4, i4), w4 = u3(w4, l4);
            }
          }
          return N4 != 2 * m4[15] - 1 ? 0 : p4;
        })(t4, n3, r3, i3, o3, s3);
      }
      function h3() {
        this.value = this.g = 0;
      }
      function f3() {
        this.value = this.g = 0;
      }
      function d3() {
        this.G = o2(5, h3), this.H = a2(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = o2(Rn, f3);
      }
      function p3(t4, n3, r3, i3) {
        e2(null != t4), e2(null != n3), e2(2147483648 > i3), t4.Ca = 254, t4.I = 0, t4.b = -8, t4.Ka = 0, t4.oa = n3, t4.pa = r3, t4.Jd = n3, t4.Yc = r3 + i3, t4.Zc = 4 <= i3 ? r3 + i3 - 4 + 1 : r3, _2(t4);
      }
      function g3(t4, e3) {
        for (var n3 = 0; 0 < e3--; ) n3 |= k2(t4, 128) << e3;
        return n3;
      }
      function m3(t4, e3) {
        var n3 = g3(t4, e3);
        return P2(t4) ? -n3 : n3;
      }
      function v3(t4, n3, r3, i3) {
        var a3, o3 = 0;
        for (e2(null != t4), e2(null != n3), e2(4294967288 > i3), t4.Sb = i3, t4.Ra = 0, t4.u = 0, t4.h = 0, 4 < i3 && (i3 = 4), a3 = 0; a3 < i3; ++a3) o3 += n3[r3 + a3] << 8 * a3;
        t4.Ra = o3, t4.bb = i3, t4.oa = n3, t4.pa = r3;
      }
      function b3(t4) {
        for (; 8 <= t4.u && t4.bb < t4.Sb; ) t4.Ra >>>= 8, t4.Ra += t4.oa[t4.pa + t4.bb] << zn - 8 >>> 0, ++t4.bb, t4.u -= 8;
        x3(t4) && (t4.h = 1, t4.u = 0);
      }
      function y3(t4, n3) {
        if (e2(0 <= n3), !t4.h && n3 <= Tn) {
          var r3 = L3(t4) & Dn[n3];
          return t4.u += n3, b3(t4), r3;
        }
        return t4.h = 1, t4.u = 0;
      }
      function w3() {
        this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0;
      }
      function N3() {
        this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0;
      }
      function L3(t4) {
        return t4.Ra >>> (t4.u & zn - 1) >>> 0;
      }
      function x3(t4) {
        return e2(t4.bb <= t4.Sb), t4.h || t4.bb == t4.Sb && t4.u > zn;
      }
      function A3(t4, e3) {
        t4.u = e3, t4.h = x3(t4);
      }
      function S2(t4) {
        t4.u >= Un && (e2(t4.u >= Un), b3(t4));
      }
      function _2(t4) {
        e2(null != t4 && null != t4.oa), t4.pa < t4.Zc ? (t4.I = (t4.oa[t4.pa++] | t4.I << 8) >>> 0, t4.b += 8) : (e2(null != t4 && null != t4.oa), t4.pa < t4.Yc ? (t4.b += 8, t4.I = t4.oa[t4.pa++] | t4.I << 8) : t4.Ka ? t4.b = 0 : (t4.I <<= 8, t4.b += 8, t4.Ka = 1));
      }
      function P2(t4) {
        return g3(t4, 1);
      }
      function k2(t4, e3) {
        var n3 = t4.Ca;
        0 > t4.b && _2(t4);
        var r3 = t4.b, i3 = n3 * e3 >>> 8, a3 = (t4.I >>> r3 > i3) + 0;
        for (a3 ? (n3 -= i3, t4.I -= i3 + 1 << r3 >>> 0) : n3 = i3 + 1, r3 = n3, i3 = 0; 256 <= r3; ) i3 += 8, r3 >>= 8;
        return r3 = 7 ^ i3 + Hn[r3], t4.b -= r3, t4.Ca = (n3 << r3) - 1, a3;
      }
      function F2(t4, e3, n3) {
        t4[e3 + 0] = n3 >> 24 & 255, t4[e3 + 1] = n3 >> 16 & 255, t4[e3 + 2] = n3 >> 8 & 255, t4[e3 + 3] = 255 & n3;
      }
      function I2(t4, e3) {
        return t4[e3 + 0] | t4[e3 + 1] << 8;
      }
      function j2(t4, e3) {
        return I2(t4, e3) | t4[e3 + 2] << 16;
      }
      function C2(t4, e3) {
        return I2(t4, e3) | I2(t4, e3 + 2) << 16;
      }
      function O2(t4, n3) {
        var r3 = 1 << n3;
        return e2(null != t4), e2(0 < n3), t4.X = a2(r3), null == t4.X ? 0 : (t4.Mb = 32 - n3, t4.Xa = n3, 1);
      }
      function B3(t4, n3) {
        e2(null != t4), e2(null != n3), e2(t4.Xa == n3.Xa), r2(n3.X, 0, t4.X, 0, 1 << n3.Xa);
      }
      function M2() {
        this.X = [], this.Xa = this.Mb = 0;
      }
      function q2(t4, n3, r3, i3) {
        e2(null != r3), e2(null != i3);
        var a3 = r3[0], o3 = i3[0];
        return 0 == a3 && (a3 = (t4 * o3 + n3 / 2) / n3), 0 == o3 && (o3 = (n3 * a3 + t4 / 2) / t4), 0 >= a3 || 0 >= o3 ? 0 : (r3[0] = a3, i3[0] = o3, 1);
      }
      function E2(t4, e3) {
        return t4 + (1 << e3) - 1 >>> e3;
      }
      function R2(t4, e3) {
        return ((4278255360 & t4) + (4278255360 & e3) >>> 0 & 4278255360) + ((16711935 & t4) + (16711935 & e3) >>> 0 & 16711935) >>> 0;
      }
      function D2(e3, n3) {
        t3[n3] = function(n4, r3, i3, a3, o3, s3, u4) {
          var c4;
          for (c4 = 0; c4 < o3; ++c4) {
            var l4 = t3[e3](s3[u4 + c4 - 1], i3, a3 + c4);
            s3[u4 + c4] = R2(n4[r3 + c4], l4);
          }
        };
      }
      function T2() {
        this.ud = this.hd = this.jd = 0;
      }
      function z2(t4, e3) {
        return ((4278124286 & (t4 ^ e3)) >>> 1) + (t4 & e3) >>> 0;
      }
      function U2(t4) {
        return 0 <= t4 && 256 > t4 ? t4 : 0 > t4 ? 0 : 255 < t4 ? 255 : void 0;
      }
      function H4(t4, e3) {
        return U2(t4 + (t4 - e3 + 0.5 >> 1));
      }
      function W2(t4, e3, n3) {
        return Math.abs(e3 - n3) - Math.abs(t4 - n3);
      }
      function V2(t4, e3, n3, r3, i3, a3, o3) {
        for (r3 = a3[o3 - 1], n3 = 0; n3 < i3; ++n3) a3[o3 + n3] = r3 = R2(t4[e3 + n3], r3);
      }
      function G2(t4, e3, n3, r3, i3) {
        var a3;
        for (a3 = 0; a3 < n3; ++a3) {
          var o3 = t4[e3 + a3], s3 = o3 >> 8 & 255, u4 = 16711935 & (u4 = (u4 = 16711935 & o3) + ((s3 << 16) + s3));
          r3[i3 + a3] = (4278255360 & o3) + u4 >>> 0;
        }
      }
      function Y2(t4, e3) {
        e3.jd = 255 & t4, e3.hd = t4 >> 8 & 255, e3.ud = t4 >> 16 & 255;
      }
      function J2(t4, e3, n3, r3, i3, a3) {
        var o3;
        for (o3 = 0; o3 < r3; ++o3) {
          var s3 = e3[n3 + o3], u4 = s3 >>> 8, c4 = s3, l4 = 255 & (l4 = (l4 = s3 >>> 16) + ((t4.jd << 24 >> 24) * (u4 << 24 >> 24) >>> 5));
          c4 = 255 & (c4 = (c4 += (t4.hd << 24 >> 24) * (u4 << 24 >> 24) >>> 5) + ((t4.ud << 24 >> 24) * (l4 << 24 >> 24) >>> 5)), i3[a3 + o3] = (4278255360 & s3) + (l4 << 16) + c4;
        }
      }
      function X2(e3, n3, r3, i3, a3) {
        t3[n3] = function(t4, e4, n4, r4, o3, s3, u4, c4, l4) {
          for (r4 = u4; r4 < c4; ++r4) for (u4 = 0; u4 < l4; ++u4) o3[s3++] = a3(n4[i3(t4[e4++])]);
        }, t3[e3] = function(e4, n4, o3, s3, u4, c4, l4) {
          var h4 = 8 >> e4.b, f4 = e4.Ea, d4 = e4.K[0], p4 = e4.w;
          if (8 > h4) for (e4 = (1 << e4.b) - 1, p4 = (1 << h4) - 1; n4 < o3; ++n4) {
            var g4, m4 = 0;
            for (g4 = 0; g4 < f4; ++g4) g4 & e4 || (m4 = i3(s3[u4++])), c4[l4++] = a3(d4[m4 & p4]), m4 >>= h4;
          }
          else t3["VP8LMapColor" + r3](s3, u4, d4, p4, c4, l4, n4, o3, f4);
        };
      }
      function K2(t4, e3, n3, r3, i3) {
        for (n3 = e3 + n3; e3 < n3; ) {
          var a3 = t4[e3++];
          r3[i3++] = a3 >> 16 & 255, r3[i3++] = a3 >> 8 & 255, r3[i3++] = 255 & a3;
        }
      }
      function Z2(t4, e3, n3, r3, i3) {
        for (n3 = e3 + n3; e3 < n3; ) {
          var a3 = t4[e3++];
          r3[i3++] = a3 >> 16 & 255, r3[i3++] = a3 >> 8 & 255, r3[i3++] = 255 & a3, r3[i3++] = a3 >> 24 & 255;
        }
      }
      function $2(t4, e3, n3, r3, i3) {
        for (n3 = e3 + n3; e3 < n3; ) {
          var a3 = (o3 = t4[e3++]) >> 16 & 240 | o3 >> 12 & 15, o3 = 240 & o3 | o3 >> 28 & 15;
          r3[i3++] = a3, r3[i3++] = o3;
        }
      }
      function Q2(t4, e3, n3, r3, i3) {
        for (n3 = e3 + n3; e3 < n3; ) {
          var a3 = (o3 = t4[e3++]) >> 16 & 248 | o3 >> 13 & 7, o3 = o3 >> 5 & 224 | o3 >> 3 & 31;
          r3[i3++] = a3, r3[i3++] = o3;
        }
      }
      function tt2(t4, e3, n3, r3, i3) {
        for (n3 = e3 + n3; e3 < n3; ) {
          var a3 = t4[e3++];
          r3[i3++] = 255 & a3, r3[i3++] = a3 >> 8 & 255, r3[i3++] = a3 >> 16 & 255;
        }
      }
      function et2(t4, e3, n3, i3, a3, o3) {
        if (0 == o3) for (n3 = e3 + n3; e3 < n3; ) F2(i3, ((o3 = t4[e3++])[0] >> 24 | o3[1] >> 8 & 65280 | o3[2] << 8 & 16711680 | o3[3] << 24) >>> 0), a3 += 32;
        else r2(i3, a3, t4, e3, n3);
      }
      function nt2(e3, n3) {
        t3[n3][0] = t3[e3 + "0"], t3[n3][1] = t3[e3 + "1"], t3[n3][2] = t3[e3 + "2"], t3[n3][3] = t3[e3 + "3"], t3[n3][4] = t3[e3 + "4"], t3[n3][5] = t3[e3 + "5"], t3[n3][6] = t3[e3 + "6"], t3[n3][7] = t3[e3 + "7"], t3[n3][8] = t3[e3 + "8"], t3[n3][9] = t3[e3 + "9"], t3[n3][10] = t3[e3 + "10"], t3[n3][11] = t3[e3 + "11"], t3[n3][12] = t3[e3 + "12"], t3[n3][13] = t3[e3 + "13"], t3[n3][14] = t3[e3 + "0"], t3[n3][15] = t3[e3 + "0"];
      }
      function rt2(t4) {
        return t4 == Ur || t4 == Hr || t4 == Wr || t4 == Vr;
      }
      function it2() {
        this.eb = [], this.size = this.A = this.fb = 0;
      }
      function at2() {
        this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0;
      }
      function ot2() {
        this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new it2(), this.f.kb = new at2(), this.sd = null;
      }
      function st2() {
        this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0];
      }
      function ut2() {
        this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0;
      }
      function ct2(t4) {
        return alert("todo:WebPSamplerProcessPlane"), t4.T;
      }
      function lt2(t4, e3) {
        var n3 = t4.T, i3 = e3.ba.f.RGBA, a3 = i3.eb, o3 = i3.fb + t4.ka * i3.A, s3 = mi[e3.ba.S], u4 = t4.y, c4 = t4.O, l4 = t4.f, h4 = t4.N, f4 = t4.ea, d4 = t4.W, p4 = e3.cc, g4 = e3.dc, m4 = e3.Mc, v4 = e3.Nc, b4 = t4.ka, y4 = t4.ka + t4.T, w4 = t4.U, N4 = w4 + 1 >> 1;
        for (0 == b4 ? s3(u4, c4, null, null, l4, h4, f4, d4, l4, h4, f4, d4, a3, o3, null, null, w4) : (s3(e3.ec, e3.fc, u4, c4, p4, g4, m4, v4, l4, h4, f4, d4, a3, o3 - i3.A, a3, o3, w4), ++n3); b4 + 2 < y4; b4 += 2) p4 = l4, g4 = h4, m4 = f4, v4 = d4, h4 += t4.Rc, d4 += t4.Rc, o3 += 2 * i3.A, s3(u4, (c4 += 2 * t4.fa) - t4.fa, u4, c4, p4, g4, m4, v4, l4, h4, f4, d4, a3, o3 - i3.A, a3, o3, w4);
        return c4 += t4.fa, t4.j + y4 < t4.o ? (r2(e3.ec, e3.fc, u4, c4, w4), r2(e3.cc, e3.dc, l4, h4, N4), r2(e3.Mc, e3.Nc, f4, d4, N4), n3--) : 1 & y4 || s3(u4, c4, null, null, l4, h4, f4, d4, l4, h4, f4, d4, a3, o3 + i3.A, null, null, w4), n3;
      }
      function ht2(t4, n3, r3) {
        var i3 = t4.F, a3 = [t4.J];
        if (null != i3) {
          var o3 = t4.U, s3 = n3.ba.S, u4 = s3 == Dr || s3 == Wr;
          n3 = n3.ba.f.RGBA;
          var c4 = [0], l4 = t4.ka;
          c4[0] = t4.T, t4.Kb && (0 == l4 ? --c4[0] : (--l4, a3[0] -= t4.width), t4.j + t4.ka + t4.T == t4.o && (c4[0] = t4.o - t4.j - l4));
          var h4 = n3.eb;
          l4 = n3.fb + l4 * n3.A, t4 = Ar(i3, a3[0], t4.width, o3, c4, h4, l4 + (u4 ? 0 : 3), n3.A), e2(r3 == c4), t4 && rt2(s3) && Lr(h4, l4, u4, o3, c4, n3.A);
        }
        return 0;
      }
      function ft2(t4) {
        var e3 = t4.ma, n3 = e3.ba.S, r3 = 11 > n3, i3 = n3 == qr || n3 == Rr || n3 == Dr || n3 == Tr || 12 == n3 || rt2(n3);
        if (e3.memory = null, e3.Ib = null, e3.Jb = null, e3.Nd = null, !Mn(e3.Oa, t4, i3 ? 11 : 12)) return 0;
        if (i3 && rt2(n3) && bn(), t4.da) alert("todo:use_scaling");
        else {
          if (r3) {
            if (e3.Ib = ct2, t4.Kb) {
              if (n3 = t4.U + 1 >> 1, e3.memory = a2(t4.U + 2 * n3), null == e3.memory) return 0;
              e3.ec = e3.memory, e3.fc = 0, e3.cc = e3.ec, e3.dc = e3.fc + t4.U, e3.Mc = e3.cc, e3.Nc = e3.dc + n3, e3.Ib = lt2, bn();
            }
          } else alert("todo:EmitYUV");
          i3 && (e3.Jb = ht2, r3 && mn());
        }
        if (r3 && !Ii) {
          for (t4 = 0; 256 > t4; ++t4) ji[t4] = 89858 * (t4 - 128) + Si >> Ai, Bi[t4] = -22014 * (t4 - 128) + Si, Oi[t4] = -45773 * (t4 - 128), Ci[t4] = 113618 * (t4 - 128) + Si >> Ai;
          for (t4 = _i; t4 < Pi; ++t4) e3 = 76283 * (t4 - 16) + Si >> Ai, Mi[t4 - _i] = Vt2(e3, 255), qi[t4 - _i] = Vt2(e3 + 8 >> 4, 15);
          Ii = 1;
        }
        return 1;
      }
      function dt2(t4) {
        var n3 = t4.ma, r3 = t4.U, i3 = t4.T;
        return e2(!(1 & t4.ka)), 0 >= r3 || 0 >= i3 ? 0 : (r3 = n3.Ib(t4, n3), null != n3.Jb && n3.Jb(t4, n3, r3), n3.Dc += r3, 1);
      }
      function pt2(t4) {
        t4.ma.memory = null;
      }
      function gt2(t4, e3, n3, r3) {
        return 47 != y3(t4, 8) ? 0 : (e3[0] = y3(t4, 14) + 1, n3[0] = y3(t4, 14) + 1, r3[0] = y3(t4, 1), 0 != y3(t4, 3) ? 0 : !t4.h);
      }
      function mt2(t4, e3) {
        if (4 > t4) return t4 + 1;
        var n3 = t4 - 2 >> 1;
        return (2 + (1 & t4) << n3) + y3(e3, n3) + 1;
      }
      function vt2(t4, e3) {
        return 120 < e3 ? e3 - 120 : 1 <= (n3 = ((n3 = Zr[e3 - 1]) >> 4) * t4 + (8 - (15 & n3))) ? n3 : 1;
        var n3;
      }
      function bt2(t4, e3, n3) {
        var r3 = L3(n3), i3 = t4[e3 += 255 & r3].g - 8;
        return 0 < i3 && (A3(n3, n3.u + 8), r3 = L3(n3), e3 += t4[e3].value, e3 += r3 & (1 << i3) - 1), A3(n3, n3.u + t4[e3].g), t4[e3].value;
      }
      function yt2(t4, n3, r3) {
        return r3.g += t4.g, r3.value += t4.value << n3 >>> 0, e2(8 >= r3.g), t4.g;
      }
      function wt2(t4, n3, r3) {
        var i3 = t4.xc;
        return e2((n3 = 0 == i3 ? 0 : t4.vc[t4.md * (r3 >> i3) + (n3 >> i3)]) < t4.Wb), t4.Ya[n3];
      }
      function Nt2(t4, n3, i3, a3) {
        var o3 = t4.ab, s3 = t4.c * n3, u4 = t4.C;
        n3 = u4 + n3;
        var c4 = i3, l4 = a3;
        for (a3 = t4.Ta, i3 = t4.Ua; 0 < o3--; ) {
          var h4 = t4.gc[o3], f4 = u4, d4 = n3, p4 = c4, g4 = l4, m4 = (l4 = a3, c4 = i3, h4.Ea);
          switch (e2(f4 < d4), e2(d4 <= h4.nc), h4.hc) {
            case 2:
              Gn(p4, g4, (d4 - f4) * m4, l4, c4);
              break;
            case 0:
              var v4 = f4, b4 = d4, y4 = l4, w4 = c4, N4 = (_3 = h4).Ea;
              0 == v4 && (Wn(p4, g4, null, null, 1, y4, w4), V2(p4, g4 + 1, 0, 0, N4 - 1, y4, w4 + 1), g4 += N4, w4 += N4, ++v4);
              for (var L4 = 1 << _3.b, x4 = L4 - 1, A4 = E2(N4, _3.b), S3 = _3.K, _3 = _3.w + (v4 >> _3.b) * A4; v4 < b4; ) {
                var P3 = S3, k3 = _3, F3 = 1;
                for (Vn(p4, g4, y4, w4 - N4, 1, y4, w4); F3 < N4; ) {
                  var I3 = (F3 & ~x4) + L4;
                  I3 > N4 && (I3 = N4), (0, Zn[P3[k3++] >> 8 & 15])(p4, g4 + +F3, y4, w4 + F3 - N4, I3 - F3, y4, w4 + F3), F3 = I3;
                }
                g4 += N4, w4 += N4, ++v4 & x4 || (_3 += A4);
              }
              d4 != h4.nc && r2(l4, c4 - m4, l4, c4 + (d4 - f4 - 1) * m4, m4);
              break;
            case 1:
              for (m4 = p4, b4 = g4, N4 = (p4 = h4.Ea) - (w4 = p4 & ~(y4 = (g4 = 1 << h4.b) - 1)), v4 = E2(p4, h4.b), L4 = h4.K, h4 = h4.w + (f4 >> h4.b) * v4; f4 < d4; ) {
                for (x4 = L4, A4 = h4, S3 = new T2(), _3 = b4 + w4, P3 = b4 + p4; b4 < _3; ) Y2(x4[A4++], S3), $n(S3, m4, b4, g4, l4, c4), b4 += g4, c4 += g4;
                b4 < P3 && (Y2(x4[A4++], S3), $n(S3, m4, b4, N4, l4, c4), b4 += N4, c4 += N4), ++f4 & y4 || (h4 += v4);
              }
              break;
            case 3:
              if (p4 == l4 && g4 == c4 && 0 < h4.b) {
                for (b4 = l4, p4 = m4 = c4 + (d4 - f4) * m4 - (w4 = (d4 - f4) * E2(h4.Ea, h4.b)), g4 = l4, y4 = c4, v4 = [], w4 = (N4 = w4) - 1; 0 <= w4; --w4) v4[w4] = g4[y4 + w4];
                for (w4 = N4 - 1; 0 <= w4; --w4) b4[p4 + w4] = v4[w4];
                Yn(h4, f4, d4, l4, m4, l4, c4);
              } else Yn(h4, f4, d4, p4, g4, l4, c4);
          }
          c4 = a3, l4 = i3;
        }
        l4 != i3 && r2(a3, i3, c4, l4, s3);
      }
      function Lt2(t4, n3) {
        var r3 = t4.V, i3 = t4.Ba + t4.c * t4.C, a3 = n3 - t4.C;
        if (e2(n3 <= t4.l.o), e2(16 >= a3), 0 < a3) {
          var o3 = t4.l, s3 = t4.Ta, u4 = t4.Ua, c4 = o3.width;
          if (Nt2(t4, a3, r3, i3), a3 = u4 = [u4], e2((r3 = t4.C) < (i3 = n3)), e2(o3.v < o3.va), i3 > o3.o && (i3 = o3.o), r3 < o3.j) {
            var l4 = o3.j - r3;
            r3 = o3.j, a3[0] += l4 * c4;
          }
          if (r3 >= i3 ? r3 = 0 : (a3[0] += 4 * o3.v, o3.ka = r3 - o3.j, o3.U = o3.va - o3.v, o3.T = i3 - r3, r3 = 1), r3) {
            if (u4 = u4[0], 11 > (r3 = t4.ca).S) {
              var h4 = r3.f.RGBA, f4 = (i3 = r3.S, a3 = o3.U, o3 = o3.T, l4 = h4.eb, h4.A), d4 = o3;
              for (h4 = h4.fb + t4.Ma * h4.A; 0 < d4--; ) {
                var p4 = s3, g4 = u4, m4 = a3, v4 = l4, b4 = h4;
                switch (i3) {
                  case Mr:
                    Qn(p4, g4, m4, v4, b4);
                    break;
                  case qr:
                    tr(p4, g4, m4, v4, b4);
                    break;
                  case Ur:
                    tr(p4, g4, m4, v4, b4), Lr(v4, b4, 0, m4, 1, 0);
                    break;
                  case Er:
                    rr(p4, g4, m4, v4, b4);
                    break;
                  case Rr:
                    et2(p4, g4, m4, v4, b4, 1);
                    break;
                  case Hr:
                    et2(p4, g4, m4, v4, b4, 1), Lr(v4, b4, 0, m4, 1, 0);
                    break;
                  case Dr:
                    et2(p4, g4, m4, v4, b4, 0);
                    break;
                  case Wr:
                    et2(p4, g4, m4, v4, b4, 0), Lr(v4, b4, 1, m4, 1, 0);
                    break;
                  case Tr:
                    er(p4, g4, m4, v4, b4);
                    break;
                  case Vr:
                    er(p4, g4, m4, v4, b4), xr(v4, b4, m4, 1, 0);
                    break;
                  case zr:
                    nr(p4, g4, m4, v4, b4);
                    break;
                  default:
                    e2(0);
                }
                u4 += c4, h4 += f4;
              }
              t4.Ma += o3;
            } else alert("todo:EmitRescaledRowsYUVA");
            e2(t4.Ma <= r3.height);
          }
        }
        t4.C = n3, e2(t4.C <= t4.i);
      }
      function xt2(t4) {
        var e3;
        if (0 < t4.ua) return 0;
        for (e3 = 0; e3 < t4.Wb; ++e3) {
          var n3 = t4.Ya[e3].G, r3 = t4.Ya[e3].H;
          if (0 < n3[1][r3[1] + 0].g || 0 < n3[2][r3[2] + 0].g || 0 < n3[3][r3[3] + 0].g) return 0;
        }
        return 1;
      }
      function At2(t4, n3, r3, i3, a3, o3) {
        if (0 != t4.Z) {
          var s3 = t4.qd, u4 = t4.rd;
          for (e2(null != gi[t4.Z]); n3 < r3; ++n3) gi[t4.Z](s3, u4, i3, a3, i3, a3, o3), s3 = i3, u4 = a3, a3 += o3;
          t4.qd = s3, t4.rd = u4;
        }
      }
      function St(t4, n3) {
        var r3 = t4.l.ma, i3 = 0 == r3.Z || 1 == r3.Z ? t4.l.j : t4.C;
        if (i3 = t4.C < i3 ? i3 : t4.C, e2(n3 <= t4.l.o), n3 > i3) {
          var a3 = t4.l.width, o3 = r3.ca, s3 = r3.tb + a3 * i3, u4 = t4.V, c4 = t4.Ba + t4.c * i3, l4 = t4.gc;
          e2(1 == t4.ab), e2(3 == l4[0].hc), Xn(l4[0], i3, n3, u4, c4, o3, s3), At2(r3, i3, n3, o3, s3, a3);
        }
        t4.C = t4.Ma = n3;
      }
      function _t2(t4, n3, r3, i3, a3, o3, s3) {
        var u4 = t4.$ / i3, c4 = t4.$ % i3, l4 = t4.m, h4 = t4.s, f4 = r3 + t4.$, d4 = f4;
        a3 = r3 + i3 * a3;
        var p4 = r3 + i3 * o3, g4 = 280 + h4.ua, m4 = t4.Pb ? u4 : 16777216, v4 = 0 < h4.ua ? h4.Wa : null, b4 = h4.wc, y4 = f4 < p4 ? wt2(h4, c4, u4) : null;
        e2(t4.C < o3), e2(p4 <= a3);
        var w4 = false;
        t: for (; ; ) {
          for (; w4 || f4 < p4; ) {
            var N4 = 0;
            if (u4 >= m4) {
              var _3 = f4 - r3;
              e2((m4 = t4).Pb), m4.wd = m4.m, m4.xd = _3, 0 < m4.s.ua && B3(m4.s.Wa, m4.s.vb), m4 = u4 + Qr;
            }
            if (c4 & b4 || (y4 = wt2(h4, c4, u4)), e2(null != y4), y4.Qb && (n3[f4] = y4.qb, w4 = true), !w4) if (S2(l4), y4.jc) {
              N4 = l4, _3 = n3;
              var P3 = f4, k3 = y4.pd[L3(N4) & Rn - 1];
              e2(y4.jc), 256 > k3.g ? (A3(N4, N4.u + k3.g), _3[P3] = k3.value, N4 = 0) : (A3(N4, N4.u + k3.g - 256), e2(256 <= k3.value), N4 = k3.value), 0 == N4 && (w4 = true);
            } else N4 = bt2(y4.G[0], y4.H[0], l4);
            if (l4.h) break;
            if (w4 || 256 > N4) {
              if (!w4) if (y4.nd) n3[f4] = (y4.qb | N4 << 8) >>> 0;
              else {
                if (S2(l4), w4 = bt2(y4.G[1], y4.H[1], l4), S2(l4), _3 = bt2(y4.G[2], y4.H[2], l4), P3 = bt2(y4.G[3], y4.H[3], l4), l4.h) break;
                n3[f4] = (P3 << 24 | w4 << 16 | N4 << 8 | _3) >>> 0;
              }
              if (w4 = false, ++f4, ++c4 >= i3 && (c4 = 0, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t4, u4), null != v4)) for (; d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else if (280 > N4) {
              if (N4 = mt2(N4 - 256, l4), _3 = bt2(y4.G[4], y4.H[4], l4), S2(l4), _3 = vt2(i3, _3 = mt2(_3, l4)), l4.h) break;
              if (f4 - r3 < _3 || a3 - f4 < N4) break t;
              for (P3 = 0; P3 < N4; ++P3) n3[f4 + P3] = n3[f4 + P3 - _3];
              for (f4 += N4, c4 += N4; c4 >= i3; ) c4 -= i3, ++u4, null != s3 && u4 <= o3 && !(u4 % 16) && s3(t4, u4);
              if (e2(f4 <= a3), c4 & b4 && (y4 = wt2(h4, c4, u4)), null != v4) for (; d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
            } else {
              if (!(N4 < g4)) break t;
              for (w4 = N4 - 280, e2(null != v4); d4 < f4; ) N4 = n3[d4++], v4.X[(506832829 * N4 & 4294967295) >>> v4.Mb] = N4;
              N4 = f4, e2(!(w4 >>> (_3 = v4).Xa)), n3[N4] = _3.X[w4], w4 = true;
            }
            w4 || e2(l4.h == x3(l4));
          }
          if (t4.Pb && l4.h && f4 < a3) e2(t4.m.h), t4.a = 5, t4.m = t4.wd, t4.$ = t4.xd, 0 < t4.s.ua && B3(t4.s.vb, t4.s.Wa);
          else {
            if (l4.h) break t;
            null != s3 && s3(t4, u4 > o3 ? o3 : u4), t4.a = 0, t4.$ = f4 - r3;
          }
          return 1;
        }
        return t4.a = 3, 0;
      }
      function Pt2(t4) {
        e2(null != t4), t4.vc = null, t4.yc = null, t4.Ya = null;
        var n3 = t4.Wa;
        null != n3 && (n3.X = null), t4.vb = null, e2(null != t4);
      }
      function kt2() {
        var e3 = new on();
        return null == e3 ? null : (e3.a = 0, e3.xb = pi, nt2("Predictor", "VP8LPredictors"), nt2("Predictor", "VP8LPredictors_C"), nt2("PredictorAdd", "VP8LPredictorsAdd"), nt2("PredictorAdd", "VP8LPredictorsAdd_C"), Gn = G2, $n = J2, Qn = K2, tr = Z2, er = $2, nr = Q2, rr = tt2, t3.VP8LMapColor32b = Jn, t3.VP8LMapColor8b = Kn, e3);
      }
      function Ft2(t4, n3, r3, s3, u4) {
        var c4 = 1, f4 = [t4], p4 = [n3], g4 = s3.m, m4 = s3.s, v4 = null, b4 = 0;
        t: for (; ; ) {
          if (r3) for (; c4 && y3(g4, 1); ) {
            var w4 = f4, N4 = p4, x4 = s3, _3 = 1, P3 = x4.m, k3 = x4.gc[x4.ab], F3 = y3(P3, 2);
            if (x4.Oc & 1 << F3) c4 = 0;
            else {
              switch (x4.Oc |= 1 << F3, k3.hc = F3, k3.Ea = w4[0], k3.nc = N4[0], k3.K = [null], ++x4.ab, e2(4 >= x4.ab), F3) {
                case 0:
                case 1:
                  k3.b = y3(P3, 3) + 2, _3 = Ft2(E2(k3.Ea, k3.b), E2(k3.nc, k3.b), 0, x4, k3.K), k3.K = k3.K[0];
                  break;
                case 3:
                  var I3, j3 = y3(P3, 8) + 1, C3 = 16 < j3 ? 0 : 4 < j3 ? 1 : 2 < j3 ? 2 : 3;
                  if (w4[0] = E2(k3.Ea, C3), k3.b = C3, I3 = _3 = Ft2(j3, 1, 0, x4, k3.K)) {
                    var B4, M3 = j3, q3 = k3, D3 = 1 << (8 >> q3.b), T3 = a2(D3);
                    if (null == T3) I3 = 0;
                    else {
                      var z3 = q3.K[0], U3 = q3.w;
                      for (T3[0] = q3.K[0][0], B4 = 1; B4 < 1 * M3; ++B4) T3[B4] = R2(z3[U3 + B4], T3[B4 - 1]);
                      for (; B4 < 4 * D3; ++B4) T3[B4] = 0;
                      q3.K[0] = null, q3.K[0] = T3, I3 = 1;
                    }
                  }
                  _3 = I3;
                  break;
                case 2:
                  break;
                default:
                  e2(0);
              }
              c4 = _3;
            }
          }
          if (f4 = f4[0], p4 = p4[0], c4 && y3(g4, 1) && !(c4 = 1 <= (b4 = y3(g4, 4)) && 11 >= b4)) {
            s3.a = 3;
            break t;
          }
          var H5;
          if (H5 = c4) e: {
            var W3, V3, G3, Y3 = s3, J3 = f4, X3 = p4, K3 = b4, Z3 = r3, $3 = Y3.m, Q3 = Y3.s, tt3 = [null], et3 = 1, nt3 = 0, rt3 = $r[K3];
            n: for (; ; ) {
              if (Z3 && y3($3, 1)) {
                var it3 = y3($3, 3) + 2, at3 = E2(J3, it3), ot3 = E2(X3, it3), st3 = at3 * ot3;
                if (!Ft2(at3, ot3, 0, Y3, tt3)) break n;
                for (tt3 = tt3[0], Q3.xc = it3, W3 = 0; W3 < st3; ++W3) {
                  var ut3 = tt3[W3] >> 8 & 65535;
                  tt3[W3] = ut3, ut3 >= et3 && (et3 = ut3 + 1);
                }
              }
              if ($3.h) break n;
              for (V3 = 0; 5 > V3; ++V3) {
                var ct3 = Jr[V3];
                !V3 && 0 < K3 && (ct3 += 1 << K3), nt3 < ct3 && (nt3 = ct3);
              }
              var lt3 = o2(et3 * rt3, h3), ht3 = et3, ft3 = o2(ht3, d3);
              if (null == ft3) var dt3 = null;
              else e2(65536 >= ht3), dt3 = ft3;
              var pt3 = a2(nt3);
              if (null == dt3 || null == pt3 || null == lt3) {
                Y3.a = 1;
                break n;
              }
              var gt3 = lt3;
              for (W3 = G3 = 0; W3 < et3; ++W3) {
                var mt3 = dt3[W3], vt3 = mt3.G, bt3 = mt3.H, wt3 = 0, Nt3 = 1, Lt3 = 0;
                for (V3 = 0; 5 > V3; ++V3) {
                  ct3 = Jr[V3], vt3[V3] = gt3, bt3[V3] = G3, !V3 && 0 < K3 && (ct3 += 1 << K3);
                  r: {
                    var xt3, At3 = ct3, St2 = Y3, kt3 = pt3, It3 = gt3, jt3 = G3, Ct3 = 0, Ot3 = St2.m, Bt3 = y3(Ot3, 1);
                    if (i2(kt3, 0, 0, At3), Bt3) {
                      var Mt3 = y3(Ot3, 1) + 1, qt3 = y3(Ot3, 1), Et3 = y3(Ot3, 0 == qt3 ? 1 : 8);
                      kt3[Et3] = 1, 2 == Mt3 && (kt3[Et3 = y3(Ot3, 8)] = 1);
                      var Rt3 = 1;
                    } else {
                      var Dt3 = a2(19), Tt3 = y3(Ot3, 4) + 4;
                      if (19 < Tt3) {
                        St2.a = 3;
                        var zt3 = 0;
                        break r;
                      }
                      for (xt3 = 0; xt3 < Tt3; ++xt3) Dt3[Kr[xt3]] = y3(Ot3, 3);
                      var Ut3 = void 0, Ht3 = void 0, Wt3 = St2, Vt3 = Dt3, Gt3 = At3, Yt3 = kt3, Jt3 = 0, Xt3 = Wt3.m, Kt3 = 8, Zt3 = o2(128, h3);
                      i: for (; l3(Zt3, 0, 7, Vt3, 19); ) {
                        if (y3(Xt3, 1)) {
                          var $t3 = 2 + 2 * y3(Xt3, 3);
                          if ((Ut3 = 2 + y3(Xt3, $t3)) > Gt3) break i;
                        } else Ut3 = Gt3;
                        for (Ht3 = 0; Ht3 < Gt3 && Ut3--; ) {
                          S2(Xt3);
                          var Qt3 = Zt3[0 + (127 & L3(Xt3))];
                          A3(Xt3, Xt3.u + Qt3.g);
                          var te3 = Qt3.value;
                          if (16 > te3) Yt3[Ht3++] = te3, 0 != te3 && (Kt3 = te3);
                          else {
                            var ee3 = 16 == te3, ne3 = te3 - 16, re3 = Yr[ne3], ie3 = y3(Xt3, Gr[ne3]) + re3;
                            if (Ht3 + ie3 > Gt3) break i;
                            for (var ae3 = ee3 ? Kt3 : 0; 0 < ie3--; ) Yt3[Ht3++] = ae3;
                          }
                        }
                        Jt3 = 1;
                        break i;
                      }
                      Jt3 || (Wt3.a = 3), Rt3 = Jt3;
                    }
                    (Rt3 = Rt3 && !Ot3.h) && (Ct3 = l3(It3, jt3, 8, kt3, At3)), Rt3 && 0 != Ct3 ? zt3 = Ct3 : (St2.a = 3, zt3 = 0);
                  }
                  if (0 == zt3) break n;
                  if (Nt3 && 1 == Xr[V3] && (Nt3 = 0 == gt3[G3].g), wt3 += gt3[G3].g, G3 += zt3, 3 >= V3) {
                    var oe3, se3 = pt3[0];
                    for (oe3 = 1; oe3 < ct3; ++oe3) pt3[oe3] > se3 && (se3 = pt3[oe3]);
                    Lt3 += se3;
                  }
                }
                if (mt3.nd = Nt3, mt3.Qb = 0, Nt3 && (mt3.qb = (vt3[3][bt3[3] + 0].value << 24 | vt3[1][bt3[1] + 0].value << 16 | vt3[2][bt3[2] + 0].value) >>> 0, 0 == wt3 && 256 > vt3[0][bt3[0] + 0].value && (mt3.Qb = 1, mt3.qb += vt3[0][bt3[0] + 0].value << 8)), mt3.jc = !mt3.Qb && 6 > Lt3, mt3.jc) {
                  var ue3, ce3 = mt3;
                  for (ue3 = 0; ue3 < Rn; ++ue3) {
                    var le3 = ue3, he3 = ce3.pd[le3], fe3 = ce3.G[0][ce3.H[0] + le3];
                    256 <= fe3.value ? (he3.g = fe3.g + 256, he3.value = fe3.value) : (he3.g = 0, he3.value = 0, le3 >>= yt2(fe3, 8, he3), le3 >>= yt2(ce3.G[1][ce3.H[1] + le3], 16, he3), le3 >>= yt2(ce3.G[2][ce3.H[2] + le3], 0, he3), yt2(ce3.G[3][ce3.H[3] + le3], 24, he3));
                  }
                }
              }
              Q3.vc = tt3, Q3.Wb = et3, Q3.Ya = dt3, Q3.yc = lt3, H5 = 1;
              break e;
            }
            H5 = 0;
          }
          if (!(c4 = H5)) {
            s3.a = 3;
            break t;
          }
          if (0 < b4) {
            if (m4.ua = 1 << b4, !O2(m4.Wa, b4)) {
              s3.a = 1, c4 = 0;
              break t;
            }
          } else m4.ua = 0;
          var de3 = s3, pe3 = f4, ge3 = p4, me3 = de3.s, ve3 = me3.xc;
          if (de3.c = pe3, de3.i = ge3, me3.md = E2(pe3, ve3), me3.wc = 0 == ve3 ? -1 : (1 << ve3) - 1, r3) {
            s3.xb = di;
            break t;
          }
          if (null == (v4 = a2(f4 * p4))) {
            s3.a = 1, c4 = 0;
            break t;
          }
          c4 = (c4 = _t2(s3, v4, 0, f4, p4, p4, null)) && !g4.h;
          break t;
        }
        return c4 ? (null != u4 ? u4[0] = v4 : (e2(null == v4), e2(r3)), s3.$ = 0, r3 || Pt2(m4)) : Pt2(m4), c4;
      }
      function It2(t4, n3) {
        var r3 = t4.c * t4.i, i3 = r3 + n3 + 16 * n3;
        return e2(t4.c <= n3), t4.V = a2(i3), null == t4.V ? (t4.Ta = null, t4.Ua = 0, t4.a = 1, 0) : (t4.Ta = t4.V, t4.Ua = t4.Ba + r3 + n3, 1);
      }
      function jt2(t4, n3) {
        var r3 = t4.C, i3 = n3 - r3, a3 = t4.V, o3 = t4.Ba + t4.c * r3;
        for (e2(n3 <= t4.l.o); 0 < i3; ) {
          var s3 = 16 < i3 ? 16 : i3, u4 = t4.l.ma, c4 = t4.l.width, l4 = c4 * s3, h4 = u4.ca, f4 = u4.tb + c4 * r3, d4 = t4.Ta, p4 = t4.Ua;
          Nt2(t4, s3, a3, o3), Sr(d4, p4, h4, f4, l4), At2(u4, r3, r3 + s3, h4, f4, c4), i3 -= s3, a3 += s3 * t4.c, r3 += s3;
        }
        e2(r3 == n3), t4.C = t4.Ma = n3;
      }
      function Ct2() {
        this.ub = this.yd = this.td = this.Rb = 0;
      }
      function Ot2() {
        this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0;
      }
      function Bt2() {
        this.Fb = this.Bb = this.Cb = 0, this.Zb = a2(4), this.Lb = a2(4);
      }
      function Mt2() {
        this.Yb = (function() {
          var t4 = [];
          return (function t5(e3, n3, r3) {
            for (var i3 = r3[n3], a3 = 0; a3 < i3 && (e3.push(r3.length > n3 + 1 ? [] : 0), !(r3.length < n3 + 1)); a3++) t5(e3[a3], n3 + 1, r3);
          })(t4, 0, [3, 11]), t4;
        })();
      }
      function qt2() {
        this.jb = a2(3), this.Wc = s2([4, 8], Mt2), this.Xc = s2([4, 17], Mt2);
      }
      function Et2() {
        this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new a2(4), this.od = new a2(4);
      }
      function Rt2() {
        this.ld = this.La = this.dd = this.tc = 0;
      }
      function Dt2() {
        this.Na = this.la = 0;
      }
      function Tt2() {
        this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0;
      }
      function zt2() {
        this.ad = a2(384), this.Za = 0, this.Ob = a2(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0;
      }
      function Ut2() {
        this.uc = this.M = this.Nb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.ya = Array(new zt2()), this.aa = 0, this.l = new Gt2();
      }
      function Ht2() {
        this.y = a2(16), this.f = a2(8), this.ea = a2(8);
      }
      function Wt2() {
        this.cb = this.a = 0, this.sc = "", this.m = new w3(), this.Od = new Ct2(), this.Kc = new Ot2(), this.ed = new Et2(), this.Qa = new Bt2(), this.Ic = this.$c = this.Aa = 0, this.D = new Ut2(), this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = o2(8, w3), this.ia = 0, this.pb = o2(4, Tt2), this.Pa = new qt2(), this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new Ht2()), this.Hd = 0, this.rb = Array(new Dt2()), this.sb = 0, this.wa = Array(new Rt2()), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new zt2()), this.L = this.aa = 0, this.gd = s2([4, 2], Rt2), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0;
      }
      function Vt2(t4, e3) {
        return 0 > t4 ? 0 : t4 > e3 ? e3 : t4;
      }
      function Gt2() {
        this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0;
      }
      function Yt2() {
        var t4 = new Wt2();
        return null != t4 && (t4.a = 0, t4.sc = "OK", t4.cb = 0, t4.Xb = 0, ni || (ni = Zt2)), t4;
      }
      function Jt2(t4, e3, n3) {
        return 0 == t4.a && (t4.a = e3, t4.sc = n3, t4.cb = 0), 0;
      }
      function Xt2(t4, e3, n3) {
        return 3 <= n3 && 157 == t4[e3 + 0] && 1 == t4[e3 + 1] && 42 == t4[e3 + 2];
      }
      function Kt2(t4, n3) {
        if (null == t4) return 0;
        if (t4.a = 0, t4.sc = "OK", null == n3) return Jt2(t4, 2, "null VP8Io passed to VP8GetHeaders()");
        var r3 = n3.data, a3 = n3.w, o3 = n3.ha;
        if (4 > o3) return Jt2(t4, 7, "Truncated header.");
        var s3 = r3[a3 + 0] | r3[a3 + 1] << 8 | r3[a3 + 2] << 16, u4 = t4.Od;
        if (u4.Rb = !(1 & s3), u4.td = s3 >> 1 & 7, u4.yd = s3 >> 4 & 1, u4.ub = s3 >> 5, 3 < u4.td) return Jt2(t4, 3, "Incorrect keyframe parameters.");
        if (!u4.yd) return Jt2(t4, 4, "Frame not displayable.");
        a3 += 3, o3 -= 3;
        var c4 = t4.Kc;
        if (u4.Rb) {
          if (7 > o3) return Jt2(t4, 7, "cannot parse picture header");
          if (!Xt2(r3, a3, o3)) return Jt2(t4, 3, "Bad code word");
          c4.c = 16383 & (r3[a3 + 4] << 8 | r3[a3 + 3]), c4.Td = r3[a3 + 4] >> 6, c4.i = 16383 & (r3[a3 + 6] << 8 | r3[a3 + 5]), c4.Ud = r3[a3 + 6] >> 6, a3 += 7, o3 -= 7, t4.za = c4.c + 15 >> 4, t4.Ub = c4.i + 15 >> 4, n3.width = c4.c, n3.height = c4.i, n3.Da = 0, n3.j = 0, n3.v = 0, n3.va = n3.width, n3.o = n3.height, n3.da = 0, n3.ib = n3.width, n3.hb = n3.height, n3.U = n3.width, n3.T = n3.height, i2((s3 = t4.Pa).jb, 0, 255, s3.jb.length), e2(null != (s3 = t4.Qa)), s3.Cb = 0, s3.Bb = 0, s3.Fb = 1, i2(s3.Zb, 0, 0, s3.Zb.length), i2(s3.Lb, 0, 0, s3.Lb);
        }
        if (u4.ub > o3) return Jt2(t4, 7, "bad partition length");
        p3(s3 = t4.m, r3, a3, u4.ub), a3 += u4.ub, o3 -= u4.ub, u4.Rb && (c4.Ld = P2(s3), c4.Kd = P2(s3)), c4 = t4.Qa;
        var l4, h4 = t4.Pa;
        if (e2(null != s3), e2(null != c4), c4.Cb = P2(s3), c4.Cb) {
          if (c4.Bb = P2(s3), P2(s3)) {
            for (c4.Fb = P2(s3), l4 = 0; 4 > l4; ++l4) c4.Zb[l4] = P2(s3) ? m3(s3, 7) : 0;
            for (l4 = 0; 4 > l4; ++l4) c4.Lb[l4] = P2(s3) ? m3(s3, 6) : 0;
          }
          if (c4.Bb) for (l4 = 0; 3 > l4; ++l4) h4.jb[l4] = P2(s3) ? g3(s3, 8) : 255;
        } else c4.Bb = 0;
        if (s3.Ka) return Jt2(t4, 3, "cannot parse segment header");
        if ((c4 = t4.ed).zd = P2(s3), c4.Tb = g3(s3, 6), c4.wb = g3(s3, 3), c4.Pc = P2(s3), c4.Pc && P2(s3)) {
          for (h4 = 0; 4 > h4; ++h4) P2(s3) && (c4.vd[h4] = m3(s3, 6));
          for (h4 = 0; 4 > h4; ++h4) P2(s3) && (c4.od[h4] = m3(s3, 6));
        }
        if (t4.L = 0 == c4.Tb ? 0 : c4.zd ? 1 : 2, s3.Ka) return Jt2(t4, 3, "cannot parse filter header");
        var f4 = o3;
        if (o3 = l4 = a3, a3 = l4 + f4, c4 = f4, t4.Xb = (1 << g3(t4.m, 2)) - 1, f4 < 3 * (h4 = t4.Xb)) r3 = 7;
        else {
          for (l4 += 3 * h4, c4 -= 3 * h4, f4 = 0; f4 < h4; ++f4) {
            var d4 = r3[o3 + 0] | r3[o3 + 1] << 8 | r3[o3 + 2] << 16;
            d4 > c4 && (d4 = c4), p3(t4.Jc[+f4], r3, l4, d4), l4 += d4, c4 -= d4, o3 += 3;
          }
          p3(t4.Jc[+h4], r3, l4, c4), r3 = l4 < a3 ? 0 : 5;
        }
        if (0 != r3) return Jt2(t4, r3, "cannot parse partitions");
        for (r3 = g3(l4 = t4.m, 7), o3 = P2(l4) ? m3(l4, 4) : 0, a3 = P2(l4) ? m3(l4, 4) : 0, c4 = P2(l4) ? m3(l4, 4) : 0, h4 = P2(l4) ? m3(l4, 4) : 0, l4 = P2(l4) ? m3(l4, 4) : 0, f4 = t4.Qa, d4 = 0; 4 > d4; ++d4) {
          if (f4.Cb) {
            var v4 = f4.Zb[d4];
            f4.Fb || (v4 += r3);
          } else {
            if (0 < d4) {
              t4.pb[d4] = t4.pb[0];
              continue;
            }
            v4 = r3;
          }
          var b4 = t4.pb[d4];
          b4.Sc[0] = ti[Vt2(v4 + o3, 127)], b4.Sc[1] = ei[Vt2(v4 + 0, 127)], b4.Eb[0] = 2 * ti[Vt2(v4 + a3, 127)], b4.Eb[1] = 101581 * ei[Vt2(v4 + c4, 127)] >> 16, 8 > b4.Eb[1] && (b4.Eb[1] = 8), b4.Qc[0] = ti[Vt2(v4 + h4, 117)], b4.Qc[1] = ei[Vt2(v4 + l4, 127)], b4.lc = v4 + l4;
        }
        if (!u4.Rb) return Jt2(t4, 4, "Not a key frame.");
        for (P2(s3), u4 = t4.Pa, r3 = 0; 4 > r3; ++r3) {
          for (o3 = 0; 8 > o3; ++o3) for (a3 = 0; 3 > a3; ++a3) for (c4 = 0; 11 > c4; ++c4) h4 = k2(s3, ui[r3][o3][a3][c4]) ? g3(s3, 8) : oi[r3][o3][a3][c4], u4.Wc[r3][o3].Yb[a3][c4] = h4;
          for (o3 = 0; 17 > o3; ++o3) u4.Xc[r3][o3] = u4.Wc[r3][ci[o3]];
        }
        return t4.kc = P2(s3), t4.kc && (t4.Bd = g3(s3, 8)), t4.cb = 1;
      }
      function Zt2(t4, e3, n3, r3, i3, a3, o3) {
        var s3 = e3[i3].Yb[n3];
        for (n3 = 0; 16 > i3; ++i3) {
          if (!k2(t4, s3[n3 + 0])) return i3;
          for (; !k2(t4, s3[n3 + 1]); ) if (s3 = e3[++i3].Yb[0], n3 = 0, 16 == i3) return 16;
          var u4 = e3[i3 + 1].Yb;
          if (k2(t4, s3[n3 + 2])) {
            var c4 = t4, l4 = 0;
            if (k2(c4, (f4 = s3)[(h4 = n3) + 3])) if (k2(c4, f4[h4 + 6])) {
              for (s3 = 0, h4 = 2 * (l4 = k2(c4, f4[h4 + 8])) + (f4 = k2(c4, f4[h4 + 9 + l4])), l4 = 0, f4 = ri[h4]; f4[s3]; ++s3) l4 += l4 + k2(c4, f4[s3]);
              l4 += 3 + (8 << h4);
            } else k2(c4, f4[h4 + 7]) ? (l4 = 7 + 2 * k2(c4, 165), l4 += k2(c4, 145)) : l4 = 5 + k2(c4, 159);
            else l4 = k2(c4, f4[h4 + 4]) ? 3 + k2(c4, f4[h4 + 5]) : 2;
            s3 = u4[2];
          } else l4 = 1, s3 = u4[1];
          u4 = o3 + ii[i3], 0 > (c4 = t4).b && _2(c4);
          var h4, f4 = c4.b, d4 = (h4 = c4.Ca >> 1) - (c4.I >> f4) >> 31;
          --c4.b, c4.Ca += d4, c4.Ca |= 1, c4.I -= (h4 + 1 & d4) << f4, a3[u4] = ((l4 ^ d4) - d4) * r3[(0 < i3) + 0];
        }
        return 16;
      }
      function $t2(t4) {
        var e3 = t4.rb[t4.sb - 1];
        e3.la = 0, e3.Na = 0, i2(t4.zc, 0, 0, t4.zc.length), t4.ja = 0;
      }
      function Qt2(t4, e3, n3, r3, i3) {
        i3 = t4[e3 + n3 + 32 * r3] + (i3 >> 3), t4[e3 + n3 + 32 * r3] = -256 & i3 ? 0 > i3 ? 0 : 255 : i3;
      }
      function te2(t4, e3, n3, r3, i3, a3) {
        Qt2(t4, e3, 0, n3, r3 + i3), Qt2(t4, e3, 1, n3, r3 + a3), Qt2(t4, e3, 2, n3, r3 - a3), Qt2(t4, e3, 3, n3, r3 - i3);
      }
      function ee2(t4) {
        return (20091 * t4 >> 16) + t4;
      }
      function ne2(t4, e3, n3, r3) {
        var i3, o3 = 0, s3 = a2(16);
        for (i3 = 0; 4 > i3; ++i3) {
          var u4 = t4[e3 + 0] + t4[e3 + 8], c4 = t4[e3 + 0] - t4[e3 + 8], l4 = (35468 * t4[e3 + 4] >> 16) - ee2(t4[e3 + 12]), h4 = ee2(t4[e3 + 4]) + (35468 * t4[e3 + 12] >> 16);
          s3[o3 + 0] = u4 + h4, s3[o3 + 1] = c4 + l4, s3[o3 + 2] = c4 - l4, s3[o3 + 3] = u4 - h4, o3 += 4, e3++;
        }
        for (i3 = o3 = 0; 4 > i3; ++i3) u4 = (t4 = s3[o3 + 0] + 4) + s3[o3 + 8], c4 = t4 - s3[o3 + 8], l4 = (35468 * s3[o3 + 4] >> 16) - ee2(s3[o3 + 12]), Qt2(n3, r3, 0, 0, u4 + (h4 = ee2(s3[o3 + 4]) + (35468 * s3[o3 + 12] >> 16))), Qt2(n3, r3, 1, 0, c4 + l4), Qt2(n3, r3, 2, 0, c4 - l4), Qt2(n3, r3, 3, 0, u4 - h4), o3++, r3 += 32;
      }
      function re2(t4, e3, n3, r3) {
        var i3 = t4[e3 + 0] + 4, a3 = 35468 * t4[e3 + 4] >> 16, o3 = ee2(t4[e3 + 4]), s3 = 35468 * t4[e3 + 1] >> 16;
        te2(n3, r3, 0, i3 + o3, t4 = ee2(t4[e3 + 1]), s3), te2(n3, r3, 1, i3 + a3, t4, s3), te2(n3, r3, 2, i3 - a3, t4, s3), te2(n3, r3, 3, i3 - o3, t4, s3);
      }
      function ie2(t4, e3, n3, r3, i3) {
        ne2(t4, e3, n3, r3), i3 && ne2(t4, e3 + 16, n3, r3 + 4);
      }
      function ae2(t4, e3, n3, r3) {
        ar(t4, e3 + 0, n3, r3, 1), ar(t4, e3 + 32, n3, r3 + 128, 1);
      }
      function oe2(t4, e3, n3, r3) {
        var i3;
        for (t4 = t4[e3 + 0] + 4, i3 = 0; 4 > i3; ++i3) for (e3 = 0; 4 > e3; ++e3) Qt2(n3, r3, e3, i3, t4);
      }
      function se2(t4, e3, n3, r3) {
        t4[e3 + 0] && ur(t4, e3 + 0, n3, r3), t4[e3 + 16] && ur(t4, e3 + 16, n3, r3 + 4), t4[e3 + 32] && ur(t4, e3 + 32, n3, r3 + 128), t4[e3 + 48] && ur(t4, e3 + 48, n3, r3 + 128 + 4);
      }
      function ue2(t4, e3, n3, r3) {
        var i3, o3 = a2(16);
        for (i3 = 0; 4 > i3; ++i3) {
          var s3 = t4[e3 + 0 + i3] + t4[e3 + 12 + i3], u4 = t4[e3 + 4 + i3] + t4[e3 + 8 + i3], c4 = t4[e3 + 4 + i3] - t4[e3 + 8 + i3], l4 = t4[e3 + 0 + i3] - t4[e3 + 12 + i3];
          o3[0 + i3] = s3 + u4, o3[8 + i3] = s3 - u4, o3[4 + i3] = l4 + c4, o3[12 + i3] = l4 - c4;
        }
        for (i3 = 0; 4 > i3; ++i3) s3 = (t4 = o3[0 + 4 * i3] + 3) + o3[3 + 4 * i3], u4 = o3[1 + 4 * i3] + o3[2 + 4 * i3], c4 = o3[1 + 4 * i3] - o3[2 + 4 * i3], l4 = t4 - o3[3 + 4 * i3], n3[r3 + 0] = s3 + u4 >> 3, n3[r3 + 16] = l4 + c4 >> 3, n3[r3 + 32] = s3 - u4 >> 3, n3[r3 + 48] = l4 - c4 >> 3, r3 += 64;
      }
      function ce2(t4, e3, n3) {
        var r3, i3 = e3 - 32, a3 = Or, o3 = 255 - t4[i3 - 1];
        for (r3 = 0; r3 < n3; ++r3) {
          var s3, u4 = a3, c4 = o3 + t4[e3 - 1];
          for (s3 = 0; s3 < n3; ++s3) t4[e3 + s3] = u4[c4 + t4[i3 + s3]];
          e3 += 32;
        }
      }
      function le2(t4, e3) {
        ce2(t4, e3, 4);
      }
      function he2(t4, e3) {
        ce2(t4, e3, 8);
      }
      function fe2(t4, e3) {
        ce2(t4, e3, 16);
      }
      function de2(t4, e3) {
        var n3;
        for (n3 = 0; 16 > n3; ++n3) r2(t4, e3 + 32 * n3, t4, e3 - 32, 16);
      }
      function pe2(t4, e3) {
        var n3;
        for (n3 = 16; 0 < n3; --n3) i2(t4, e3, t4[e3 - 1], 16), e3 += 32;
      }
      function ge2(t4, e3, n3) {
        var r3;
        for (r3 = 0; 16 > r3; ++r3) i2(e3, n3 + 32 * r3, t4, 16);
      }
      function me2(t4, e3) {
        var n3, r3 = 16;
        for (n3 = 0; 16 > n3; ++n3) r3 += t4[e3 - 1 + 32 * n3] + t4[e3 + n3 - 32];
        ge2(r3 >> 5, t4, e3);
      }
      function ve2(t4, e3) {
        var n3, r3 = 8;
        for (n3 = 0; 16 > n3; ++n3) r3 += t4[e3 - 1 + 32 * n3];
        ge2(r3 >> 4, t4, e3);
      }
      function be2(t4, e3) {
        var n3, r3 = 8;
        for (n3 = 0; 16 > n3; ++n3) r3 += t4[e3 + n3 - 32];
        ge2(r3 >> 4, t4, e3);
      }
      function ye2(t4, e3) {
        ge2(128, t4, e3);
      }
      function we2(t4, e3, n3) {
        return t4 + 2 * e3 + n3 + 2 >> 2;
      }
      function Ne2(t4, e3) {
        var n3, i3 = e3 - 32;
        for (i3 = new Uint8Array([we2(t4[i3 - 1], t4[i3 + 0], t4[i3 + 1]), we2(t4[i3 + 0], t4[i3 + 1], t4[i3 + 2]), we2(t4[i3 + 1], t4[i3 + 2], t4[i3 + 3]), we2(t4[i3 + 2], t4[i3 + 3], t4[i3 + 4])]), n3 = 0; 4 > n3; ++n3) r2(t4, e3 + 32 * n3, i3, 0, i3.length);
      }
      function Le2(t4, e3) {
        var n3 = t4[e3 - 1], r3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
        F2(t4, e3 + 0, 16843009 * we2(t4[e3 - 1 - 32], n3, r3)), F2(t4, e3 + 32, 16843009 * we2(n3, r3, i3)), F2(t4, e3 + 64, 16843009 * we2(r3, i3, a3)), F2(t4, e3 + 96, 16843009 * we2(i3, a3, a3));
      }
      function xe2(t4, e3) {
        var n3, r3 = 4;
        for (n3 = 0; 4 > n3; ++n3) r3 += t4[e3 + n3 - 32] + t4[e3 - 1 + 32 * n3];
        for (r3 >>= 3, n3 = 0; 4 > n3; ++n3) i2(t4, e3 + 32 * n3, r3, 4);
      }
      function Ae2(t4, e3) {
        var n3 = t4[e3 - 1 + 0], r3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], u4 = t4[e3 + 2 - 32], c4 = t4[e3 + 3 - 32];
        t4[e3 + 0 + 96] = we2(r3, i3, t4[e3 - 1 + 96]), t4[e3 + 1 + 96] = t4[e3 + 0 + 64] = we2(n3, r3, i3), t4[e3 + 2 + 96] = t4[e3 + 1 + 64] = t4[e3 + 0 + 32] = we2(a3, n3, r3), t4[e3 + 3 + 96] = t4[e3 + 2 + 64] = t4[e3 + 1 + 32] = t4[e3 + 0 + 0] = we2(o3, a3, n3), t4[e3 + 3 + 64] = t4[e3 + 2 + 32] = t4[e3 + 1 + 0] = we2(s3, o3, a3), t4[e3 + 3 + 32] = t4[e3 + 2 + 0] = we2(u4, s3, o3), t4[e3 + 3 + 0] = we2(c4, u4, s3);
      }
      function Se2(t4, e3) {
        var n3 = t4[e3 + 1 - 32], r3 = t4[e3 + 2 - 32], i3 = t4[e3 + 3 - 32], a3 = t4[e3 + 4 - 32], o3 = t4[e3 + 5 - 32], s3 = t4[e3 + 6 - 32], u4 = t4[e3 + 7 - 32];
        t4[e3 + 0 + 0] = we2(t4[e3 + 0 - 32], n3, r3), t4[e3 + 1 + 0] = t4[e3 + 0 + 32] = we2(n3, r3, i3), t4[e3 + 2 + 0] = t4[e3 + 1 + 32] = t4[e3 + 0 + 64] = we2(r3, i3, a3), t4[e3 + 3 + 0] = t4[e3 + 2 + 32] = t4[e3 + 1 + 64] = t4[e3 + 0 + 96] = we2(i3, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 64] = t4[e3 + 1 + 96] = we2(a3, o3, s3), t4[e3 + 3 + 64] = t4[e3 + 2 + 96] = we2(o3, s3, u4), t4[e3 + 3 + 96] = we2(s3, u4, u4);
      }
      function _e2(t4, e3) {
        var n3 = t4[e3 - 1 + 0], r3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 - 32], o3 = t4[e3 + 0 - 32], s3 = t4[e3 + 1 - 32], u4 = t4[e3 + 2 - 32], c4 = t4[e3 + 3 - 32];
        t4[e3 + 0 + 0] = t4[e3 + 1 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 2 + 64] = o3 + s3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 3 + 64] = s3 + u4 + 1 >> 1, t4[e3 + 3 + 0] = u4 + c4 + 1 >> 1, t4[e3 + 0 + 96] = we2(i3, r3, n3), t4[e3 + 0 + 64] = we2(r3, n3, a3), t4[e3 + 0 + 32] = t4[e3 + 1 + 96] = we2(n3, a3, o3), t4[e3 + 1 + 32] = t4[e3 + 2 + 96] = we2(a3, o3, s3), t4[e3 + 2 + 32] = t4[e3 + 3 + 96] = we2(o3, s3, u4), t4[e3 + 3 + 32] = we2(s3, u4, c4);
      }
      function Pe2(t4, e3) {
        var n3 = t4[e3 + 0 - 32], r3 = t4[e3 + 1 - 32], i3 = t4[e3 + 2 - 32], a3 = t4[e3 + 3 - 32], o3 = t4[e3 + 4 - 32], s3 = t4[e3 + 5 - 32], u4 = t4[e3 + 6 - 32], c4 = t4[e3 + 7 - 32];
        t4[e3 + 0 + 0] = n3 + r3 + 1 >> 1, t4[e3 + 1 + 0] = t4[e3 + 0 + 64] = r3 + i3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 1 + 64] = i3 + a3 + 1 >> 1, t4[e3 + 3 + 0] = t4[e3 + 2 + 64] = a3 + o3 + 1 >> 1, t4[e3 + 0 + 32] = we2(n3, r3, i3), t4[e3 + 1 + 32] = t4[e3 + 0 + 96] = we2(r3, i3, a3), t4[e3 + 2 + 32] = t4[e3 + 1 + 96] = we2(i3, a3, o3), t4[e3 + 3 + 32] = t4[e3 + 2 + 96] = we2(a3, o3, s3), t4[e3 + 3 + 64] = we2(o3, s3, u4), t4[e3 + 3 + 96] = we2(s3, u4, c4);
      }
      function ke2(t4, e3) {
        var n3 = t4[e3 - 1 + 0], r3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96];
        t4[e3 + 0 + 0] = n3 + r3 + 1 >> 1, t4[e3 + 2 + 0] = t4[e3 + 0 + 32] = r3 + i3 + 1 >> 1, t4[e3 + 2 + 32] = t4[e3 + 0 + 64] = i3 + a3 + 1 >> 1, t4[e3 + 1 + 0] = we2(n3, r3, i3), t4[e3 + 3 + 0] = t4[e3 + 1 + 32] = we2(r3, i3, a3), t4[e3 + 3 + 32] = t4[e3 + 1 + 64] = we2(i3, a3, a3), t4[e3 + 3 + 64] = t4[e3 + 2 + 64] = t4[e3 + 0 + 96] = t4[e3 + 1 + 96] = t4[e3 + 2 + 96] = t4[e3 + 3 + 96] = a3;
      }
      function Fe2(t4, e3) {
        var n3 = t4[e3 - 1 + 0], r3 = t4[e3 - 1 + 32], i3 = t4[e3 - 1 + 64], a3 = t4[e3 - 1 + 96], o3 = t4[e3 - 1 - 32], s3 = t4[e3 + 0 - 32], u4 = t4[e3 + 1 - 32], c4 = t4[e3 + 2 - 32];
        t4[e3 + 0 + 0] = t4[e3 + 2 + 32] = n3 + o3 + 1 >> 1, t4[e3 + 0 + 32] = t4[e3 + 2 + 64] = r3 + n3 + 1 >> 1, t4[e3 + 0 + 64] = t4[e3 + 2 + 96] = i3 + r3 + 1 >> 1, t4[e3 + 0 + 96] = a3 + i3 + 1 >> 1, t4[e3 + 3 + 0] = we2(s3, u4, c4), t4[e3 + 2 + 0] = we2(o3, s3, u4), t4[e3 + 1 + 0] = t4[e3 + 3 + 32] = we2(n3, o3, s3), t4[e3 + 1 + 32] = t4[e3 + 3 + 64] = we2(r3, n3, o3), t4[e3 + 1 + 64] = t4[e3 + 3 + 96] = we2(i3, r3, n3), t4[e3 + 1 + 96] = we2(a3, i3, r3);
      }
      function Ie2(t4, e3) {
        var n3;
        for (n3 = 0; 8 > n3; ++n3) r2(t4, e3 + 32 * n3, t4, e3 - 32, 8);
      }
      function je2(t4, e3) {
        var n3;
        for (n3 = 0; 8 > n3; ++n3) i2(t4, e3, t4[e3 - 1], 8), e3 += 32;
      }
      function Ce(t4, e3, n3) {
        var r3;
        for (r3 = 0; 8 > r3; ++r3) i2(e3, n3 + 32 * r3, t4, 8);
      }
      function Oe(t4, e3) {
        var n3, r3 = 8;
        for (n3 = 0; 8 > n3; ++n3) r3 += t4[e3 + n3 - 32] + t4[e3 - 1 + 32 * n3];
        Ce(r3 >> 4, t4, e3);
      }
      function Be(t4, e3) {
        var n3, r3 = 4;
        for (n3 = 0; 8 > n3; ++n3) r3 += t4[e3 + n3 - 32];
        Ce(r3 >> 3, t4, e3);
      }
      function Me(t4, e3) {
        var n3, r3 = 4;
        for (n3 = 0; 8 > n3; ++n3) r3 += t4[e3 - 1 + 32 * n3];
        Ce(r3 >> 3, t4, e3);
      }
      function qe(t4, e3) {
        Ce(128, t4, e3);
      }
      function Ee(t4, e3, n3) {
        var r3 = t4[e3 - n3], i3 = t4[e3 + 0], a3 = 3 * (i3 - r3) + jr[1020 + t4[e3 - 2 * n3] - t4[e3 + n3]], o3 = Cr[112 + (a3 + 4 >> 3)];
        t4[e3 - n3] = Or[255 + r3 + Cr[112 + (a3 + 3 >> 3)]], t4[e3 + 0] = Or[255 + i3 - o3];
      }
      function Re(t4, e3, n3, r3) {
        var i3 = t4[e3 + 0], a3 = t4[e3 + n3];
        return Br[255 + t4[e3 - 2 * n3] - t4[e3 - n3]] > r3 || Br[255 + a3 - i3] > r3;
      }
      function De(t4, e3, n3, r3) {
        return 4 * Br[255 + t4[e3 - n3] - t4[e3 + 0]] + Br[255 + t4[e3 - 2 * n3] - t4[e3 + n3]] <= r3;
      }
      function Te(t4, e3, n3, r3, i3) {
        var a3 = t4[e3 - 3 * n3], o3 = t4[e3 - 2 * n3], s3 = t4[e3 - n3], u4 = t4[e3 + 0], c4 = t4[e3 + n3], l4 = t4[e3 + 2 * n3], h4 = t4[e3 + 3 * n3];
        return 4 * Br[255 + s3 - u4] + Br[255 + o3 - c4] > r3 ? 0 : Br[255 + t4[e3 - 4 * n3] - a3] <= i3 && Br[255 + a3 - o3] <= i3 && Br[255 + o3 - s3] <= i3 && Br[255 + h4 - l4] <= i3 && Br[255 + l4 - c4] <= i3 && Br[255 + c4 - u4] <= i3;
      }
      function ze(t4, e3, n3, r3) {
        var i3 = 2 * r3 + 1;
        for (r3 = 0; 16 > r3; ++r3) De(t4, e3 + r3, n3, i3) && Ee(t4, e3 + r3, n3);
      }
      function Ue(t4, e3, n3, r3) {
        var i3 = 2 * r3 + 1;
        for (r3 = 0; 16 > r3; ++r3) De(t4, e3 + r3 * n3, 1, i3) && Ee(t4, e3 + r3 * n3, 1);
      }
      function He(t4, e3, n3, r3) {
        var i3;
        for (i3 = 3; 0 < i3; --i3) ze(t4, e3 += 4 * n3, n3, r3);
      }
      function We(t4, e3, n3, r3) {
        var i3;
        for (i3 = 3; 0 < i3; --i3) Ue(t4, e3 += 4, n3, r3);
      }
      function Ve(t4, e3, n3, r3, i3, a3, o3, s3) {
        for (a3 = 2 * a3 + 1; 0 < i3--; ) {
          if (Te(t4, e3, n3, a3, o3)) if (Re(t4, e3, n3, s3)) Ee(t4, e3, n3);
          else {
            var u4 = t4, c4 = e3, l4 = n3, h4 = u4[c4 - 2 * l4], f4 = u4[c4 - l4], d4 = u4[c4 + 0], p4 = u4[c4 + l4], g4 = u4[c4 + 2 * l4], m4 = 27 * (b4 = jr[1020 + 3 * (d4 - f4) + jr[1020 + h4 - p4]]) + 63 >> 7, v4 = 18 * b4 + 63 >> 7, b4 = 9 * b4 + 63 >> 7;
            u4[c4 - 3 * l4] = Or[255 + u4[c4 - 3 * l4] + b4], u4[c4 - 2 * l4] = Or[255 + h4 + v4], u4[c4 - l4] = Or[255 + f4 + m4], u4[c4 + 0] = Or[255 + d4 - m4], u4[c4 + l4] = Or[255 + p4 - v4], u4[c4 + 2 * l4] = Or[255 + g4 - b4];
          }
          e3 += r3;
        }
      }
      function Ge(t4, e3, n3, r3, i3, a3, o3, s3) {
        for (a3 = 2 * a3 + 1; 0 < i3--; ) {
          if (Te(t4, e3, n3, a3, o3)) if (Re(t4, e3, n3, s3)) Ee(t4, e3, n3);
          else {
            var u4 = t4, c4 = e3, l4 = n3, h4 = u4[c4 - l4], f4 = u4[c4 + 0], d4 = u4[c4 + l4], p4 = Cr[112 + (4 + (g4 = 3 * (f4 - h4)) >> 3)], g4 = Cr[112 + (g4 + 3 >> 3)], m4 = p4 + 1 >> 1;
            u4[c4 - 2 * l4] = Or[255 + u4[c4 - 2 * l4] + m4], u4[c4 - l4] = Or[255 + h4 + g4], u4[c4 + 0] = Or[255 + f4 - p4], u4[c4 + l4] = Or[255 + d4 - m4];
          }
          e3 += r3;
        }
      }
      function Ye(t4, e3, n3, r3, i3, a3) {
        Ve(t4, e3, n3, 1, 16, r3, i3, a3);
      }
      function Je(t4, e3, n3, r3, i3, a3) {
        Ve(t4, e3, 1, n3, 16, r3, i3, a3);
      }
      function Xe(t4, e3, n3, r3, i3, a3) {
        var o3;
        for (o3 = 3; 0 < o3; --o3) Ge(t4, e3 += 4 * n3, n3, 1, 16, r3, i3, a3);
      }
      function Ke(t4, e3, n3, r3, i3, a3) {
        var o3;
        for (o3 = 3; 0 < o3; --o3) Ge(t4, e3 += 4, 1, n3, 16, r3, i3, a3);
      }
      function Ze(t4, e3, n3, r3, i3, a3, o3, s3) {
        Ve(t4, e3, i3, 1, 8, a3, o3, s3), Ve(n3, r3, i3, 1, 8, a3, o3, s3);
      }
      function $e(t4, e3, n3, r3, i3, a3, o3, s3) {
        Ve(t4, e3, 1, i3, 8, a3, o3, s3), Ve(n3, r3, 1, i3, 8, a3, o3, s3);
      }
      function Qe(t4, e3, n3, r3, i3, a3, o3, s3) {
        Ge(t4, e3 + 4 * i3, i3, 1, 8, a3, o3, s3), Ge(n3, r3 + 4 * i3, i3, 1, 8, a3, o3, s3);
      }
      function tn(t4, e3, n3, r3, i3, a3, o3, s3) {
        Ge(t4, e3 + 4, 1, i3, 8, a3, o3, s3), Ge(n3, r3 + 4, 1, i3, 8, a3, o3, s3);
      }
      function en() {
        this.ba = new ot2(), this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new ut2(), this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc";
      }
      function nn() {
        this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0;
      }
      function rn() {
        this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0;
      }
      function an() {
        this.ua = 0, this.Wa = new M2(), this.vb = new M2(), this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new d3(), this.yc = new h3();
      }
      function on() {
        this.xb = this.a = 0, this.l = new Gt2(), this.ca = new ot2(), this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new N3(), this.Pb = 0, this.wd = new N3(), this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new an(), this.ab = 0, this.gc = o2(4, rn), this.Oc = 0;
      }
      function sn() {
        this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new Gt2(), this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0;
      }
      function un(t4, e3, n3, r3, i3, a3, o3) {
        for (t4 = null == t4 ? 0 : t4[e3 + 0], e3 = 0; e3 < o3; ++e3) i3[a3 + e3] = t4 + n3[r3 + e3] & 255, t4 = i3[a3 + e3];
      }
      function cn(t4, e3, n3, r3, i3, a3, o3) {
        var s3;
        if (null == t4) un(null, null, n3, r3, i3, a3, o3);
        else for (s3 = 0; s3 < o3; ++s3) i3[a3 + s3] = t4[e3 + s3] + n3[r3 + s3] & 255;
      }
      function ln2(t4, e3, n3, r3, i3, a3, o3) {
        if (null == t4) un(null, null, n3, r3, i3, a3, o3);
        else {
          var s3, u4 = t4[e3 + 0], c4 = u4, l4 = u4;
          for (s3 = 0; s3 < o3; ++s3) c4 = l4 + (u4 = t4[e3 + s3]) - c4, l4 = n3[r3 + s3] + (-256 & c4 ? 0 > c4 ? 0 : 255 : c4) & 255, c4 = u4, i3[a3 + s3] = l4;
        }
      }
      function hn(t4, n3, i3, o3) {
        var s3 = n3.width, u4 = n3.o;
        if (e2(null != t4 && null != n3), 0 > i3 || 0 >= o3 || i3 + o3 > u4) return null;
        if (!t4.Cc) {
          if (null == t4.ga) {
            var c4;
            if (t4.ga = new sn(), (c4 = null == t4.ga) || (c4 = n3.width * n3.o, e2(0 == t4.Gb.length), t4.Gb = a2(c4), t4.Uc = 0, null == t4.Gb ? c4 = 0 : (t4.mb = t4.Gb, t4.nb = t4.Uc, t4.rc = null, c4 = 1), c4 = !c4), !c4) {
              c4 = t4.ga;
              var l4 = t4.Fa, h4 = t4.P, f4 = t4.qc, d4 = t4.mb, p4 = t4.nb, g4 = h4 + 1, m4 = f4 - 1, b4 = c4.l;
              if (e2(null != l4 && null != d4 && null != n3), gi[0] = null, gi[1] = un, gi[2] = cn, gi[3] = ln2, c4.ca = d4, c4.tb = p4, c4.c = n3.width, c4.i = n3.height, e2(0 < c4.c && 0 < c4.i), 1 >= f4) n3 = 0;
              else if (c4.$a = 3 & l4[h4 + 0], c4.Z = l4[h4 + 0] >> 2 & 3, c4.Lc = l4[h4 + 0] >> 4 & 3, h4 = l4[h4 + 0] >> 6 & 3, 0 > c4.$a || 1 < c4.$a || 4 <= c4.Z || 1 < c4.Lc || h4) n3 = 0;
              else if (b4.put = dt2, b4.ac = ft2, b4.bc = pt2, b4.ma = c4, b4.width = n3.width, b4.height = n3.height, b4.Da = n3.Da, b4.v = n3.v, b4.va = n3.va, b4.j = n3.j, b4.o = n3.o, c4.$a) t: {
                e2(1 == c4.$a), n3 = kt2();
                e: for (; ; ) {
                  if (null == n3) {
                    n3 = 0;
                    break t;
                  }
                  if (e2(null != c4), c4.mc = n3, n3.c = c4.c, n3.i = c4.i, n3.l = c4.l, n3.l.ma = c4, n3.l.width = c4.c, n3.l.height = c4.i, n3.a = 0, v3(n3.m, l4, g4, m4), !Ft2(c4.c, c4.i, 1, n3, null)) break e;
                  if (1 == n3.ab && 3 == n3.gc[0].hc && xt2(n3.s) ? (c4.ic = 1, l4 = n3.c * n3.i, n3.Ta = null, n3.Ua = 0, n3.V = a2(l4), n3.Ba = 0, null == n3.V ? (n3.a = 1, n3 = 0) : n3 = 1) : (c4.ic = 0, n3 = It2(n3, c4.c)), !n3) break e;
                  n3 = 1;
                  break t;
                }
                c4.mc = null, n3 = 0;
              }
              else n3 = m4 >= c4.c * c4.i;
              c4 = !n3;
            }
            if (c4) return null;
            1 != t4.ga.Lc ? t4.Ga = 0 : o3 = u4 - i3;
          }
          e2(null != t4.ga), e2(i3 + o3 <= u4);
          t: {
            if (n3 = (l4 = t4.ga).c, u4 = l4.l.o, 0 == l4.$a) {
              if (g4 = t4.rc, m4 = t4.Vc, b4 = t4.Fa, h4 = t4.P + 1 + i3 * n3, f4 = t4.mb, d4 = t4.nb + i3 * n3, e2(h4 <= t4.P + t4.qc), 0 != l4.Z) for (e2(null != gi[l4.Z]), c4 = 0; c4 < o3; ++c4) gi[l4.Z](g4, m4, b4, h4, f4, d4, n3), g4 = f4, m4 = d4, d4 += n3, h4 += n3;
              else for (c4 = 0; c4 < o3; ++c4) r2(f4, d4, b4, h4, n3), g4 = f4, m4 = d4, d4 += n3, h4 += n3;
              t4.rc = g4, t4.Vc = m4;
            } else {
              if (e2(null != l4.mc), n3 = i3 + o3, e2(null != (c4 = l4.mc)), e2(n3 <= c4.i), c4.C >= n3) n3 = 1;
              else if (l4.ic || mn(), l4.ic) {
                l4 = c4.V, g4 = c4.Ba, m4 = c4.c;
                var y4 = c4.i, w4 = (b4 = 1, h4 = c4.$ / m4, f4 = c4.$ % m4, d4 = c4.m, p4 = c4.s, c4.$), N4 = m4 * y4, L4 = m4 * n3, A4 = p4.wc, _3 = w4 < L4 ? wt2(p4, f4, h4) : null;
                e2(w4 <= N4), e2(n3 <= y4), e2(xt2(p4));
                e: for (; ; ) {
                  for (; !d4.h && w4 < L4; ) {
                    if (f4 & A4 || (_3 = wt2(p4, f4, h4)), e2(null != _3), S2(d4), 256 > (y4 = bt2(_3.G[0], _3.H[0], d4))) l4[g4 + w4] = y4, ++w4, ++f4 >= m4 && (f4 = 0, ++h4 <= n3 && !(h4 % 16) && St(c4, h4));
                    else {
                      if (!(280 > y4)) {
                        b4 = 0;
                        break e;
                      }
                      y4 = mt2(y4 - 256, d4);
                      var P3, k3 = bt2(_3.G[4], _3.H[4], d4);
                      if (S2(d4), !(w4 >= (k3 = vt2(m4, k3 = mt2(k3, d4))) && N4 - w4 >= y4)) {
                        b4 = 0;
                        break e;
                      }
                      for (P3 = 0; P3 < y4; ++P3) l4[g4 + w4 + P3] = l4[g4 + w4 + P3 - k3];
                      for (w4 += y4, f4 += y4; f4 >= m4; ) f4 -= m4, ++h4 <= n3 && !(h4 % 16) && St(c4, h4);
                      w4 < L4 && f4 & A4 && (_3 = wt2(p4, f4, h4));
                    }
                    e2(d4.h == x3(d4));
                  }
                  St(c4, h4 > n3 ? n3 : h4);
                  break e;
                }
                !b4 || d4.h && w4 < N4 ? (b4 = 0, c4.a = d4.h ? 5 : 3) : c4.$ = w4, n3 = b4;
              } else n3 = _t2(c4, c4.V, c4.Ba, c4.c, c4.i, n3, jt2);
              if (!n3) {
                o3 = 0;
                break t;
              }
            }
            i3 + o3 >= u4 && (t4.Cc = 1), o3 = 1;
          }
          if (!o3) return null;
          if (t4.Cc && (null != (o3 = t4.ga) && (o3.mc = null), t4.ga = null, 0 < t4.Ga)) return alert("todo:WebPDequantizeLevels"), null;
        }
        return t4.nb + i3 * s3;
      }
      function fn(t4, e3, n3, r3, i3, a3) {
        for (; 0 < i3--; ) {
          var o3, s3 = t4, u4 = e3 + (n3 ? 1 : 0), c4 = t4, l4 = e3 + (n3 ? 0 : 3);
          for (o3 = 0; o3 < r3; ++o3) {
            var h4 = c4[l4 + 4 * o3];
            255 != h4 && (h4 *= 32897, s3[u4 + 4 * o3 + 0] = s3[u4 + 4 * o3 + 0] * h4 >> 23, s3[u4 + 4 * o3 + 1] = s3[u4 + 4 * o3 + 1] * h4 >> 23, s3[u4 + 4 * o3 + 2] = s3[u4 + 4 * o3 + 2] * h4 >> 23);
          }
          e3 += a3;
        }
      }
      function dn(t4, e3, n3, r3, i3) {
        for (; 0 < r3--; ) {
          var a3;
          for (a3 = 0; a3 < n3; ++a3) {
            var o3 = t4[e3 + 2 * a3 + 0], s3 = 15 & (c4 = t4[e3 + 2 * a3 + 1]), u4 = 4369 * s3, c4 = (240 & c4 | c4 >> 4) * u4 >> 16;
            t4[e3 + 2 * a3 + 0] = (240 & o3 | o3 >> 4) * u4 >> 16 & 240 | (15 & o3 | o3 << 4) * u4 >> 16 >> 4 & 15, t4[e3 + 2 * a3 + 1] = 240 & c4 | s3;
          }
          e3 += i3;
        }
      }
      function pn(t4, e3, n3, r3, i3, a3, o3, s3) {
        var u4, c4, l4 = 255;
        for (c4 = 0; c4 < i3; ++c4) {
          for (u4 = 0; u4 < r3; ++u4) {
            var h4 = t4[e3 + u4];
            a3[o3 + 4 * u4] = h4, l4 &= h4;
          }
          e3 += n3, o3 += s3;
        }
        return 255 != l4;
      }
      function gn(t4, e3, n3, r3, i3) {
        var a3;
        for (a3 = 0; a3 < i3; ++a3) n3[r3 + a3] = t4[e3 + a3] >> 8;
      }
      function mn() {
        Lr = fn, xr = dn, Ar = pn, Sr = gn;
      }
      function vn(n3, r3, i3) {
        t3[n3] = function(t4, n4, a3, o3, s3, u4, c4, l4, h4, f4, d4, p4, g4, m4, v4, b4, y4) {
          var w4, N4 = y4 - 1 >> 1, L4 = s3[u4 + 0] | c4[l4 + 0] << 16, x4 = h4[f4 + 0] | d4[p4 + 0] << 16;
          e2(null != t4);
          var A4 = 3 * L4 + x4 + 131074 >> 2;
          for (r3(t4[n4 + 0], 255 & A4, A4 >> 16, g4, m4), null != a3 && (A4 = 3 * x4 + L4 + 131074 >> 2, r3(a3[o3 + 0], 255 & A4, A4 >> 16, v4, b4)), w4 = 1; w4 <= N4; ++w4) {
            var S3 = s3[u4 + w4] | c4[l4 + w4] << 16, _3 = h4[f4 + w4] | d4[p4 + w4] << 16, P3 = L4 + S3 + x4 + _3 + 524296, k3 = P3 + 2 * (S3 + x4) >> 3;
            A4 = k3 + L4 >> 1, L4 = (P3 = P3 + 2 * (L4 + _3) >> 3) + S3 >> 1, r3(t4[n4 + 2 * w4 - 1], 255 & A4, A4 >> 16, g4, m4 + (2 * w4 - 1) * i3), r3(t4[n4 + 2 * w4 - 0], 255 & L4, L4 >> 16, g4, m4 + (2 * w4 - 0) * i3), null != a3 && (A4 = P3 + x4 >> 1, L4 = k3 + _3 >> 1, r3(a3[o3 + 2 * w4 - 1], 255 & A4, A4 >> 16, v4, b4 + (2 * w4 - 1) * i3), r3(a3[o3 + 2 * w4 + 0], 255 & L4, L4 >> 16, v4, b4 + (2 * w4 + 0) * i3)), L4 = S3, x4 = _3;
          }
          1 & y4 || (A4 = 3 * L4 + x4 + 131074 >> 2, r3(t4[n4 + y4 - 1], 255 & A4, A4 >> 16, g4, m4 + (y4 - 1) * i3), null != a3 && (A4 = 3 * x4 + L4 + 131074 >> 2, r3(a3[o3 + y4 - 1], 255 & A4, A4 >> 16, v4, b4 + (y4 - 1) * i3)));
        };
      }
      function bn() {
        mi[Mr] = vi, mi[qr] = yi, mi[Er] = bi, mi[Rr] = wi, mi[Dr] = Ni, mi[Tr] = Li, mi[zr] = xi, mi[Ur] = yi, mi[Hr] = wi, mi[Wr] = Ni, mi[Vr] = Li;
      }
      function yn(t4) {
        return t4 & -16384 ? 0 > t4 ? 0 : 255 : t4 >> ki;
      }
      function wn(t4, e3) {
        return yn((19077 * t4 >> 8) + (26149 * e3 >> 8) - 14234);
      }
      function Nn(t4, e3, n3) {
        return yn((19077 * t4 >> 8) - (6419 * e3 >> 8) - (13320 * n3 >> 8) + 8708);
      }
      function Ln(t4, e3) {
        return yn((19077 * t4 >> 8) + (33050 * e3 >> 8) - 17685);
      }
      function xn(t4, e3, n3, r3, i3) {
        r3[i3 + 0] = wn(t4, n3), r3[i3 + 1] = Nn(t4, e3, n3), r3[i3 + 2] = Ln(t4, e3);
      }
      function An(t4, e3, n3, r3, i3) {
        r3[i3 + 0] = Ln(t4, e3), r3[i3 + 1] = Nn(t4, e3, n3), r3[i3 + 2] = wn(t4, n3);
      }
      function Sn(t4, e3, n3, r3, i3) {
        var a3 = Nn(t4, e3, n3);
        e3 = a3 << 3 & 224 | Ln(t4, e3) >> 3, r3[i3 + 0] = 248 & wn(t4, n3) | a3 >> 5, r3[i3 + 1] = e3;
      }
      function _n(t4, e3, n3, r3, i3) {
        var a3 = 240 & Ln(t4, e3) | 15;
        r3[i3 + 0] = 240 & wn(t4, n3) | Nn(t4, e3, n3) >> 4, r3[i3 + 1] = a3;
      }
      function Pn(t4, e3, n3, r3, i3) {
        r3[i3 + 0] = 255, xn(t4, e3, n3, r3, i3 + 1);
      }
      function kn(t4, e3, n3, r3, i3) {
        An(t4, e3, n3, r3, i3), r3[i3 + 3] = 255;
      }
      function Fn(t4, e3, n3, r3, i3) {
        xn(t4, e3, n3, r3, i3), r3[i3 + 3] = 255;
      }
      function In(e3, n3, r3) {
        t3[e3] = function(t4, e4, i3, a3, o3, s3, u4, c4, l4) {
          for (var h4 = c4 + (-2 & l4) * r3; c4 != h4; ) n3(t4[e4 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4), n3(t4[e4 + 1], i3[a3 + 0], o3[s3 + 0], u4, c4 + r3), e4 += 2, ++a3, ++s3, c4 += 2 * r3;
          1 & l4 && n3(t4[e4 + 0], i3[a3 + 0], o3[s3 + 0], u4, c4);
        };
      }
      function jn(t4, e3, n3) {
        return 0 == n3 ? 0 == t4 ? 0 == e3 ? 6 : 5 : 0 == e3 ? 4 : 0 : n3;
      }
      function Cn(t4, e3, n3, r3, i3) {
        switch (t4 >>> 30) {
          case 3:
            ar(e3, n3, r3, i3, 0);
            break;
          case 2:
            or(e3, n3, r3, i3);
            break;
          case 1:
            ur(e3, n3, r3, i3);
        }
      }
      function On(t4, e3) {
        var n3, a3, o3 = e3.M, s3 = e3.Nb, u4 = t4.oc, c4 = t4.pc + 40, l4 = t4.oc, h4 = t4.pc + 584, f4 = t4.oc, d4 = t4.pc + 600;
        for (n3 = 0; 16 > n3; ++n3) u4[c4 + 32 * n3 - 1] = 129;
        for (n3 = 0; 8 > n3; ++n3) l4[h4 + 32 * n3 - 1] = 129, f4[d4 + 32 * n3 - 1] = 129;
        for (0 < o3 ? u4[c4 - 1 - 32] = l4[h4 - 1 - 32] = f4[d4 - 1 - 32] = 129 : (i2(u4, c4 - 32 - 1, 127, 21), i2(l4, h4 - 32 - 1, 127, 9), i2(f4, d4 - 32 - 1, 127, 9)), a3 = 0; a3 < t4.za; ++a3) {
          var p4 = e3.ya[e3.aa + a3];
          if (0 < a3) {
            for (n3 = -1; 16 > n3; ++n3) r2(u4, c4 + 32 * n3 - 4, u4, c4 + 32 * n3 + 12, 4);
            for (n3 = -1; 8 > n3; ++n3) r2(l4, h4 + 32 * n3 - 4, l4, h4 + 32 * n3 + 4, 4), r2(f4, d4 + 32 * n3 - 4, f4, d4 + 32 * n3 + 4, 4);
          }
          var g4 = t4.Gd, m4 = t4.Hd + a3, v4 = p4.ad, b4 = p4.Hc;
          if (0 < o3 && (r2(u4, c4 - 32, g4[m4].y, 0, 16), r2(l4, h4 - 32, g4[m4].f, 0, 8), r2(f4, d4 - 32, g4[m4].ea, 0, 8)), p4.Za) {
            var y4 = u4, w4 = c4 - 32 + 16;
            for (0 < o3 && (a3 >= t4.za - 1 ? i2(y4, w4, g4[m4].y[15], 4) : r2(y4, w4, g4[m4 + 1].y, 0, 4)), n3 = 0; 4 > n3; n3++) y4[w4 + 128 + n3] = y4[w4 + 256 + n3] = y4[w4 + 384 + n3] = y4[w4 + 0 + n3];
            for (n3 = 0; 16 > n3; ++n3, b4 <<= 2) y4 = u4, w4 = c4 + Ei[n3], hi[p4.Ob[n3]](y4, w4), Cn(b4, v4, 16 * +n3, y4, w4);
          } else if (y4 = jn(a3, o3, p4.Ob[0]), li[y4](u4, c4), 0 != b4) for (n3 = 0; 16 > n3; ++n3, b4 <<= 2) Cn(b4, v4, 16 * +n3, u4, c4 + Ei[n3]);
          for (n3 = p4.Gc, y4 = jn(a3, o3, p4.Dd), fi[y4](l4, h4), fi[y4](f4, d4), b4 = v4, y4 = l4, w4 = h4, 255 & (p4 = 0 | n3) && (170 & p4 ? sr(b4, 256, y4, w4) : cr(b4, 256, y4, w4)), p4 = f4, b4 = d4, 255 & (n3 >>= 8) && (170 & n3 ? sr(v4, 320, p4, b4) : cr(v4, 320, p4, b4)), o3 < t4.Ub - 1 && (r2(g4[m4].y, 0, u4, c4 + 480, 16), r2(g4[m4].f, 0, l4, h4 + 224, 8), r2(g4[m4].ea, 0, f4, d4 + 224, 8)), n3 = 8 * s3 * t4.B, g4 = t4.sa, m4 = t4.ta + 16 * a3 + 16 * s3 * t4.R, v4 = t4.qa, p4 = t4.ra + 8 * a3 + n3, b4 = t4.Ha, y4 = t4.Ia + 8 * a3 + n3, n3 = 0; 16 > n3; ++n3) r2(g4, m4 + n3 * t4.R, u4, c4 + 32 * n3, 16);
          for (n3 = 0; 8 > n3; ++n3) r2(v4, p4 + n3 * t4.B, l4, h4 + 32 * n3, 8), r2(b4, y4 + n3 * t4.B, f4, d4 + 32 * n3, 8);
        }
      }
      function Bn(t4, r3, i3, a3, o3, s3, u4, c4, l4) {
        var h4 = [0], f4 = [0], d4 = 0, p4 = null != l4 ? l4.kd : 0, g4 = null != l4 ? l4 : new nn();
        if (null == t4 || 12 > i3) return 7;
        g4.data = t4, g4.w = r3, g4.ha = i3, r3 = [r3], i3 = [i3], g4.gb = [g4.gb];
        t: {
          var m4 = r3, b4 = i3, y4 = g4.gb;
          if (e2(null != t4), e2(null != b4), e2(null != y4), y4[0] = 0, 12 <= b4[0] && !n2(t4, m4[0], "RIFF")) {
            if (n2(t4, m4[0] + 8, "WEBP")) {
              y4 = 3;
              break t;
            }
            var w4 = C2(t4, m4[0] + 4);
            if (12 > w4 || 4294967286 < w4) {
              y4 = 3;
              break t;
            }
            if (p4 && w4 > b4[0] - 8) {
              y4 = 7;
              break t;
            }
            y4[0] = w4, m4[0] += 12, b4[0] -= 12;
          }
          y4 = 0;
        }
        if (0 != y4) return y4;
        for (w4 = 0 < g4.gb[0], i3 = i3[0]; ; ) {
          t: {
            var L4 = t4;
            b4 = r3, y4 = i3;
            var x4 = h4, A4 = f4, S3 = m4 = [0];
            if ((k3 = d4 = [d4])[0] = 0, 8 > y4[0]) y4 = 7;
            else {
              if (!n2(L4, b4[0], "VP8X")) {
                if (10 != C2(L4, b4[0] + 4)) {
                  y4 = 3;
                  break t;
                }
                if (18 > y4[0]) {
                  y4 = 7;
                  break t;
                }
                var _3 = C2(L4, b4[0] + 8), P3 = 1 + j2(L4, b4[0] + 12);
                if (2147483648 <= P3 * (L4 = 1 + j2(L4, b4[0] + 15))) {
                  y4 = 3;
                  break t;
                }
                null != S3 && (S3[0] = _3), null != x4 && (x4[0] = P3), null != A4 && (A4[0] = L4), b4[0] += 18, y4[0] -= 18, k3[0] = 1;
              }
              y4 = 0;
            }
          }
          if (d4 = d4[0], m4 = m4[0], 0 != y4) return y4;
          if (b4 = !!(2 & m4), !w4 && d4) return 3;
          if (null != s3 && (s3[0] = !!(16 & m4)), null != u4 && (u4[0] = b4), null != c4 && (c4[0] = 0), u4 = h4[0], m4 = f4[0], d4 && b4 && null == l4) {
            y4 = 0;
            break;
          }
          if (4 > i3) {
            y4 = 7;
            break;
          }
          if (w4 && d4 || !w4 && !d4 && !n2(t4, r3[0], "ALPH")) {
            i3 = [i3], g4.na = [g4.na], g4.P = [g4.P], g4.Sa = [g4.Sa];
            t: {
              _3 = t4, y4 = r3, w4 = i3;
              var k3 = g4.gb;
              x4 = g4.na, A4 = g4.P, S3 = g4.Sa, P3 = 22, e2(null != _3), e2(null != w4), L4 = y4[0];
              var F3 = w4[0];
              for (e2(null != x4), e2(null != S3), x4[0] = null, A4[0] = null, S3[0] = 0; ; ) {
                if (y4[0] = L4, w4[0] = F3, 8 > F3) {
                  y4 = 7;
                  break t;
                }
                var I3 = C2(_3, L4 + 4);
                if (4294967286 < I3) {
                  y4 = 3;
                  break t;
                }
                var O3 = 8 + I3 + 1 & -2;
                if (P3 += O3, 0 < k3 && P3 > k3) {
                  y4 = 3;
                  break t;
                }
                if (!n2(_3, L4, "VP8 ") || !n2(_3, L4, "VP8L")) {
                  y4 = 0;
                  break t;
                }
                if (F3[0] < O3) {
                  y4 = 7;
                  break t;
                }
                n2(_3, L4, "ALPH") || (x4[0] = _3, A4[0] = L4 + 8, S3[0] = I3), L4 += O3, F3 -= O3;
              }
            }
            if (i3 = i3[0], g4.na = g4.na[0], g4.P = g4.P[0], g4.Sa = g4.Sa[0], 0 != y4) break;
          }
          i3 = [i3], g4.Ja = [g4.Ja], g4.xa = [g4.xa];
          t: if (k3 = t4, y4 = r3, w4 = i3, x4 = g4.gb[0], A4 = g4.Ja, S3 = g4.xa, _3 = y4[0], L4 = !n2(k3, _3, "VP8 "), P3 = !n2(k3, _3, "VP8L"), e2(null != k3), e2(null != w4), e2(null != A4), e2(null != S3), 8 > w4[0]) y4 = 7;
          else {
            if (L4 || P3) {
              if (k3 = C2(k3, _3 + 4), 12 <= x4 && k3 > x4 - 12) {
                y4 = 3;
                break t;
              }
              if (p4 && k3 > w4[0] - 8) {
                y4 = 7;
                break t;
              }
              A4[0] = k3, y4[0] += 8, w4[0] -= 8, S3[0] = P3;
            } else S3[0] = 5 <= w4[0] && 47 == k3[_3 + 0] && !(k3[_3 + 4] >> 5), A4[0] = w4[0];
            y4 = 0;
          }
          if (i3 = i3[0], g4.Ja = g4.Ja[0], g4.xa = g4.xa[0], r3 = r3[0], 0 != y4) break;
          if (4294967286 < g4.Ja) return 3;
          if (null == c4 || b4 || (c4[0] = g4.xa ? 2 : 1), u4 = [u4], m4 = [m4], g4.xa) {
            if (5 > i3) {
              y4 = 7;
              break;
            }
            c4 = u4, p4 = m4, b4 = s3, null == t4 || 5 > i3 ? t4 = 0 : 5 <= i3 && 47 == t4[r3 + 0] && !(t4[r3 + 4] >> 5) ? (w4 = [0], k3 = [0], x4 = [0], v3(A4 = new N3(), t4, r3, i3), gt2(A4, w4, k3, x4) ? (null != c4 && (c4[0] = w4[0]), null != p4 && (p4[0] = k3[0]), null != b4 && (b4[0] = x4[0]), t4 = 1) : t4 = 0) : t4 = 0;
          } else {
            if (10 > i3) {
              y4 = 7;
              break;
            }
            c4 = m4, null == t4 || 10 > i3 || !Xt2(t4, r3 + 3, i3 - 3) ? t4 = 0 : (p4 = t4[r3 + 0] | t4[r3 + 1] << 8 | t4[r3 + 2] << 16, b4 = 16383 & (t4[r3 + 7] << 8 | t4[r3 + 6]), t4 = 16383 & (t4[r3 + 9] << 8 | t4[r3 + 8]), 1 & p4 || 3 < (p4 >> 1 & 7) || !(p4 >> 4 & 1) || p4 >> 5 >= g4.Ja || !b4 || !t4 ? t4 = 0 : (u4 && (u4[0] = b4), c4 && (c4[0] = t4), t4 = 1));
          }
          if (!t4) return 3;
          if (u4 = u4[0], m4 = m4[0], d4 && (h4[0] != u4 || f4[0] != m4)) return 3;
          null != l4 && (l4[0] = g4, l4.offset = r3 - l4.w, e2(4294967286 > r3 - l4.w), e2(l4.offset == l4.ha - i3));
          break;
        }
        return 0 == y4 || 7 == y4 && d4 && null == l4 ? (null != s3 && (s3[0] |= null != g4.na && 0 < g4.na.length), null != a3 && (a3[0] = u4), null != o3 && (o3[0] = m4), 0) : y4;
      }
      function Mn(t4, e3, n3) {
        var r3 = e3.width, i3 = e3.height, a3 = 0, o3 = 0, s3 = r3, u4 = i3;
        if (e3.Da = null != t4 && 0 < t4.Da, e3.Da && (s3 = t4.cd, u4 = t4.bd, a3 = t4.v, o3 = t4.j, 11 > n3 || (a3 &= -2, o3 &= -2), 0 > a3 || 0 > o3 || 0 >= s3 || 0 >= u4 || a3 + s3 > r3 || o3 + u4 > i3)) return 0;
        if (e3.v = a3, e3.j = o3, e3.va = a3 + s3, e3.o = o3 + u4, e3.U = s3, e3.T = u4, e3.da = null != t4 && 0 < t4.da, e3.da) {
          if (!q2(s3, u4, n3 = [t4.ib], a3 = [t4.hb])) return 0;
          e3.ib = n3[0], e3.hb = a3[0];
        }
        return e3.ob = null != t4 && t4.ob, e3.Kb = null == t4 || !t4.Sd, e3.da && (e3.ob = e3.ib < 3 * r3 / 4 && e3.hb < 3 * i3 / 4, e3.Kb = 0), 1;
      }
      function qn(t4) {
        if (null == t4) return 2;
        if (11 > t4.S) {
          var e3 = t4.f.RGBA;
          e3.fb += (t4.height - 1) * e3.A, e3.A = -e3.A;
        } else e3 = t4.f.kb, t4 = t4.height, e3.O += (t4 - 1) * e3.fa, e3.fa = -e3.fa, e3.N += (t4 - 1 >> 1) * e3.Ab, e3.Ab = -e3.Ab, e3.W += (t4 - 1 >> 1) * e3.Db, e3.Db = -e3.Db, null != e3.F && (e3.J += (t4 - 1) * e3.lb, e3.lb = -e3.lb);
        return 0;
      }
      function En(t4, e3, n3, r3) {
        if (null == r3 || 0 >= t4 || 0 >= e3) return 2;
        if (null != n3) {
          if (n3.Da) {
            var i3 = n3.cd, o3 = n3.bd, s3 = -2 & n3.v, u4 = -2 & n3.j;
            if (0 > s3 || 0 > u4 || 0 >= i3 || 0 >= o3 || s3 + i3 > t4 || u4 + o3 > e3) return 2;
            t4 = i3, e3 = o3;
          }
          if (n3.da) {
            if (!q2(t4, e3, i3 = [n3.ib], o3 = [n3.hb])) return 2;
            t4 = i3[0], e3 = o3[0];
          }
        }
        r3.width = t4, r3.height = e3;
        t: {
          var c4 = r3.width, l4 = r3.height;
          if (t4 = r3.S, 0 >= c4 || 0 >= l4 || !(t4 >= Mr && 13 > t4)) t4 = 2;
          else {
            if (0 >= r3.Rd && null == r3.sd) {
              s3 = o3 = i3 = e3 = 0;
              var h4 = (u4 = c4 * zi[t4]) * l4;
              if (11 > t4 || (o3 = (l4 + 1) / 2 * (e3 = (c4 + 1) / 2), 12 == t4 && (s3 = (i3 = c4) * l4)), null == (l4 = a2(h4 + 2 * o3 + s3))) {
                t4 = 1;
                break t;
              }
              r3.sd = l4, 11 > t4 ? ((c4 = r3.f.RGBA).eb = l4, c4.fb = 0, c4.A = u4, c4.size = h4) : ((c4 = r3.f.kb).y = l4, c4.O = 0, c4.fa = u4, c4.Fd = h4, c4.f = l4, c4.N = 0 + h4, c4.Ab = e3, c4.Cd = o3, c4.ea = l4, c4.W = 0 + h4 + o3, c4.Db = e3, c4.Ed = o3, 12 == t4 && (c4.F = l4, c4.J = 0 + h4 + 2 * o3), c4.Tc = s3, c4.lb = i3);
            }
            if (e3 = 1, i3 = r3.S, o3 = r3.width, s3 = r3.height, i3 >= Mr && 13 > i3) if (11 > i3) t4 = r3.f.RGBA, e3 &= (u4 = Math.abs(t4.A)) * (s3 - 1) + o3 <= t4.size, e3 &= u4 >= o3 * zi[i3], e3 &= null != t4.eb;
            else {
              t4 = r3.f.kb, u4 = (o3 + 1) / 2, h4 = (s3 + 1) / 2, c4 = Math.abs(t4.fa), l4 = Math.abs(t4.Ab);
              var f4 = Math.abs(t4.Db), d4 = Math.abs(t4.lb), p4 = d4 * (s3 - 1) + o3;
              e3 &= c4 * (s3 - 1) + o3 <= t4.Fd, e3 &= l4 * (h4 - 1) + u4 <= t4.Cd, e3 = (e3 &= f4 * (h4 - 1) + u4 <= t4.Ed) & c4 >= o3 & l4 >= u4 & f4 >= u4, e3 &= null != t4.y, e3 &= null != t4.f, e3 &= null != t4.ea, 12 == i3 && (e3 &= d4 >= o3, e3 &= p4 <= t4.Tc, e3 &= null != t4.F);
            }
            else e3 = 0;
            t4 = e3 ? 0 : 2;
          }
        }
        return 0 != t4 || null != n3 && n3.fd && (t4 = qn(r3)), t4;
      }
      var Rn = 64, Dn = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], Tn = 24, zn = 32, Un = 8, Hn = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7];
      D2("Predictor0", "PredictorAdd0"), t3.Predictor0 = function() {
        return 4278190080;
      }, t3.Predictor1 = function(t4) {
        return t4;
      }, t3.Predictor2 = function(t4, e3, n3) {
        return e3[n3 + 0];
      }, t3.Predictor3 = function(t4, e3, n3) {
        return e3[n3 + 1];
      }, t3.Predictor4 = function(t4, e3, n3) {
        return e3[n3 - 1];
      }, t3.Predictor5 = function(t4, e3, n3) {
        return z2(z2(t4, e3[n3 + 1]), e3[n3 + 0]);
      }, t3.Predictor6 = function(t4, e3, n3) {
        return z2(t4, e3[n3 - 1]);
      }, t3.Predictor7 = function(t4, e3, n3) {
        return z2(t4, e3[n3 + 0]);
      }, t3.Predictor8 = function(t4, e3, n3) {
        return z2(e3[n3 - 1], e3[n3 + 0]);
      }, t3.Predictor9 = function(t4, e3, n3) {
        return z2(e3[n3 + 0], e3[n3 + 1]);
      }, t3.Predictor10 = function(t4, e3, n3) {
        return z2(z2(t4, e3[n3 - 1]), z2(e3[n3 + 0], e3[n3 + 1]));
      }, t3.Predictor11 = function(t4, e3, n3) {
        var r3 = e3[n3 + 0];
        return 0 >= W2(r3 >> 24 & 255, t4 >> 24 & 255, (e3 = e3[n3 - 1]) >> 24 & 255) + W2(r3 >> 16 & 255, t4 >> 16 & 255, e3 >> 16 & 255) + W2(r3 >> 8 & 255, t4 >> 8 & 255, e3 >> 8 & 255) + W2(255 & r3, 255 & t4, 255 & e3) ? r3 : t4;
      }, t3.Predictor12 = function(t4, e3, n3) {
        var r3 = e3[n3 + 0];
        return (U2((t4 >> 24 & 255) + (r3 >> 24 & 255) - ((e3 = e3[n3 - 1]) >> 24 & 255)) << 24 | U2((t4 >> 16 & 255) + (r3 >> 16 & 255) - (e3 >> 16 & 255)) << 16 | U2((t4 >> 8 & 255) + (r3 >> 8 & 255) - (e3 >> 8 & 255)) << 8 | U2((255 & t4) + (255 & r3) - (255 & e3))) >>> 0;
      }, t3.Predictor13 = function(t4, e3, n3) {
        var r3 = e3[n3 - 1];
        return (H4((t4 = z2(t4, e3[n3 + 0])) >> 24 & 255, r3 >> 24 & 255) << 24 | H4(t4 >> 16 & 255, r3 >> 16 & 255) << 16 | H4(t4 >> 8 & 255, r3 >> 8 & 255) << 8 | H4(255 & t4, 255 & r3)) >>> 0;
      };
      var Wn = t3.PredictorAdd0;
      t3.PredictorAdd1 = V2, D2("Predictor2", "PredictorAdd2"), D2("Predictor3", "PredictorAdd3"), D2("Predictor4", "PredictorAdd4"), D2("Predictor5", "PredictorAdd5"), D2("Predictor6", "PredictorAdd6"), D2("Predictor7", "PredictorAdd7"), D2("Predictor8", "PredictorAdd8"), D2("Predictor9", "PredictorAdd9"), D2("Predictor10", "PredictorAdd10"), D2("Predictor11", "PredictorAdd11"), D2("Predictor12", "PredictorAdd12"), D2("Predictor13", "PredictorAdd13");
      var Vn = t3.PredictorAdd2;
      X2("ColorIndexInverseTransform", "MapARGB", "32b", function(t4) {
        return t4 >> 8 & 255;
      }, function(t4) {
        return t4;
      }), X2("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function(t4) {
        return t4;
      }, function(t4) {
        return t4 >> 8 & 255;
      });
      var Gn, Yn = t3.ColorIndexInverseTransform, Jn = t3.MapARGB, Xn = t3.VP8LColorIndexInverseTransformAlpha, Kn = t3.MapAlpha, Zn = t3.VP8LPredictorsAdd = [];
      Zn.length = 16, (t3.VP8LPredictors = []).length = 16, (t3.VP8LPredictorsAdd_C = []).length = 16, (t3.VP8LPredictors_C = []).length = 16;
      var $n, Qn, tr, er, nr, rr, ir, ar, or, sr, ur, cr, lr, hr, fr, dr, pr, gr, mr, vr, br, yr, wr, Nr, Lr, xr, Ar, Sr, _r = a2(511), Pr = a2(2041), kr = a2(225), Fr = a2(767), Ir = 0, jr = Pr, Cr = kr, Or = Fr, Br = _r, Mr = 0, qr = 1, Er = 2, Rr = 3, Dr = 4, Tr = 5, zr = 6, Ur = 7, Hr = 8, Wr = 9, Vr = 10, Gr = [2, 3, 7], Yr = [3, 3, 11], Jr = [280, 256, 256, 256, 40], Xr = [0, 1, 1, 1, 0], Kr = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], Zr = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], $r = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Qr = 8, ti = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], ei = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], ni = null, ri = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], ii = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], ai = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], oi = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], si = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], ui = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], ci = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], li = [], hi = [], fi = [], di = 1, pi = 2, gi = [], mi = [];
      vn("UpsampleRgbLinePair", xn, 3), vn("UpsampleBgrLinePair", An, 3), vn("UpsampleRgbaLinePair", Fn, 4), vn("UpsampleBgraLinePair", kn, 4), vn("UpsampleArgbLinePair", Pn, 4), vn("UpsampleRgba4444LinePair", _n, 2), vn("UpsampleRgb565LinePair", Sn, 2);
      var vi = t3.UpsampleRgbLinePair, bi = t3.UpsampleBgrLinePair, yi = t3.UpsampleRgbaLinePair, wi = t3.UpsampleBgraLinePair, Ni = t3.UpsampleArgbLinePair, Li = t3.UpsampleRgba4444LinePair, xi = t3.UpsampleRgb565LinePair, Ai = 16, Si = 1 << Ai - 1, _i = -227, Pi = 482, ki = 6, Ii = 0, ji = a2(256), Ci = a2(256), Oi = a2(256), Bi = a2(256), Mi = a2(Pi - _i), qi = a2(Pi - _i);
      In("YuvToRgbRow", xn, 3), In("YuvToBgrRow", An, 3), In("YuvToRgbaRow", Fn, 4), In("YuvToBgraRow", kn, 4), In("YuvToArgbRow", Pn, 4), In("YuvToRgba4444Row", _n, 2), In("YuvToRgb565Row", Sn, 2);
      var Ei = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], Ri = [0, 2, 8], Di = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], Ti = 1;
      this.WebPDecodeRGBA = function(t4, n3, s3, u4, c4) {
        var l4 = qr, h4 = new en(), f4 = new ot2();
        h4.ba = f4, f4.S = l4, f4.width = [f4.width], f4.height = [f4.height];
        var d4 = f4.width, p4 = f4.height, g4 = new st2();
        if (null == g4 || null == t4) var m4 = 2;
        else e2(null != g4), m4 = Bn(t4, n3, s3, g4.width, g4.height, g4.Pd, g4.Qd, g4.format, null);
        if (0 != m4 ? d4 = 0 : (null != d4 && (d4[0] = g4.width[0]), null != p4 && (p4[0] = g4.height[0]), d4 = 1), d4) {
          f4.width = f4.width[0], f4.height = f4.height[0], null != u4 && (u4[0] = f4.width), null != c4 && (c4[0] = f4.height);
          t: {
            if (u4 = new Gt2(), (c4 = new nn()).data = t4, c4.w = n3, c4.ha = s3, c4.kd = 1, n3 = [0], e2(null != c4), (0 == (t4 = Bn(c4.data, c4.w, c4.ha, null, null, null, n3, null, c4)) || 7 == t4) && n3[0] && (t4 = 4), 0 == (n3 = t4)) {
              if (e2(null != h4), u4.data = c4.data, u4.w = c4.w + c4.offset, u4.ha = c4.ha - c4.offset, u4.put = dt2, u4.ac = ft2, u4.bc = pt2, u4.ma = h4, c4.xa) {
                if (null == (t4 = kt2())) {
                  h4 = 1;
                  break t;
                }
                if ((function(t5, n4) {
                  var r3 = [0], i3 = [0], a3 = [0];
                  e: for (; ; ) {
                    if (null == t5) return 0;
                    if (null == n4) return t5.a = 2, 0;
                    if (t5.l = n4, t5.a = 0, v3(t5.m, n4.data, n4.w, n4.ha), !gt2(t5.m, r3, i3, a3)) {
                      t5.a = 3;
                      break e;
                    }
                    if (t5.xb = pi, n4.width = r3[0], n4.height = i3[0], !Ft2(r3[0], i3[0], 1, t5, null)) break e;
                    return 1;
                  }
                  return e2(0 != t5.a), 0;
                })(t4, u4)) {
                  if (u4 = 0 == (n3 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                    e: {
                      u4 = t4;
                      n: for (; ; ) {
                        if (null == u4) {
                          u4 = 0;
                          break e;
                        }
                        if (e2(null != u4.s.yc), e2(null != u4.s.Ya), e2(0 < u4.s.Wb), e2(null != (s3 = u4.l)), e2(null != (c4 = s3.ma)), 0 != u4.xb) {
                          if (u4.ca = c4.ba, u4.tb = c4.tb, e2(null != u4.ca), !Mn(c4.Oa, s3, Rr)) {
                            u4.a = 2;
                            break n;
                          }
                          if (!It2(u4, s3.width)) break n;
                          if (s3.da) break n;
                          if ((s3.da || rt2(u4.ca.S)) && mn(), 11 > u4.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), null != u4.ca.f.kb.F && mn()), u4.Pb && 0 < u4.s.ua && null == u4.s.vb.X && !O2(u4.s.vb, u4.s.Wa.Xa)) {
                            u4.a = 1;
                            break n;
                          }
                          u4.xb = 0;
                        }
                        if (!_t2(u4, u4.V, u4.Ba, u4.c, u4.i, s3.o, Lt2)) break n;
                        c4.Dc = u4.Ma, u4 = 1;
                        break e;
                      }
                      e2(0 != u4.a), u4 = 0;
                    }
                    u4 = !u4;
                  }
                  u4 && (n3 = t4.a);
                } else n3 = t4.a;
              } else {
                if (null == (t4 = new Yt2())) {
                  h4 = 1;
                  break t;
                }
                if (t4.Fa = c4.na, t4.P = c4.P, t4.qc = c4.Sa, Kt2(t4, u4)) {
                  if (0 == (n3 = En(u4.width, u4.height, h4.Oa, h4.ba))) {
                    if (t4.Aa = 0, s3 = h4.Oa, e2(null != (c4 = t4)), null != s3) {
                      if (0 < (d4 = 0 > (d4 = s3.Md) ? 0 : 100 < d4 ? 255 : 255 * d4 / 100)) {
                        for (p4 = g4 = 0; 4 > p4; ++p4) 12 > (m4 = c4.pb[p4]).lc && (m4.ia = d4 * Di[0 > m4.lc ? 0 : m4.lc] >> 3), g4 |= m4.ia;
                        g4 && (alert("todo:VP8InitRandom"), c4.ia = 1);
                      }
                      c4.Ga = s3.Id, 100 < c4.Ga ? c4.Ga = 100 : 0 > c4.Ga && (c4.Ga = 0);
                    }
                    (function(t5, n4) {
                      if (null == t5) return 0;
                      if (null == n4) return Jt2(t5, 2, "NULL VP8Io parameter in VP8Decode().");
                      if (!t5.cb && !Kt2(t5, n4)) return 0;
                      if (e2(t5.cb), null == n4.ac || n4.ac(n4)) {
                        n4.ob && (t5.L = 0);
                        var s4 = Ri[t5.L];
                        if (2 == t5.L ? (t5.yb = 0, t5.zb = 0) : (t5.yb = n4.v - s4 >> 4, t5.zb = n4.j - s4 >> 4, 0 > t5.yb && (t5.yb = 0), 0 > t5.zb && (t5.zb = 0)), t5.Va = n4.o + 15 + s4 >> 4, t5.Hb = n4.va + 15 + s4 >> 4, t5.Hb > t5.za && (t5.Hb = t5.za), t5.Va > t5.Ub && (t5.Va = t5.Ub), 0 < t5.L) {
                          var u5 = t5.ed;
                          for (s4 = 0; 4 > s4; ++s4) {
                            var c5;
                            if (t5.Qa.Cb) {
                              var l5 = t5.Qa.Lb[s4];
                              t5.Qa.Fb || (l5 += u5.Tb);
                            } else l5 = u5.Tb;
                            for (c5 = 0; 1 >= c5; ++c5) {
                              var h5 = t5.gd[s4][c5], f5 = l5;
                              if (u5.Pc && (f5 += u5.vd[0], c5 && (f5 += u5.od[0])), 0 < (f5 = 0 > f5 ? 0 : 63 < f5 ? 63 : f5)) {
                                var d5 = f5;
                                0 < u5.wb && (d5 = 4 < u5.wb ? d5 >> 2 : d5 >> 1) > 9 - u5.wb && (d5 = 9 - u5.wb), 1 > d5 && (d5 = 1), h5.dd = d5, h5.tc = 2 * f5 + d5, h5.ld = 40 <= f5 ? 2 : 15 <= f5 ? 1 : 0;
                              } else h5.tc = 0;
                              h5.La = c5;
                            }
                          }
                        }
                        s4 = 0;
                      } else Jt2(t5, 6, "Frame setup failed"), s4 = t5.a;
                      if (s4 = 0 == s4) {
                        if (s4) {
                          t5.$c = 0, 0 < t5.Aa || (t5.Ic = Ti);
                          e: {
                            s4 = t5.Ic, u5 = 4 * (d5 = t5.za);
                            var p5 = 32 * d5, g5 = d5 + 1, m5 = 0 < t5.L ? d5 * (0 < t5.Aa ? 2 : 1) : 0, v4 = (2 == t5.Aa ? 2 : 1) * d5;
                            if ((h5 = u5 + 832 + (c5 = 3 * (16 * s4 + Ri[t5.L]) / 2 * p5) + (l5 = null != t5.Fa && 0 < t5.Fa.length ? t5.Kc.c * t5.Kc.i : 0)) != h5) s4 = 0;
                            else {
                              if (h5 > t5.Vb) {
                                if (t5.Vb = 0, t5.Ec = a2(h5), t5.Fc = 0, null == t5.Ec) {
                                  s4 = Jt2(t5, 1, "no memory during frame initialization.");
                                  break e;
                                }
                                t5.Vb = h5;
                              }
                              h5 = t5.Ec, f5 = t5.Fc, t5.Ac = h5, t5.Bc = f5, f5 += u5, t5.Gd = o2(p5, Ht2), t5.Hd = 0, t5.rb = o2(g5 + 1, Dt2), t5.sb = 1, t5.wa = m5 ? o2(m5, Rt2) : null, t5.Y = 0, t5.D.Nb = 0, t5.D.wa = t5.wa, t5.D.Y = t5.Y, 0 < t5.Aa && (t5.D.Y += d5), e2(true), t5.oc = h5, t5.pc = f5, f5 += 832, t5.ya = o2(v4, zt2), t5.aa = 0, t5.D.ya = t5.ya, t5.D.aa = t5.aa, 2 == t5.Aa && (t5.D.aa += d5), t5.R = 16 * d5, t5.B = 8 * d5, d5 = (p5 = Ri[t5.L]) * t5.R, p5 = p5 / 2 * t5.B, t5.sa = h5, t5.ta = f5 + d5, t5.qa = t5.sa, t5.ra = t5.ta + 16 * s4 * t5.R + p5, t5.Ha = t5.qa, t5.Ia = t5.ra + 8 * s4 * t5.B + p5, t5.$c = 0, f5 += c5, t5.mb = l5 ? h5 : null, t5.nb = l5 ? f5 : null, e2(f5 + l5 <= t5.Fc + t5.Vb), $t2(t5), i2(t5.Ac, t5.Bc, 0, u5), s4 = 1;
                            }
                          }
                          if (s4) {
                            if (n4.ka = 0, n4.y = t5.sa, n4.O = t5.ta, n4.f = t5.qa, n4.N = t5.ra, n4.ea = t5.Ha, n4.Vd = t5.Ia, n4.fa = t5.R, n4.Rc = t5.B, n4.F = null, n4.J = 0, !Ir) {
                              for (s4 = -255; 255 >= s4; ++s4) _r[255 + s4] = 0 > s4 ? -s4 : s4;
                              for (s4 = -1020; 1020 >= s4; ++s4) Pr[1020 + s4] = -128 > s4 ? -128 : 127 < s4 ? 127 : s4;
                              for (s4 = -112; 112 >= s4; ++s4) kr[112 + s4] = -16 > s4 ? -16 : 15 < s4 ? 15 : s4;
                              for (s4 = -255; 510 >= s4; ++s4) Fr[255 + s4] = 0 > s4 ? 0 : 255 < s4 ? 255 : s4;
                              Ir = 1;
                            }
                            ir = ue2, ar = ie2, sr = ae2, ur = oe2, cr = se2, or = re2, lr = Ye, hr = Je, fr = Ze, dr = $e, pr = Xe, gr = Ke, mr = Qe, vr = tn, br = ze, yr = Ue, wr = He, Nr = We, hi[0] = xe2, hi[1] = le2, hi[2] = Ne2, hi[3] = Le2, hi[4] = Ae2, hi[5] = _e2, hi[6] = Se2, hi[7] = Pe2, hi[8] = Fe2, hi[9] = ke2, li[0] = me2, li[1] = fe2, li[2] = de2, li[3] = pe2, li[4] = ve2, li[5] = be2, li[6] = ye2, fi[0] = Oe, fi[1] = he2, fi[2] = Ie2, fi[3] = je2, fi[4] = Me, fi[5] = Be, fi[6] = qe, s4 = 1;
                          } else s4 = 0;
                        }
                        s4 && (s4 = (function(t6, n5) {
                          for (t6.M = 0; t6.M < t6.Va; ++t6.M) {
                            var o3, s5 = t6.Jc[t6.M & t6.Xb], u6 = t6.m, c6 = t6;
                            for (o3 = 0; o3 < c6.za; ++o3) {
                              var l6 = u6, h6 = c6, f6 = h6.Ac, d6 = h6.Bc + 4 * o3, p6 = h6.zc, g6 = h6.ya[h6.aa + o3];
                              if (h6.Qa.Bb ? g6.$b = k2(l6, h6.Pa.jb[0]) ? 2 + k2(l6, h6.Pa.jb[2]) : k2(l6, h6.Pa.jb[1]) : g6.$b = 0, h6.kc && (g6.Ad = k2(l6, h6.Bd)), g6.Za = !k2(l6, 145) + 0, g6.Za) {
                                var m6 = g6.Ob, v5 = 0;
                                for (h6 = 0; 4 > h6; ++h6) {
                                  var b4, y4 = p6[0 + h6];
                                  for (b4 = 0; 4 > b4; ++b4) {
                                    y4 = si[f6[d6 + b4]][y4];
                                    for (var w4 = ai[k2(l6, y4[0])]; 0 < w4; ) w4 = ai[2 * w4 + k2(l6, y4[w4])];
                                    y4 = -w4, f6[d6 + b4] = y4;
                                  }
                                  r2(m6, v5, f6, d6, 4), v5 += 4, p6[0 + h6] = y4;
                                }
                              } else y4 = k2(l6, 156) ? k2(l6, 128) ? 1 : 3 : k2(l6, 163) ? 2 : 0, g6.Ob[0] = y4, i2(f6, d6, y4, 4), i2(p6, 0, y4, 4);
                              g6.Dd = k2(l6, 142) ? k2(l6, 114) ? k2(l6, 183) ? 1 : 3 : 2 : 0;
                            }
                            if (c6.m.Ka) return Jt2(t6, 7, "Premature end-of-partition0 encountered.");
                            for (; t6.ja < t6.za; ++t6.ja) {
                              if (c6 = s5, l6 = (u6 = t6).rb[u6.sb - 1], f6 = u6.rb[u6.sb + u6.ja], o3 = u6.ya[u6.aa + u6.ja], d6 = u6.kc ? o3.Ad : 0) l6.la = f6.la = 0, o3.Za || (l6.Na = f6.Na = 0), o3.Hc = 0, o3.Gc = 0, o3.ia = 0;
                              else {
                                var N4, L4;
                                if (l6 = f6, f6 = c6, d6 = u6.Pa.Xc, p6 = u6.ya[u6.aa + u6.ja], g6 = u6.pb[p6.$b], h6 = p6.ad, m6 = 0, v5 = u6.rb[u6.sb - 1], y4 = b4 = 0, i2(h6, m6, 0, 384), p6.Za) var x4 = 0, A4 = d6[3];
                                else {
                                  w4 = a2(16);
                                  var S3 = l6.Na + v5.Na;
                                  if (S3 = ni(f6, d6[1], S3, g6.Eb, 0, w4, 0), l6.Na = v5.Na = (0 < S3) + 0, 1 < S3) ir(w4, 0, h6, m6);
                                  else {
                                    var _3 = w4[0] + 3 >> 3;
                                    for (w4 = 0; 256 > w4; w4 += 16) h6[m6 + w4] = _3;
                                  }
                                  x4 = 1, A4 = d6[0];
                                }
                                var P3 = 15 & l6.la, F3 = 15 & v5.la;
                                for (w4 = 0; 4 > w4; ++w4) {
                                  var I3 = 1 & F3;
                                  for (_3 = L4 = 0; 4 > _3; ++_3) P3 = P3 >> 1 | (I3 = (S3 = ni(f6, A4, S3 = I3 + (1 & P3), g6.Sc, x4, h6, m6)) > x4) << 7, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                  P3 >>= 4, F3 = F3 >> 1 | I3 << 7, b4 = (b4 << 8 | L4) >>> 0;
                                }
                                for (A4 = P3, x4 = F3 >> 4, N4 = 0; 4 > N4; N4 += 2) {
                                  for (L4 = 0, P3 = l6.la >> 4 + N4, F3 = v5.la >> 4 + N4, w4 = 0; 2 > w4; ++w4) {
                                    for (I3 = 1 & F3, _3 = 0; 2 > _3; ++_3) S3 = I3 + (1 & P3), P3 = P3 >> 1 | (I3 = 0 < (S3 = ni(f6, d6[2], S3, g6.Qc, 0, h6, m6))) << 3, L4 = L4 << 2 | (3 < S3 ? 3 : 1 < S3 ? 2 : 0 != h6[m6 + 0]), m6 += 16;
                                    P3 >>= 2, F3 = F3 >> 1 | I3 << 5;
                                  }
                                  y4 |= L4 << 4 * N4, A4 |= P3 << 4 << N4, x4 |= (240 & F3) << N4;
                                }
                                l6.la = A4, v5.la = x4, p6.Hc = b4, p6.Gc = y4, p6.ia = 43690 & y4 ? 0 : g6.ia, d6 = !(b4 | y4);
                              }
                              if (0 < u6.L && (u6.wa[u6.Y + u6.ja] = u6.gd[o3.$b][o3.Za], u6.wa[u6.Y + u6.ja].La |= !d6), c6.Ka) return Jt2(t6, 7, "Premature end-of-file encountered.");
                            }
                            if ($t2(t6), u6 = n5, c6 = 1, o3 = (s5 = t6).D, l6 = 0 < s5.L && s5.M >= s5.zb && s5.M <= s5.Va, 0 == s5.Aa) e: {
                              if (o3.M = s5.M, o3.uc = l6, On(s5, o3), c6 = 1, o3 = (L4 = s5.D).Nb, l6 = (y4 = Ri[s5.L]) * s5.R, f6 = y4 / 2 * s5.B, w4 = 16 * o3 * s5.R, _3 = 8 * o3 * s5.B, d6 = s5.sa, p6 = s5.ta - l6 + w4, g6 = s5.qa, h6 = s5.ra - f6 + _3, m6 = s5.Ha, v5 = s5.Ia - f6 + _3, F3 = 0 == (P3 = L4.M), b4 = P3 >= s5.Va - 1, 2 == s5.Aa && On(s5, L4), L4.uc) for (I3 = (S3 = s5).D.M, e2(S3.D.uc), L4 = S3.yb; L4 < S3.Hb; ++L4) {
                                x4 = L4, A4 = I3;
                                var j3 = (C3 = (z3 = S3).D).Nb;
                                N4 = z3.R;
                                var C3 = C3.wa[C3.Y + x4], O3 = z3.sa, B4 = z3.ta + 16 * j3 * N4 + 16 * x4, M3 = C3.dd, q3 = C3.tc;
                                if (0 != q3) if (e2(3 <= q3), 1 == z3.L) 0 < x4 && yr(O3, B4, N4, q3 + 4), C3.La && Nr(O3, B4, N4, q3), 0 < A4 && br(O3, B4, N4, q3 + 4), C3.La && wr(O3, B4, N4, q3);
                                else {
                                  var E3 = z3.B, R3 = z3.qa, D3 = z3.ra + 8 * j3 * E3 + 8 * x4, T3 = z3.Ha, z3 = z3.Ia + 8 * j3 * E3 + 8 * x4;
                                  j3 = C3.ld, 0 < x4 && (hr(O3, B4, N4, q3 + 4, M3, j3), dr(R3, D3, T3, z3, E3, q3 + 4, M3, j3)), C3.La && (gr(O3, B4, N4, q3, M3, j3), vr(R3, D3, T3, z3, E3, q3, M3, j3)), 0 < A4 && (lr(O3, B4, N4, q3 + 4, M3, j3), fr(R3, D3, T3, z3, E3, q3 + 4, M3, j3)), C3.La && (pr(O3, B4, N4, q3, M3, j3), mr(R3, D3, T3, z3, E3, q3, M3, j3));
                                }
                              }
                              if (s5.ia && alert("todo:DitherRow"), null != u6.put) {
                                if (L4 = 16 * P3, P3 = 16 * (P3 + 1), F3 ? (u6.y = s5.sa, u6.O = s5.ta + w4, u6.f = s5.qa, u6.N = s5.ra + _3, u6.ea = s5.Ha, u6.W = s5.Ia + _3) : (L4 -= y4, u6.y = d6, u6.O = p6, u6.f = g6, u6.N = h6, u6.ea = m6, u6.W = v5), b4 || (P3 -= y4), P3 > u6.o && (P3 = u6.o), u6.F = null, u6.J = null, null != s5.Fa && 0 < s5.Fa.length && L4 < P3 && (u6.J = hn(s5, u6, L4, P3 - L4), u6.F = s5.mb, null == u6.F && 0 == u6.F.length)) {
                                  c6 = Jt2(s5, 3, "Could not decode alpha data.");
                                  break e;
                                }
                                L4 < u6.j && (y4 = u6.j - L4, L4 = u6.j, e2(!(1 & y4)), u6.O += s5.R * y4, u6.N += s5.B * (y4 >> 1), u6.W += s5.B * (y4 >> 1), null != u6.F && (u6.J += u6.width * y4)), L4 < P3 && (u6.O += u6.v, u6.N += u6.v >> 1, u6.W += u6.v >> 1, null != u6.F && (u6.J += u6.v), u6.ka = L4 - u6.j, u6.U = u6.va - u6.v, u6.T = P3 - L4, c6 = u6.put(u6));
                              }
                              o3 + 1 != s5.Ic || b4 || (r2(s5.sa, s5.ta - l6, d6, p6 + 16 * s5.R, l6), r2(s5.qa, s5.ra - f6, g6, h6 + 8 * s5.B, f6), r2(s5.Ha, s5.Ia - f6, m6, v5 + 8 * s5.B, f6));
                            }
                            if (!c6) return Jt2(t6, 6, "Output aborted.");
                          }
                          return 1;
                        })(t5, n4)), null != n4.bc && n4.bc(n4), s4 &= 1;
                      }
                      return s4 ? (t5.cb = 0, s4) : 0;
                    })(t4, u4) || (n3 = t4.a);
                  }
                } else n3 = t4.a;
              }
              0 == n3 && null != h4.Oa && h4.Oa.fd && (n3 = qn(h4.ba));
            }
            h4 = n3;
          }
          l4 = 0 != h4 ? null : 11 > l4 ? f4.f.RGBA.eb : f4.f.kb.y;
        } else l4 = null;
        return l4;
      };
      var zi = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1];
    };
    function c2(t3, e3) {
      for (var n3 = "", r3 = 0; r3 < 4; r3++) n3 += String.fromCharCode(t3[e3++]);
      return n3;
    }
    function l2(t3, e3) {
      return t3[e3 + 0] | t3[e3 + 1] << 8;
    }
    function h2(t3, e3) {
      return (t3[e3 + 0] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16) >>> 0;
    }
    function f2(t3, e3) {
      return (t3[e3 + 0] | t3[e3 + 1] << 8 | t3[e3 + 2] << 16 | t3[e3 + 3] << 24) >>> 0;
    }
    new u2();
    var d2 = [0], p2 = [0], g2 = [], m2 = new u2(), v2 = t2, b2 = (function(t3, e3) {
      var n3 = {}, r3 = 0, i3 = false, a3 = 0, o3 = 0;
      if (n3.frames = [], !/** @license
         * Copyright (c) 2017 Dominik Homberger
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        https://webpjs.appspot.com
        WebPRiffParser dominikhlbg@gmail.com
        */
      (function(t4, e4) {
        for (var n4 = 0; n4 < 4; n4++) if (t4[e4 + n4] != "RIFF".charCodeAt(n4)) return true;
        return false;
      })(t3, e3)) {
        for (f2(t3, e3 += 4), e3 += 8; e3 < t3.length; ) {
          var s3 = c2(t3, e3), u3 = f2(t3, e3 += 4);
          e3 += 4;
          var d3 = u3 + (1 & u3);
          switch (s3) {
            case "VP8 ":
            case "VP8L":
              void 0 === n3.frames[r3] && (n3.frames[r3] = {}), (m3 = n3.frames[r3]).src_off = i3 ? o3 : e3 - 8, m3.src_size = a3 + u3 + 8, r3++, i3 && (i3 = false, a3 = 0, o3 = 0);
              break;
            case "VP8X":
              (m3 = n3.header = {}).feature_flags = t3[e3];
              var p3 = e3 + 4;
              m3.canvas_width = 1 + h2(t3, p3), p3 += 3, m3.canvas_height = 1 + h2(t3, p3), p3 += 3;
              break;
            case "ALPH":
              i3 = true, a3 = d3 + 8, o3 = e3 - 8;
              break;
            case "ANIM":
              (m3 = n3.header).bgcolor = f2(t3, e3), p3 = e3 + 4, m3.loop_count = l2(t3, p3), p3 += 2;
              break;
            case "ANMF":
              var g3, m3;
              (m3 = n3.frames[r3] = {}).offset_x = 2 * h2(t3, e3), e3 += 3, m3.offset_y = 2 * h2(t3, e3), e3 += 3, m3.width = 1 + h2(t3, e3), e3 += 3, m3.height = 1 + h2(t3, e3), e3 += 3, m3.duration = h2(t3, e3), e3 += 3, g3 = t3[e3++], m3.dispose = 1 & g3, m3.blend = g3 >> 1 & 1;
          }
          "ANMF" != s3 && (e3 += d3);
        }
        return n3;
      }
    })(v2, 0);
    b2.response = v2, b2.rgbaoutput = true, b2.dataurl = false;
    var y2 = b2.header ? b2.header : null, w2 = b2.frames ? b2.frames : null;
    if (y2) {
      y2.loop_counter = y2.loop_count, d2 = [y2.canvas_height], p2 = [y2.canvas_width];
      for (var N2 = 0; N2 < w2.length && 0 != w2[N2].blend; N2++) ;
    }
    var L2 = w2[0], x2 = m2.WebPDecodeRGBA(v2, L2.src_off, L2.src_size, p2, d2);
    L2.rgba = x2, L2.imgwidth = p2[0], L2.imgheight = d2[0];
    for (var A2 = 0; A2 < p2[0] * d2[0] * 4; A2++) g2[A2] = x2[A2];
    return this.width = p2, this.height = d2, this.data = g2, this;
  }
  !(function(e2) {
    var n2, r2, i2, a2, s2, u2, c2, l2, f2, d2 = function(t2) {
      return t2 = t2 || {}, this.isStrokeTransparent = t2.isStrokeTransparent || false, this.strokeOpacity = t2.strokeOpacity || 1, this.strokeStyle = t2.strokeStyle || "#000000", this.fillStyle = t2.fillStyle || "#000000", this.isFillTransparent = t2.isFillTransparent || false, this.fillOpacity = t2.fillOpacity || 1, this.font = t2.font || "10px sans-serif", this.textBaseline = t2.textBaseline || "alphabetic", this.textAlign = t2.textAlign || "left", this.lineWidth = t2.lineWidth || 1, this.lineJoin = t2.lineJoin || "miter", this.lineCap = t2.lineCap || "butt", this.path = t2.path || [], this.transform = void 0 !== t2.transform ? t2.transform.clone() : new l2(), this.globalCompositeOperation = t2.globalCompositeOperation || "normal", this.globalAlpha = t2.globalAlpha || 1, this.clip_path = t2.clip_path || [], this.currentPoint = t2.currentPoint || new u2(), this.miterLimit = t2.miterLimit || 10, this.lastPoint = t2.lastPoint || new u2(), this.lineDashOffset = t2.lineDashOffset || 0, this.lineDash = t2.lineDash || [], this.margin = t2.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = t2.prevPageLastElemOffset || 0, this.ignoreClearRect = "boolean" != typeof t2.ignoreClearRect || t2.ignoreClearRect, this;
    };
    e2.events.push(["initialized", function() {
      this.context2d = new p2(this), n2 = this.internal.f2, r2 = this.internal.getCoordinateString, i2 = this.internal.getVerticalCoordinateString, a2 = this.internal.getHorizontalCoordinate, s2 = this.internal.getVerticalCoordinate, u2 = this.internal.Point, c2 = this.internal.Rectangle, l2 = this.internal.Matrix, f2 = new d2();
    }]);
    var p2 = function(t2) {
      Object.defineProperty(this, "canvas", { get: function() {
        return { parentNode: false, style: false };
      } });
      var e3 = t2;
      Object.defineProperty(this, "pdf", { get: function() {
        return e3;
      } });
      var n3 = false;
      Object.defineProperty(this, "pageWrapXEnabled", { get: function() {
        return n3;
      }, set: function(t3) {
        n3 = Boolean(t3);
      } });
      var r3 = false;
      Object.defineProperty(this, "pageWrapYEnabled", { get: function() {
        return r3;
      }, set: function(t3) {
        r3 = Boolean(t3);
      } });
      var i3 = 0;
      Object.defineProperty(this, "posX", { get: function() {
        return i3;
      }, set: function(t3) {
        isNaN(t3) || (i3 = t3);
      } });
      var a3 = 0;
      Object.defineProperty(this, "posY", { get: function() {
        return a3;
      }, set: function(t3) {
        isNaN(t3) || (a3 = t3);
      } }), Object.defineProperty(this, "margin", { get: function() {
        return f2.margin;
      }, set: function(t3) {
        var e4;
        "number" == typeof t3 ? e4 = [t3, t3, t3, t3] : ((e4 = new Array(4))[0] = t3[0], e4[1] = t3.length >= 2 ? t3[1] : e4[0], e4[2] = t3.length >= 3 ? t3[2] : e4[0], e4[3] = t3.length >= 4 ? t3[3] : e4[1]), f2.margin = e4;
      } });
      var o2 = false;
      Object.defineProperty(this, "autoPaging", { get: function() {
        return o2;
      }, set: function(t3) {
        o2 = t3;
      } });
      var s3 = 0;
      Object.defineProperty(this, "lastBreak", { get: function() {
        return s3;
      }, set: function(t3) {
        s3 = t3;
      } });
      var u3 = [];
      Object.defineProperty(this, "pageBreaks", { get: function() {
        return u3;
      }, set: function(t3) {
        u3 = t3;
      } }), Object.defineProperty(this, "ctx", { get: function() {
        return f2;
      }, set: function(t3) {
        t3 instanceof d2 && (f2 = t3);
      } }), Object.defineProperty(this, "path", { get: function() {
        return f2.path;
      }, set: function(t3) {
        f2.path = t3;
      } });
      var c3 = [];
      Object.defineProperty(this, "ctxStack", { get: function() {
        return c3;
      }, set: function(t3) {
        c3 = t3;
      } }), Object.defineProperty(this, "fillStyle", { get: function() {
        return this.ctx.fillStyle;
      }, set: function(t3) {
        var e4;
        e4 = g2(t3), this.ctx.fillStyle = e4.style, this.ctx.isFillTransparent = 0 === e4.a, this.ctx.fillOpacity = e4.a, this.pdf.setFillColor(e4.r, e4.g, e4.b, { a: e4.a }), this.pdf.setTextColor(e4.r, e4.g, e4.b, { a: e4.a });
      } }), Object.defineProperty(this, "strokeStyle", { get: function() {
        return this.ctx.strokeStyle;
      }, set: function(t3) {
        var e4 = g2(t3);
        this.ctx.strokeStyle = e4.style, this.ctx.isStrokeTransparent = 0 === e4.a, this.ctx.strokeOpacity = e4.a, 0 === e4.a ? this.pdf.setDrawColor(255, 255, 255) : (e4.a, this.pdf.setDrawColor(e4.r, e4.g, e4.b));
      } }), Object.defineProperty(this, "lineCap", { get: function() {
        return this.ctx.lineCap;
      }, set: function(t3) {
        -1 !== ["butt", "round", "square"].indexOf(t3) && (this.ctx.lineCap = t3, this.pdf.setLineCap(t3));
      } }), Object.defineProperty(this, "lineWidth", { get: function() {
        return this.ctx.lineWidth;
      }, set: function(t3) {
        isNaN(t3) || (this.ctx.lineWidth = t3, this.pdf.setLineWidth(t3));
      } }), Object.defineProperty(this, "lineJoin", { get: function() {
        return this.ctx.lineJoin;
      }, set: function(t3) {
        -1 !== ["bevel", "round", "miter"].indexOf(t3) && (this.ctx.lineJoin = t3, this.pdf.setLineJoin(t3));
      } }), Object.defineProperty(this, "miterLimit", { get: function() {
        return this.ctx.miterLimit;
      }, set: function(t3) {
        isNaN(t3) || (this.ctx.miterLimit = t3, this.pdf.setMiterLimit(t3));
      } }), Object.defineProperty(this, "textBaseline", { get: function() {
        return this.ctx.textBaseline;
      }, set: function(t3) {
        this.ctx.textBaseline = t3;
      } }), Object.defineProperty(this, "textAlign", { get: function() {
        return this.ctx.textAlign;
      }, set: function(t3) {
        -1 !== ["right", "end", "center", "left", "start"].indexOf(t3) && (this.ctx.textAlign = t3);
      } });
      var l3 = null, h2 = null;
      var p3 = null;
      Object.defineProperty(this, "fontFaces", { get: function() {
        return p3;
      }, set: function(t3) {
        l3 = null, h2 = null, p3 = t3;
      } }), Object.defineProperty(this, "font", { get: function() {
        return this.ctx.font;
      }, set: function(t3) {
        var e4;
        if (this.ctx.font = t3, null !== (e4 = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z0-9]+?)\s*$/i.exec(t3))) {
          var n4 = e4[1];
          e4[2];
          var r4 = e4[3], i4 = e4[4];
          e4[5];
          var a4 = e4[6], o3 = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(i4)[2];
          i4 = "px" === o3 ? Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor) : "em" === o3 ? Math.floor(parseFloat(i4) * this.pdf.getFontSize()) : Math.floor(parseFloat(i4) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(i4);
          var s4 = (function(t4) {
            var e5, n5, r5 = [], i5 = t4.trim();
            if ("" === i5) return Jt;
            if (i5 in Mt) return [Mt[i5]];
            for (; "" !== i5; ) {
              switch (n5 = null, e5 = (i5 = Et(i5)).charAt(0)) {
                case '"':
                case "'":
                  n5 = Rt(i5.substring(1), e5);
                  break;
                default:
                  n5 = Dt(i5);
              }
              if (null === n5) return Jt;
              if (r5.push(n5[0]), "" !== (i5 = Et(n5[1])) && "," !== i5.charAt(0)) return Jt;
              i5 = i5.replace(/^,/, "");
            }
            return r5;
          })(a4);
          if (this.fontFaces) {
            var u4 = (function(t4, e5) {
              var n5 = t4.getFontList(), r5 = JSON.stringify(n5);
              if (null === l3 || h2 !== r5) {
                var i5 = (function(t5) {
                  var e6 = [];
                  return Object.keys(t5).forEach(function(n6) {
                    t5[n6].forEach(function(t6) {
                      var r6 = null;
                      switch (t6) {
                        case "bold":
                          r6 = { family: n6, weight: "bold" };
                          break;
                        case "italic":
                          r6 = { family: n6, style: "italic" };
                          break;
                        case "bolditalic":
                          r6 = { family: n6, weight: "bold", style: "italic" };
                          break;
                        case "":
                        case "normal":
                          r6 = { family: n6 };
                      }
                      null !== r6 && (r6.ref = { name: n6, style: t6 }, e6.push(r6));
                    });
                  }), e6;
                })(n5);
                l3 = (function(t5) {
                  for (var e6 = {}, n6 = 0; n6 < t5.length; ++n6) {
                    var r6 = Ct(t5[n6]), i6 = r6.family, a5 = r6.stretch, o4 = r6.style, s5 = r6.weight;
                    e6[i6] = e6[i6] || {}, e6[i6][a5] = e6[i6][a5] || {}, e6[i6][a5][o4] = e6[i6][a5][o4] || {}, e6[i6][a5][o4][s5] = r6;
                  }
                  return e6;
                })(i5.concat(e5)), h2 = r5;
              }
              return l3;
            })(this.pdf, this.fontFaces), c4 = s4.map(function(t4) {
              return { family: t4, stretch: "normal", weight: r4, style: n4 };
            }), f3 = (function(t4, e5, n5) {
              for (var r5 = (n5 = n5 || {}).defaultFontFamily || "times", i5 = Object.assign({}, Bt, n5.genericFontFamilies || {}), a5 = null, o4 = null, s5 = 0; s5 < e5.length; ++s5) if (i5[(a5 = Ct(e5[s5])).family] && (a5.family = i5[a5.family]), t4.hasOwnProperty(a5.family)) {
                o4 = t4[a5.family];
                break;
              }
              if (!(o4 = o4 || t4[r5])) throw new Error("Could not find a font-family for the rule '" + qt(a5) + "' and default family '" + r5 + "'.");
              if (o4 = (function(t5, e6) {
                if (e6[t5]) return e6[t5];
                var n6 = Ft[t5], r6 = n6 <= Ft.normal ? -1 : 1, i6 = Ot(e6, kt, n6, r6);
                if (!i6) throw new Error("Could not find a matching font-stretch value for " + t5);
                return i6;
              })(a5.stretch, o4), o4 = (function(t5, e6) {
                if (e6[t5]) return e6[t5];
                for (var n6 = Pt[t5], r6 = 0; r6 < n6.length; ++r6) if (e6[n6[r6]]) return e6[n6[r6]];
                throw new Error("Could not find a matching font-style for " + t5);
              })(a5.style, o4), !(o4 = (function(t5, e6) {
                if (e6[t5]) return e6[t5];
                if (400 === t5 && e6[500]) return e6[500];
                if (500 === t5 && e6[400]) return e6[400];
                var n6 = jt[t5], r6 = Ot(e6, It, n6, t5 < 400 ? -1 : 1);
                if (!r6) throw new Error("Could not find a matching font-weight for value " + t5);
                return r6;
              })(a5.weight, o4))) throw new Error("Failed to resolve a font for the rule '" + qt(a5) + "'.");
              return o4;
            })(u4, c4);
            this.pdf.setFont(f3.ref.name, f3.ref.style);
          } else {
            var d3 = "";
            ("bold" === r4 || parseInt(r4, 10) >= 700 || "bold" === n4) && (d3 = "bold"), "italic" === n4 && (d3 += "italic"), 0 === d3.length && (d3 = "normal");
            for (var p4 = "", g3 = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, m3 = 0; m3 < s4.length; m3++) {
              if (void 0 !== this.pdf.internal.getFont(s4[m3], d3, { noFallback: true, disableWarning: true })) {
                p4 = s4[m3];
                break;
              }
              if ("bolditalic" === d3 && void 0 !== this.pdf.internal.getFont(s4[m3], "bold", { noFallback: true, disableWarning: true })) p4 = s4[m3], d3 = "bold";
              else if (void 0 !== this.pdf.internal.getFont(s4[m3], "normal", { noFallback: true, disableWarning: true })) {
                p4 = s4[m3], d3 = "normal";
                break;
              }
            }
            if ("" === p4) {
              for (var v3 = 0; v3 < s4.length; v3++) if (g3[s4[v3]]) {
                p4 = g3[s4[v3]];
                break;
              }
            }
            p4 = "" === p4 ? "Times" : p4, this.pdf.setFont(p4, d3);
          }
        }
      } }), Object.defineProperty(this, "globalCompositeOperation", { get: function() {
        return this.ctx.globalCompositeOperation;
      }, set: function(t3) {
        this.ctx.globalCompositeOperation = t3;
      } }), Object.defineProperty(this, "globalAlpha", { get: function() {
        return this.ctx.globalAlpha;
      }, set: function(t3) {
        this.ctx.globalAlpha = t3;
      } }), Object.defineProperty(this, "lineDashOffset", { get: function() {
        return this.ctx.lineDashOffset;
      }, set: function(t3) {
        this.ctx.lineDashOffset = t3, T2.call(this);
      } }), Object.defineProperty(this, "lineDash", { get: function() {
        return this.ctx.lineDash;
      }, set: function(t3) {
        this.ctx.lineDash = t3, T2.call(this);
      } }), Object.defineProperty(this, "ignoreClearRect", { get: function() {
        return this.ctx.ignoreClearRect;
      }, set: function(t3) {
        this.ctx.ignoreClearRect = Boolean(t3);
      } });
    };
    p2.prototype.setLineDash = function(t2) {
      this.lineDash = t2;
    }, p2.prototype.getLineDash = function() {
      return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice();
    }, p2.prototype.fill = function() {
      x2.call(this, "fill", false);
    }, p2.prototype.stroke = function() {
      x2.call(this, "stroke", false);
    }, p2.prototype.beginPath = function() {
      this.path = [{ type: "begin" }];
    }, p2.prototype.moveTo = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw o$1.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo");
      var n3 = this.ctx.transform.applyToPoint(new u2(t2, e3));
      this.path.push({ type: "mt", x: n3.x, y: n3.y }), this.ctx.lastPoint = new u2(t2, e3);
    }, p2.prototype.closePath = function() {
      var e3 = new u2(0, 0), n3 = 0;
      for (n3 = this.path.length - 1; -1 !== n3; n3--) if ("begin" === this.path[n3].type && "object" === _typeof$1(this.path[n3 + 1]) && "number" == typeof this.path[n3 + 1].x) {
        e3 = new u2(this.path[n3 + 1].x, this.path[n3 + 1].y);
        break;
      }
      this.path.push({ type: "close" }), this.ctx.lastPoint = new u2(e3.x, e3.y);
    }, p2.prototype.lineTo = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw o$1.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo");
      var n3 = this.ctx.transform.applyToPoint(new u2(t2, e3));
      this.path.push({ type: "lt", x: n3.x, y: n3.y }), this.ctx.lastPoint = new u2(n3.x, n3.y);
    }, p2.prototype.clip = function() {
      this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), x2.call(this, null, true);
    }, p2.prototype.quadraticCurveTo = function(t2, e3, n3, r3) {
      if (isNaN(n3) || isNaN(r3) || isNaN(t2) || isNaN(e3)) throw o$1.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo");
      var i3 = this.ctx.transform.applyToPoint(new u2(n3, r3)), a3 = this.ctx.transform.applyToPoint(new u2(t2, e3));
      this.path.push({ type: "qct", x1: a3.x, y1: a3.y, x: i3.x, y: i3.y }), this.ctx.lastPoint = new u2(i3.x, i3.y);
    }, p2.prototype.bezierCurveTo = function(t2, e3, n3, r3, i3, a3) {
      if (isNaN(i3) || isNaN(a3) || isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo");
      var s3 = this.ctx.transform.applyToPoint(new u2(i3, a3)), c3 = this.ctx.transform.applyToPoint(new u2(t2, e3)), l3 = this.ctx.transform.applyToPoint(new u2(n3, r3));
      this.path.push({ type: "bct", x1: c3.x, y1: c3.y, x2: l3.x, y2: l3.y, x: s3.x, y: s3.y }), this.ctx.lastPoint = new u2(s3.x, s3.y);
    }, p2.prototype.arc = function(t2, e3, n3, r3, i3, a3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i3)) throw o$1.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc");
      if (a3 = Boolean(a3), !this.ctx.transform.isIdentity) {
        var s3 = this.ctx.transform.applyToPoint(new u2(t2, e3));
        t2 = s3.x, e3 = s3.y;
        var c3 = this.ctx.transform.applyToPoint(new u2(0, n3)), l3 = this.ctx.transform.applyToPoint(new u2(0, 0));
        n3 = Math.sqrt(Math.pow(c3.x - l3.x, 2) + Math.pow(c3.y - l3.y, 2));
      }
      Math.abs(i3 - r3) >= 2 * Math.PI && (r3 = 0, i3 = 2 * Math.PI), this.path.push({ type: "arc", x: t2, y: e3, radius: n3, startAngle: r3, endAngle: i3, counterclockwise: a3 });
    }, p2.prototype.arcTo = function(t2, e3, n3, r3, i3) {
      throw new Error("arcTo not implemented.");
    }, p2.prototype.rect = function(t2, e3, n3, r3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect");
      this.moveTo(t2, e3), this.lineTo(t2 + n3, e3), this.lineTo(t2 + n3, e3 + r3), this.lineTo(t2, e3 + r3), this.lineTo(t2, e3), this.lineTo(t2 + n3, e3), this.lineTo(t2, e3);
    }, p2.prototype.fillRect = function(t2, e3, n3, r3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect");
      if (!m2.call(this)) {
        var i3 = {};
        "butt" !== this.lineCap && (i3.lineCap = this.lineCap, this.lineCap = "butt"), "miter" !== this.lineJoin && (i3.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(t2, e3, n3, r3), this.fill(), i3.hasOwnProperty("lineCap") && (this.lineCap = i3.lineCap), i3.hasOwnProperty("lineJoin") && (this.lineJoin = i3.lineJoin);
      }
    }, p2.prototype.strokeRect = function(t2, e3, n3, r3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect");
      v2.call(this) || (this.beginPath(), this.rect(t2, e3, n3, r3), this.stroke());
    }, p2.prototype.clearRect = function(t2, e3, n3, r3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3)) throw o$1.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect");
      this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(t2, e3, n3, r3));
    }, p2.prototype.save = function(t2) {
      t2 = "boolean" != typeof t2 || t2;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, n3 = 0; n3 < this.pdf.internal.getNumberOfPages(); n3++) this.pdf.setPage(n3 + 1), this.pdf.internal.out("q");
      if (this.pdf.setPage(e3), t2) {
        this.ctx.fontSize = this.pdf.internal.getFontSize();
        var r3 = new d2(this.ctx);
        this.ctxStack.push(this.ctx), this.ctx = r3;
      }
    }, p2.prototype.restore = function(t2) {
      t2 = "boolean" != typeof t2 || t2;
      for (var e3 = this.pdf.internal.getCurrentPageInfo().pageNumber, n3 = 0; n3 < this.pdf.internal.getNumberOfPages(); n3++) this.pdf.setPage(n3 + 1), this.pdf.internal.out("Q");
      this.pdf.setPage(e3), t2 && 0 !== this.ctxStack.length && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset);
    }, p2.prototype.toDataURL = function() {
      throw new Error("toDataUrl not implemented.");
    };
    var g2 = function(t2) {
      var e3, n3, r3, i3;
      if (true === t2.isCanvasGradient && (t2 = t2.getColor()), !t2) return { r: 0, g: 0, b: 0, a: 0, style: t2 };
      if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(t2)) e3 = 0, n3 = 0, r3 = 0, i3 = 0;
      else {
        var a3 = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(t2);
        if (null !== a3) e3 = parseInt(a3[1]), n3 = parseInt(a3[2]), r3 = parseInt(a3[3]), i3 = 1;
        else if (null !== (a3 = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(t2))) e3 = parseInt(a3[1]), n3 = parseInt(a3[2]), r3 = parseInt(a3[3]), i3 = parseFloat(a3[4]);
        else {
          if (i3 = 1, "string" == typeof t2 && "#" !== t2.charAt(0)) {
            var o2 = new h$1(t2);
            t2 = o2.ok ? o2.toHex() : "#000000";
          }
          4 === t2.length ? (e3 = t2.substring(1, 2), e3 += e3, n3 = t2.substring(2, 3), n3 += n3, r3 = t2.substring(3, 4), r3 += r3) : (e3 = t2.substring(1, 3), n3 = t2.substring(3, 5), r3 = t2.substring(5, 7)), e3 = parseInt(e3, 16), n3 = parseInt(n3, 16), r3 = parseInt(r3, 16);
        }
      }
      return { r: e3, g: n3, b: r3, a: i3, style: t2 };
    }, m2 = function() {
      return this.ctx.isFillTransparent || 0 == this.globalAlpha;
    }, v2 = function() {
      return Boolean(this.ctx.isStrokeTransparent || 0 == this.globalAlpha);
    };
    p2.prototype.fillText = function(t2, e3, n3, r3) {
      if (isNaN(e3) || isNaN(n3) || "string" != typeof t2) throw o$1.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText");
      if (r3 = isNaN(r3) ? void 0 : r3, !m2.call(this)) {
        var i3 = E2(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
        j2.call(this, { text: t2, x: e3, y: n3, scale: a3, angle: i3, align: this.textAlign, maxWidth: r3 });
      }
    }, p2.prototype.strokeText = function(t2, e3, n3, r3) {
      if (isNaN(e3) || isNaN(n3) || "string" != typeof t2) throw o$1.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText");
      if (!v2.call(this)) {
        r3 = isNaN(r3) ? void 0 : r3;
        var i3 = E2(this.ctx.transform.rotation), a3 = this.ctx.transform.scaleX;
        j2.call(this, { text: t2, x: e3, y: n3, scale: a3, renderingMode: "stroke", angle: i3, align: this.textAlign, maxWidth: r3 });
      }
    }, p2.prototype.measureText = function(t2) {
      if ("string" != typeof t2) throw o$1.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText");
      var e3 = this.pdf, n3 = this.pdf.internal.scaleFactor, r3 = e3.internal.getFontSize(), i3 = e3.getStringUnitWidth(t2) * r3 / e3.internal.scaleFactor;
      return new function(t3) {
        var e4 = (t3 = t3 || {}).width || 0;
        return Object.defineProperty(this, "width", { get: function() {
          return e4;
        } }), this;
      }({ width: i3 *= Math.round(96 * n3 / 72 * 1e4) / 1e4 });
    }, p2.prototype.scale = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw o$1.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale");
      var n3 = new l2(t2, 0, 0, e3, 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(n3);
    }, p2.prototype.rotate = function(t2) {
      if (isNaN(t2)) throw o$1.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate");
      var e3 = new l2(Math.cos(t2), Math.sin(t2), -Math.sin(t2), Math.cos(t2), 0, 0);
      this.ctx.transform = this.ctx.transform.multiply(e3);
    }, p2.prototype.translate = function(t2, e3) {
      if (isNaN(t2) || isNaN(e3)) throw o$1.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate");
      var n3 = new l2(1, 0, 0, 1, t2, e3);
      this.ctx.transform = this.ctx.transform.multiply(n3);
    }, p2.prototype.transform = function(t2, e3, n3, r3, i3, a3) {
      if (isNaN(t2) || isNaN(e3) || isNaN(n3) || isNaN(r3) || isNaN(i3) || isNaN(a3)) throw o$1.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform");
      var s3 = new l2(t2, e3, n3, r3, i3, a3);
      this.ctx.transform = this.ctx.transform.multiply(s3);
    }, p2.prototype.setTransform = function(t2, e3, n3, r3, i3, a3) {
      t2 = isNaN(t2) ? 1 : t2, e3 = isNaN(e3) ? 0 : e3, n3 = isNaN(n3) ? 0 : n3, r3 = isNaN(r3) ? 1 : r3, i3 = isNaN(i3) ? 0 : i3, a3 = isNaN(a3) ? 0 : a3, this.ctx.transform = new l2(t2, e3, n3, r3, i3, a3);
    };
    var b2 = function() {
      return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0;
    };
    p2.prototype.drawImage = function(t2, e3, n3, r3, i3, a3, o2, s3, u3) {
      var h2 = this.pdf.getImageProperties(t2), f3 = 1, d3 = 1, p3 = 1, g3 = 1;
      void 0 !== r3 && void 0 !== s3 && (p3 = s3 / r3, g3 = u3 / i3, f3 = h2.width / r3 * s3 / r3, d3 = h2.height / i3 * u3 / i3), void 0 === a3 && (a3 = e3, o2 = n3, e3 = 0, n3 = 0), void 0 !== r3 && void 0 === s3 && (s3 = r3, u3 = i3), void 0 === r3 && void 0 === s3 && (s3 = h2.width, u3 = h2.height);
      var m3 = this.ctx.transform.decompose(), v3 = E2(m3.rotate.shx), w3 = new l2(), x3 = (w3 = (w3 = (w3 = w3.multiply(m3.translate)).multiply(m3.skew)).multiply(m3.scale)).applyToRectangle(new c2(a3 - e3 * p3, o2 - n3 * g3, r3 * f3, i3 * d3));
      if (this.autoPaging) {
        for (var S3, _3 = y2.call(this, x3), P3 = [], k3 = 0; k3 < _3.length; k3 += 1) -1 === P3.indexOf(_3[k3]) && P3.push(_3[k3]);
        L2(P3);
        for (var F3 = P3[0], I3 = P3[P3.length - 1], j3 = F3; j3 < I3 + 1; j3++) {
          this.pdf.setPage(j3);
          var C3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], O3 = 1 === j3 ? this.posY + this.margin[0] : this.margin[0], B4 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], M3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], q3 = 1 === j3 ? 0 : B4 + (j3 - 2) * M3;
          if (0 !== this.ctx.clip_path.length) {
            var R3 = this.path;
            S3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(S3, this.posX + this.margin[3], -q3 + O3 + this.ctx.prevPageLastElemOffset), A2.call(this, "fill", true), this.path = R3;
          }
          var D3 = JSON.parse(JSON.stringify(x3));
          D3 = N2([D3], this.posX + this.margin[3], -q3 + O3 + this.ctx.prevPageLastElemOffset)[0];
          var T3 = (j3 > F3 || j3 < I3) && b2.call(this);
          T3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], C3, M3, null).clip().discardPath()), this.pdf.addImage(t2, "JPEG", D3.x, D3.y, D3.w, D3.h, null, null, v3), T3 && this.pdf.restoreGraphicsState();
        }
      } else this.pdf.addImage(t2, "JPEG", x3.x, x3.y, x3.w, x3.h, null, null, v3);
    };
    var y2 = function(t2, e3, n3) {
      var r3 = [];
      e3 = e3 || this.pdf.internal.pageSize.width, n3 = n3 || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2];
      var i3 = this.posY + this.ctx.prevPageLastElemOffset;
      switch (t2.type) {
        default:
        case "mt":
        case "lt":
          r3.push(Math.floor((t2.y + i3) / n3) + 1);
          break;
        case "arc":
          r3.push(Math.floor((t2.y + i3 - t2.radius) / n3) + 1), r3.push(Math.floor((t2.y + i3 + t2.radius) / n3) + 1);
          break;
        case "qct":
          var a3 = R2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x, t2.y);
          r3.push(Math.floor((a3.y + i3) / n3) + 1), r3.push(Math.floor((a3.y + a3.h + i3) / n3) + 1);
          break;
        case "bct":
          var o2 = D2(this.ctx.lastPoint.x, this.ctx.lastPoint.y, t2.x1, t2.y1, t2.x2, t2.y2, t2.x, t2.y);
          r3.push(Math.floor((o2.y + i3) / n3) + 1), r3.push(Math.floor((o2.y + o2.h + i3) / n3) + 1);
          break;
        case "rect":
          r3.push(Math.floor((t2.y + i3) / n3) + 1), r3.push(Math.floor((t2.y + t2.h + i3) / n3) + 1);
      }
      for (var s3 = 0; s3 < r3.length; s3 += 1) for (; this.pdf.internal.getNumberOfPages() < r3[s3]; ) w2.call(this);
      return r3;
    }, w2 = function() {
      var t2 = this.fillStyle, e3 = this.strokeStyle, n3 = this.font, r3 = this.lineCap, i3 = this.lineWidth, a3 = this.lineJoin;
      this.pdf.addPage(), this.fillStyle = t2, this.strokeStyle = e3, this.font = n3, this.lineCap = r3, this.lineWidth = i3, this.lineJoin = a3;
    }, N2 = function(t2, e3, n3) {
      for (var r3 = 0; r3 < t2.length; r3++) switch (t2[r3].type) {
        case "bct":
          t2[r3].x2 += e3, t2[r3].y2 += n3;
        case "qct":
          t2[r3].x1 += e3, t2[r3].y1 += n3;
        default:
          t2[r3].x += e3, t2[r3].y += n3;
      }
      return t2;
    }, L2 = function(t2) {
      return t2.sort(function(t3, e3) {
        return t3 - e3;
      });
    }, x2 = function(t2, e3) {
      var n3 = this.fillStyle, r3 = this.strokeStyle, i3 = this.lineCap, a3 = this.lineWidth, o2 = Math.abs(a3 * this.ctx.transform.scaleX), s3 = this.lineJoin;
      if (this.autoPaging) {
        for (var u3, c3, l3 = JSON.parse(JSON.stringify(this.path)), h2 = JSON.parse(JSON.stringify(this.path)), f3 = [], d3 = 0; d3 < h2.length; d3++) if (void 0 !== h2[d3].x) for (var p3 = y2.call(this, h2[d3]), g3 = 0; g3 < p3.length; g3 += 1) -1 === f3.indexOf(p3[g3]) && f3.push(p3[g3]);
        for (var m3 = 0; m3 < f3.length; m3++) for (; this.pdf.internal.getNumberOfPages() < f3[m3]; ) w2.call(this);
        L2(f3);
        for (var v3 = f3[0], x3 = f3[f3.length - 1], S3 = v3; S3 < x3 + 1; S3++) {
          this.pdf.setPage(S3), this.fillStyle = n3, this.strokeStyle = r3, this.lineCap = i3, this.lineWidth = o2, this.lineJoin = s3;
          var _3 = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], P3 = 1 === S3 ? this.posY + this.margin[0] : this.margin[0], k3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], F3 = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], I3 = 1 === S3 ? 0 : k3 + (S3 - 2) * F3;
          if (0 !== this.ctx.clip_path.length) {
            var j3 = this.path;
            u3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(u3, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), A2.call(this, t2, true), this.path = j3;
          }
          if (c3 = JSON.parse(JSON.stringify(l3)), this.path = N2(c3, this.posX + this.margin[3], -I3 + P3 + this.ctx.prevPageLastElemOffset), false === e3 || 0 === S3) {
            var C3 = (S3 > v3 || S3 < x3) && b2.call(this);
            C3 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], _3, F3, null).clip().discardPath()), A2.call(this, t2, e3), C3 && this.pdf.restoreGraphicsState();
          }
          this.lineWidth = a3;
        }
        this.path = l3;
      } else this.lineWidth = o2, A2.call(this, t2, e3), this.lineWidth = a3;
    }, A2 = function(t2, e3) {
      if (("stroke" !== t2 || e3 || !v2.call(this)) && ("stroke" === t2 || e3 || !m2.call(this))) {
        for (var n3, r3, i3 = [], a3 = this.path, o2 = 0; o2 < a3.length; o2++) {
          var s3 = a3[o2];
          switch (s3.type) {
            case "begin":
              i3.push({ begin: true });
              break;
            case "close":
              i3.push({ close: true });
              break;
            case "mt":
              i3.push({ start: s3, deltas: [], abs: [] });
              break;
            case "lt":
              var u3 = i3.length;
              if (a3[o2 - 1] && !isNaN(a3[o2 - 1].x) && (n3 = [s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], u3 > 0)) {
                for (; u3 >= 0; u3--) if (true !== i3[u3 - 1].close && true !== i3[u3 - 1].begin) {
                  i3[u3 - 1].deltas.push(n3), i3[u3 - 1].abs.push(s3);
                  break;
                }
              }
              break;
            case "bct":
              n3 = [s3.x1 - a3[o2 - 1].x, s3.y1 - a3[o2 - 1].y, s3.x2 - a3[o2 - 1].x, s3.y2 - a3[o2 - 1].y, s3.x - a3[o2 - 1].x, s3.y - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n3);
              break;
            case "qct":
              var c3 = a3[o2 - 1].x + 2 / 3 * (s3.x1 - a3[o2 - 1].x), l3 = a3[o2 - 1].y + 2 / 3 * (s3.y1 - a3[o2 - 1].y), h2 = s3.x + 2 / 3 * (s3.x1 - s3.x), f3 = s3.y + 2 / 3 * (s3.y1 - s3.y), d3 = s3.x, p3 = s3.y;
              n3 = [c3 - a3[o2 - 1].x, l3 - a3[o2 - 1].y, h2 - a3[o2 - 1].x, f3 - a3[o2 - 1].y, d3 - a3[o2 - 1].x, p3 - a3[o2 - 1].y], i3[i3.length - 1].deltas.push(n3);
              break;
            case "arc":
              i3.push({ deltas: [], abs: [], arc: true }), Array.isArray(i3[i3.length - 1].abs) && i3[i3.length - 1].abs.push(s3);
          }
        }
        r3 = e3 ? null : "stroke" === t2 ? "stroke" : "fill";
        for (var g3 = false, b3 = 0; b3 < i3.length; b3++) if (i3[b3].arc) for (var y3 = i3[b3].abs, w3 = 0; w3 < y3.length; w3++) {
          var N3 = y3[w3];
          "arc" === N3.type ? P2.call(this, N3.x, N3.y, N3.radius, N3.startAngle, N3.endAngle, N3.counterclockwise, void 0, e3, !g3) : C2.call(this, N3.x, N3.y), g3 = true;
        }
        else if (true === i3[b3].close) this.pdf.internal.out("h"), g3 = false;
        else if (true !== i3[b3].begin) {
          var L3 = i3[b3].start.x, x3 = i3[b3].start.y;
          O2.call(this, i3[b3].deltas, L3, x3), g3 = true;
        }
        r3 && k2.call(this, r3), e3 && F2.call(this);
      }
    }, S2 = function(t2) {
      var e3 = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, n3 = e3 * (this.pdf.internal.getLineHeightFactor() - 1);
      switch (this.ctx.textBaseline) {
        case "bottom":
          return t2 - n3;
        case "top":
          return t2 + e3 - n3;
        case "hanging":
          return t2 + e3 - 2 * n3;
        case "middle":
          return t2 + e3 / 2 - n3;
        default:
          return t2;
      }
    }, _2 = function(t2) {
      return t2 + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1);
    };
    p2.prototype.createLinearGradient = function() {
      var t2 = function() {
      };
      return t2.colorStops = [], t2.addColorStop = function(t3, e3) {
        this.colorStops.push([t3, e3]);
      }, t2.getColor = function() {
        return 0 === this.colorStops.length ? "#000000" : this.colorStops[0][1];
      }, t2.isCanvasGradient = true, t2;
    }, p2.prototype.createPattern = function() {
      return this.createLinearGradient();
    }, p2.prototype.createRadialGradient = function() {
      return this.createLinearGradient();
    };
    var P2 = function(t2, e3, n3, r3, i3, a3, o2, s3, u3) {
      for (var c3 = M2.call(this, n3, r3, i3, a3), l3 = 0; l3 < c3.length; l3++) {
        var h2 = c3[l3];
        0 === l3 && (u3 ? I2.call(this, h2.x1 + t2, h2.y1 + e3) : C2.call(this, h2.x1 + t2, h2.y1 + e3)), B3.call(this, t2, e3, h2.x2, h2.y2, h2.x3, h2.y3, h2.x4, h2.y4);
      }
      s3 ? F2.call(this) : k2.call(this, o2);
    }, k2 = function(t2) {
      switch (t2) {
        case "stroke":
          this.pdf.internal.out("S");
          break;
        case "fill":
          this.pdf.internal.out("f");
      }
    }, F2 = function() {
      this.pdf.clip(), this.pdf.discardPath();
    }, I2 = function(t2, e3) {
      this.pdf.internal.out(r2(t2) + " " + i2(e3) + " m");
    }, j2 = function(t2) {
      var e3;
      switch (t2.align) {
        case "right":
        case "end":
          e3 = "right";
          break;
        case "center":
          e3 = "center";
          break;
        default:
          e3 = "left";
      }
      var n3, r3, i3, a3 = this.pdf.getTextDimensions(t2.text), o2 = S2.call(this, t2.y), s3 = _2.call(this, o2) - a3.h, h2 = this.ctx.transform.applyToPoint(new u2(t2.x, o2));
      if (this.autoPaging) {
        var f3 = this.ctx.transform.decompose(), d3 = new l2();
        d3 = (d3 = (d3 = d3.multiply(f3.translate)).multiply(f3.skew)).multiply(f3.scale);
        for (var p3 = this.ctx.transform.applyToRectangle(new c2(t2.x, o2, a3.w, a3.h)), g3 = d3.applyToRectangle(new c2(t2.x, s3, a3.w, a3.h)), m3 = y2.call(this, g3), v3 = [], w3 = 0; w3 < m3.length; w3 += 1) -1 === v3.indexOf(m3[w3]) && v3.push(m3[w3]);
        L2(v3);
        for (var x3 = v3[0], P3 = v3[v3.length - 1], k3 = x3; k3 < P3 + 1; k3++) {
          this.pdf.setPage(k3);
          var F3 = 1 === k3 ? this.posY + this.margin[0] : this.margin[0], I3 = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], j3 = this.pdf.internal.pageSize.height - this.margin[2], C3 = j3 - this.margin[0], O3 = this.pdf.internal.pageSize.width - this.margin[1], B4 = O3 - this.margin[3], M3 = 1 === k3 ? 0 : I3 + (k3 - 2) * C3;
          if (0 !== this.ctx.clip_path.length) {
            var q3 = this.path;
            n3 = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = N2(n3, this.posX + this.margin[3], -1 * M3 + F3), A2.call(this, "fill", true), this.path = q3;
          }
          var E3 = N2([JSON.parse(JSON.stringify(g3))], this.posX + this.margin[3], -M3 + F3 + this.ctx.prevPageLastElemOffset)[0];
          t2.scale >= 0.01 && (r3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(r3 * t2.scale), i3 = this.lineWidth, this.lineWidth = i3 * t2.scale);
          var R3 = "text" !== this.autoPaging;
          if (R3 || E3.y + E3.h <= j3) {
            if (R3 || E3.y >= F3 && E3.x <= O3) {
              var D3 = R3 ? t2.text : this.pdf.splitTextToSize(t2.text, t2.maxWidth || O3 - E3.x)[0], T3 = N2([JSON.parse(JSON.stringify(p3))], this.posX + this.margin[3], -M3 + F3 + this.ctx.prevPageLastElemOffset)[0], z2 = R3 && (k3 > x3 || k3 < P3) && b2.call(this);
              z2 && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], B4, C3, null).clip().discardPath()), this.pdf.text(D3, T3.x, T3.y, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode }), z2 && this.pdf.restoreGraphicsState();
            }
          } else E3.y < j3 && (this.ctx.prevPageLastElemOffset += j3 - E3.y);
          t2.scale >= 0.01 && (this.pdf.setFontSize(r3), this.lineWidth = i3);
        }
      } else t2.scale >= 0.01 && (r3 = this.pdf.internal.getFontSize(), this.pdf.setFontSize(r3 * t2.scale), i3 = this.lineWidth, this.lineWidth = i3 * t2.scale), this.pdf.text(t2.text, h2.x + this.posX, h2.y + this.posY, { angle: t2.angle, align: e3, renderingMode: t2.renderingMode, maxWidth: t2.maxWidth }), t2.scale >= 0.01 && (this.pdf.setFontSize(r3), this.lineWidth = i3);
    }, C2 = function(t2, e3, n3, a3) {
      n3 = n3 || 0, a3 = a3 || 0, this.pdf.internal.out(r2(t2 + n3) + " " + i2(e3 + a3) + " l");
    }, O2 = function(t2, e3, n3) {
      return this.pdf.lines(t2, e3, n3, null, null);
    }, B3 = function(t2, e3, r3, i3, o2, u3, c3, l3) {
      this.pdf.internal.out([n2(a2(r3 + t2)), n2(s2(i3 + e3)), n2(a2(o2 + t2)), n2(s2(u3 + e3)), n2(a2(c3 + t2)), n2(s2(l3 + e3)), "c"].join(" "));
    }, M2 = function(t2, e3, n3, r3) {
      for (var i3 = 2 * Math.PI, a3 = Math.PI / 2; e3 > n3; ) e3 -= i3;
      var o2 = Math.abs(n3 - e3);
      o2 < i3 && r3 && (o2 = i3 - o2);
      for (var s3 = [], u3 = r3 ? -1 : 1, c3 = e3; o2 > 1e-5; ) {
        var l3 = c3 + u3 * Math.min(o2, a3);
        s3.push(q2.call(this, t2, c3, l3)), o2 -= Math.abs(l3 - c3), c3 = l3;
      }
      return s3;
    }, q2 = function(t2, e3, n3) {
      var r3 = (n3 - e3) / 2, i3 = t2 * Math.cos(r3), a3 = t2 * Math.sin(r3), o2 = i3, s3 = -a3, u3 = o2 * o2 + s3 * s3, c3 = u3 + o2 * i3 + s3 * a3, l3 = 4 / 3 * (Math.sqrt(2 * u3 * c3) - c3) / (o2 * a3 - s3 * i3), h2 = o2 - l3 * s3, f3 = s3 + l3 * o2, d3 = h2, p3 = -f3, g3 = r3 + e3, m3 = Math.cos(g3), v3 = Math.sin(g3);
      return { x1: t2 * Math.cos(e3), y1: t2 * Math.sin(e3), x2: h2 * m3 - f3 * v3, y2: h2 * v3 + f3 * m3, x3: d3 * m3 - p3 * v3, y3: d3 * v3 + p3 * m3, x4: t2 * Math.cos(n3), y4: t2 * Math.sin(n3) };
    }, E2 = function(t2) {
      return 180 * t2 / Math.PI;
    }, R2 = function(t2, e3, n3, r3, i3, a3) {
      var o2 = t2 + 0.5 * (n3 - t2), s3 = e3 + 0.5 * (r3 - e3), u3 = i3 + 0.5 * (n3 - i3), l3 = a3 + 0.5 * (r3 - a3), h2 = Math.min(t2, i3, o2, u3), f3 = Math.max(t2, i3, o2, u3), d3 = Math.min(e3, a3, s3, l3), p3 = Math.max(e3, a3, s3, l3);
      return new c2(h2, d3, f3 - h2, p3 - d3);
    }, D2 = function(t2, e3, n3, r3, i3, a3, o2, s3) {
      var u3, l3, h2, f3, d3, p3, g3, m3, v3, b3, y3, w3, N3, L3, x3 = n3 - t2, A3 = r3 - e3, S3 = i3 - n3, _3 = a3 - r3, P3 = o2 - i3, k3 = s3 - a3;
      for (l3 = 0; l3 < 41; l3++) v3 = (g3 = (h2 = t2 + (u3 = l3 / 40) * x3) + u3 * ((d3 = n3 + u3 * S3) - h2)) + u3 * (d3 + u3 * (i3 + u3 * P3 - d3) - g3), b3 = (m3 = (f3 = e3 + u3 * A3) + u3 * ((p3 = r3 + u3 * _3) - f3)) + u3 * (p3 + u3 * (a3 + u3 * k3 - p3) - m3), 0 == l3 ? (y3 = v3, w3 = b3, N3 = v3, L3 = b3) : (y3 = Math.min(y3, v3), w3 = Math.min(w3, b3), N3 = Math.max(N3, v3), L3 = Math.max(L3, b3));
      return new c2(Math.round(y3), Math.round(w3), Math.round(N3 - y3), Math.round(L3 - w3));
    }, T2 = function() {
      if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) {
        var t2, e3, n3 = (t2 = this.ctx.lineDash, e3 = this.ctx.lineDashOffset, JSON.stringify({ lineDash: t2, lineDashOffset: e3 }));
        this.prevLineDash !== n3 && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = n3);
      }
    };
  })(E$1.API), /**
   * @license
   * jsPDF filters PlugIn
   * Copyright (c) 2014 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var n2 = function(t3) {
      var e2, n3, r3, i3, a3, o3, s2, u2, c2, l2;
      for (n3 = [], r3 = 0, i3 = (t3 += e2 = "\0\0\0\0".slice(t3.length % 4 || 4)).length; i3 > r3; r3 += 4) 0 !== (a3 = (t3.charCodeAt(r3) << 24) + (t3.charCodeAt(r3 + 1) << 16) + (t3.charCodeAt(r3 + 2) << 8) + t3.charCodeAt(r3 + 3)) ? (o3 = (a3 = ((a3 = ((a3 = ((a3 = (a3 - (l2 = a3 % 85)) / 85) - (c2 = a3 % 85)) / 85) - (u2 = a3 % 85)) / 85) - (s2 = a3 % 85)) / 85) % 85, n3.push(o3 + 33, s2 + 33, u2 + 33, c2 + 33, l2 + 33)) : n3.push(122);
      return (function(t4, e3) {
        for (var n4 = e3; n4 > 0; n4--) t4.pop();
      })(n3, e2.length), String.fromCharCode.apply(String, n3) + "~>";
    }, r2 = function(t3) {
      var e2, n3, r3, i3, a3, o3 = String, s2 = "length", u2 = 255, c2 = "charCodeAt", l2 = "slice", h2 = "replace";
      for (t3[l2](-2), t3 = t3[l2](0, -2)[h2](/\s/g, "")[h2]("z", "!!!!!"), r3 = [], i3 = 0, a3 = (t3 += e2 = "uuuuu"[l2](t3[s2] % 5 || 5))[s2]; a3 > i3; i3 += 5) n3 = 52200625 * (t3[c2](i3) - 33) + 614125 * (t3[c2](i3 + 1) - 33) + 7225 * (t3[c2](i3 + 2) - 33) + 85 * (t3[c2](i3 + 3) - 33) + (t3[c2](i3 + 4) - 33), r3.push(u2 & n3 >> 24, u2 & n3 >> 16, u2 & n3 >> 8, u2 & n3);
      return (function(t4, e3) {
        for (var n4 = e3; n4 > 0; n4--) t4.pop();
      })(r3, e2[s2]), o3.fromCharCode.apply(o3, r3);
    }, i2 = function(t3) {
      return t3.split("").map(function(t4) {
        return ("0" + t4.charCodeAt().toString(16)).slice(-2);
      }).join("") + ">";
    }, a2 = function(t3) {
      var e2 = new RegExp(/^([0-9A-Fa-f]{2})+$/);
      if (-1 !== (t3 = t3.replace(/\s/g, "")).indexOf(">") && (t3 = t3.substr(0, t3.indexOf(">"))), t3.length % 2 && (t3 += "0"), false === e2.test(t3)) return "";
      for (var n3 = "", r3 = 0; r3 < t3.length; r3 += 2) n3 += String.fromCharCode("0x" + (t3[r3] + t3[r3 + 1]));
      return n3;
    }, o2 = function(t3) {
      for (var n3 = new Uint8Array(t3.length), r3 = t3.length; r3--; ) n3[r3] = t3.charCodeAt(r3);
      return (n3 = zlibSync(n3)).reduce(function(t4, e2) {
        return t4 + String.fromCharCode(e2);
      }, "");
    };
    t2.processDataByFilters = function(t3, e2) {
      var s2 = 0, u2 = t3 || "", c2 = [];
      for ("string" == typeof (e2 = e2 || []) && (e2 = [e2]), s2 = 0; s2 < e2.length; s2 += 1) switch (e2[s2]) {
        case "ASCII85Decode":
        case "/ASCII85Decode":
          u2 = r2(u2), c2.push("/ASCII85Encode");
          break;
        case "ASCII85Encode":
        case "/ASCII85Encode":
          u2 = n2(u2), c2.push("/ASCII85Decode");
          break;
        case "ASCIIHexDecode":
        case "/ASCIIHexDecode":
          u2 = a2(u2), c2.push("/ASCIIHexEncode");
          break;
        case "ASCIIHexEncode":
        case "/ASCIIHexEncode":
          u2 = i2(u2), c2.push("/ASCIIHexDecode");
          break;
        case "FlateEncode":
        case "/FlateEncode":
          u2 = o2(u2), c2.push("/FlateDecode");
          break;
        default:
          throw new Error('The filter: "' + e2[s2] + '" is not implemented');
      }
      return { data: u2, reverseChain: c2.reverse().join(" ") };
    };
  })(E$1.API), /**
   * @license
   * jsPDF fileloading PlugIn
   * Copyright (c) 2018 Aras Abbasi (aras.abbasi@gmail.com)
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    t2.loadFile = function(t3, e2, n2) {
      return (function(t4, e3, n3) {
        e3 = false !== e3, n3 = "function" == typeof n3 ? n3 : function() {
        };
        var r2 = void 0;
        try {
          r2 = (function(t5, e4, n4) {
            var r3 = new XMLHttpRequest(), i2 = 0, a2 = function(t6) {
              var e5 = t6.length, n5 = [], r4 = String.fromCharCode;
              for (i2 = 0; i2 < e5; i2 += 1) n5.push(r4(255 & t6.charCodeAt(i2)));
              return n5.join("");
            };
            if (r3.open("GET", t5, !e4), r3.overrideMimeType("text/plain; charset=x-user-defined"), false === e4 && (r3.onload = function() {
              200 === r3.status ? n4(a2(this.responseText)) : n4(void 0);
            }), r3.send(null), e4 && 200 === r3.status) return a2(r3.responseText);
          })(t4, e3, n3);
        } catch (i2) {
        }
        return r2;
      })(t3, e2, n2);
    }, t2.allowFsRead = void 0, t2.loadImageFile = t2.loadFile;
  })(E$1.API), (function(e2) {
    function n2() {
      return (i$5.html2canvas ? Promise.resolve(i$5.html2canvas) : Promise.resolve().then(() => html2canvas_esm)).catch(function(t2) {
        return Promise.reject(new Error("Could not load html2canvas: " + t2));
      }).then(function(t2) {
        return t2.default ? t2.default : t2;
      });
    }
    function r2() {
      return (i$5.DOMPurify ? Promise.resolve(i$5.DOMPurify) : Promise.resolve().then(() => purify_es)).catch(function(t2) {
        return Promise.reject(new Error("Could not load dompurify: " + t2));
      }).then(function(t2) {
        return t2.default ? t2.default : t2;
      });
    }
    var a2 = function(e3) {
      var n3 = _typeof$1(e3);
      return "undefined" === n3 ? "undefined" : "string" === n3 || e3 instanceof String ? "string" : "number" === n3 || e3 instanceof Number ? "number" : "function" === n3 || e3 instanceof Function ? "function" : e3 && e3.constructor === Array ? "array" : e3 && 1 === e3.nodeType ? "element" : "object" === n3 ? "object" : "unknown";
    }, o2 = function(t2, e3) {
      var n3 = document.createElement(t2);
      for (var r3 in e3.className && (n3.className = e3.className), e3.innerHTML && e3.dompurify && (n3.innerHTML = e3.dompurify.sanitize(e3.innerHTML)), e3.style) n3.style[r3] = e3.style[r3];
      return n3;
    }, s2 = function t2(e3, n3) {
      for (var r3 = 3 === e3.nodeType ? document.createTextNode(e3.nodeValue) : e3.cloneNode(false), i2 = e3.firstChild; i2; i2 = i2.nextSibling) true !== n3 && 1 === i2.nodeType && "SCRIPT" === i2.nodeName || r3.appendChild(t2(i2, n3));
      return 1 === e3.nodeType && ("CANVAS" === e3.nodeName ? (r3.width = e3.width, r3.height = e3.height, r3.getContext("2d").drawImage(e3, 0, 0)) : "TEXTAREA" !== e3.nodeName && "SELECT" !== e3.nodeName || (r3.value = e3.value), r3.addEventListener("load", function() {
        r3.scrollTop = e3.scrollTop, r3.scrollLeft = e3.scrollLeft;
      }, true)), r3;
    }, u2 = function t2(e3) {
      var n3 = Object.assign(t2.convert(Promise.resolve()), JSON.parse(JSON.stringify(t2.template))), r3 = t2.convert(Promise.resolve(), n3);
      return (r3 = r3.setProgress(1, t2, 1, [t2])).set(e3);
    };
    (u2.prototype = Object.create(Promise.prototype)).constructor = u2, u2.convert = function(t2, e3) {
      return t2.__proto__ = e3 || u2.prototype, t2;
    }, u2.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function() {
    } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: true, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, u2.prototype.from = function(t2, e3) {
      return this.then(function() {
        switch (e3 = e3 || (function(t3) {
          switch (a2(t3)) {
            case "string":
              return "string";
            case "element":
              return "canvas" === t3.nodeName.toLowerCase() ? "canvas" : "element";
            default:
              return "unknown";
          }
        })(t2), e3) {
          case "string":
            return this.then(r2).then(function(e4) {
              return this.set({ src: o2("div", { innerHTML: t2, dompurify: e4 }) });
            });
          case "element":
            return this.set({ src: t2 });
          case "canvas":
            return this.set({ canvas: t2 });
          case "img":
            return this.set({ img: t2 });
          default:
            return this.error("Unknown source type.");
        }
      });
    }, u2.prototype.to = function(t2) {
      switch (t2) {
        case "container":
          return this.toContainer();
        case "canvas":
          return this.toCanvas();
        case "img":
          return this.toImg();
        case "pdf":
          return this.toPdf();
        default:
          return this.error("Invalid target.");
      }
    }, u2.prototype.toContainer = function() {
      return this.thenList([function() {
        return this.prop.src || this.error("Cannot duplicate - no source HTML.");
      }, function() {
        return this.prop.pageSize || this.setPageSize();
      }]).then(function() {
        var t2 = { position: "relative", display: "inline-block", width: ("number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, e3 = s2(this.prop.src, this.opt.html2canvas.javascriptEnabled);
        "BODY" === e3.tagName && (t2.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = o2("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = o2("div", { className: "html2pdf__container", style: t2 }), this.prop.container.appendChild(e3), this.prop.container.firstChild.appendChild(o2("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px";
      });
    }, u2.prototype.toCanvas = function() {
      var t2 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t2).then(n2).then(function(t3) {
        var e3 = Object.assign({}, this.opt.html2canvas);
        return delete e3.onrendered, t3(this.prop.container, e3);
      }).then(function(t3) {
        (this.opt.html2canvas.onrendered || function() {
        })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
      });
    }, u2.prototype.toContext2d = function() {
      var t2 = [function() {
        return document.body.contains(this.prop.container) || this.toContainer();
      }];
      return this.thenList(t2).then(n2).then(function(t3) {
        var e3 = this.opt.jsPDF, n3 = this.opt.fontFaces, r3 = "number" != typeof this.opt.width || isNaN(this.opt.width) || "number" != typeof this.opt.windowWidth || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, i2 = Object.assign({ async: true, allowTaint: true, scale: r3, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: true, proxy: null, removeContainer: true, foreignObjectRendering: false, useCORS: false }, this.opt.html2canvas);
        if (delete i2.onrendered, e3.context2d.autoPaging = void 0 === this.opt.autoPaging || this.opt.autoPaging, e3.context2d.posX = this.opt.x, e3.context2d.posY = this.opt.y, e3.context2d.margin = this.opt.margin, e3.context2d.fontFaces = n3, n3) for (var a3 = 0; a3 < n3.length; ++a3) {
          var o3 = n3[a3], s3 = o3.src.find(function(t4) {
            return "truetype" === t4.format;
          });
          s3 && e3.addFont(s3.url, o3.ref.name, o3.ref.style);
        }
        return i2.windowHeight = i2.windowHeight || 0, i2.windowHeight = 0 == i2.windowHeight ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : i2.windowHeight, e3.context2d.save(true), t3(this.prop.container, i2);
      }).then(function(t3) {
        this.opt.jsPDF.context2d.restore(true), (this.opt.html2canvas.onrendered || function() {
        })(t3), this.prop.canvas = t3, document.body.removeChild(this.prop.overlay);
      });
    }, u2.prototype.toImg = function() {
      return this.thenList([function() {
        return this.prop.canvas || this.toCanvas();
      }]).then(function() {
        var t2 = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality);
        this.prop.img = document.createElement("img"), this.prop.img.src = t2;
      });
    }, u2.prototype.toPdf = function() {
      return this.thenList([function() {
        return this.toContext2d();
      }]).then(function() {
        this.prop.pdf = this.prop.pdf || this.opt.jsPDF;
      });
    }, u2.prototype.output = function(t2, e3, n3) {
      return "img" === (n3 = n3 || "pdf").toLowerCase() || "image" === n3.toLowerCase() ? this.outputImg(t2, e3) : this.outputPdf(t2, e3);
    }, u2.prototype.outputPdf = function(t2, e3) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        return this.prop.pdf.output(t2, e3);
      });
    }, u2.prototype.outputImg = function(t2) {
      return this.thenList([function() {
        return this.prop.img || this.toImg();
      }]).then(function() {
        switch (t2) {
          case void 0:
          case "img":
            return this.prop.img;
          case "datauristring":
          case "dataurlstring":
            return this.prop.img.src;
          case "datauri":
          case "dataurl":
            return document.location.href = this.prop.img.src;
          default:
            throw 'Image output type "' + t2 + '" is not supported.';
        }
      });
    }, u2.prototype.save = function(t2) {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).set(t2 ? { filename: t2 } : null).then(function() {
        this.prop.pdf.save(this.opt.filename);
      });
    }, u2.prototype.doCallback = function() {
      return this.thenList([function() {
        return this.prop.pdf || this.toPdf();
      }]).then(function() {
        this.prop.callback(this.prop.pdf);
      });
    }, u2.prototype.set = function(t2) {
      if ("object" !== a2(t2)) return this;
      var e3 = Object.keys(t2 || {}).map(function(e4) {
        if (e4 in u2.template.prop) return function() {
          this.prop[e4] = t2[e4];
        };
        switch (e4) {
          case "margin":
            return this.setMargin.bind(this, t2.margin);
          case "jsPDF":
            return function() {
              return this.opt.jsPDF = t2.jsPDF, this.setPageSize();
            };
          case "pageSize":
            return this.setPageSize.bind(this, t2.pageSize);
          default:
            return function() {
              this.opt[e4] = t2[e4];
            };
        }
      }, this);
      return this.then(function() {
        return this.thenList(e3);
      });
    }, u2.prototype.get = function(t2, e3) {
      return this.then(function() {
        var n3 = t2 in u2.template.prop ? this.prop[t2] : this.opt[t2];
        return e3 ? e3(n3) : n3;
      });
    }, u2.prototype.setMargin = function(t2) {
      return this.then(function() {
        switch (a2(t2)) {
          case "number":
            t2 = [t2, t2, t2, t2];
          case "array":
            if (2 === t2.length && (t2 = [t2[0], t2[1], t2[0], t2[1]]), 4 === t2.length) break;
          default:
            return this.error("Invalid margin array.");
        }
        this.opt.margin = t2;
      }).then(this.setPageSize);
    }, u2.prototype.setPageSize = function(t2) {
      function e3(t3, e4) {
        return Math.floor(t3 * e4 / 72 * 96);
      }
      return this.then(function() {
        (t2 = t2 || E$1.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (t2.inner = { width: t2.width - this.opt.margin[1] - this.opt.margin[3], height: t2.height - this.opt.margin[0] - this.opt.margin[2] }, t2.inner.px = { width: e3(t2.inner.width, t2.k), height: e3(t2.inner.height, t2.k) }, t2.inner.ratio = t2.inner.height / t2.inner.width), this.prop.pageSize = t2;
      });
    }, u2.prototype.setProgress = function(t2, e3, n3, r3) {
      return null != t2 && (this.progress.val = t2), null != e3 && (this.progress.state = e3), null != n3 && (this.progress.n = n3), null != r3 && (this.progress.stack = r3), this.progress.ratio = this.progress.val / this.progress.state, this;
    }, u2.prototype.updateProgress = function(t2, e3, n3, r3) {
      return this.setProgress(t2 ? this.progress.val + t2 : null, e3 || null, n3 ? this.progress.n + n3 : null, r3 ? this.progress.stack.concat(r3) : null);
    }, u2.prototype.then = function(t2, e3) {
      var n3 = this;
      return this.thenCore(t2, e3, function(t3, e4) {
        return n3.updateProgress(null, null, 1, [t3]), Promise.prototype.then.call(this, function(e5) {
          return n3.updateProgress(null, t3), e5;
        }).then(t3, e4).then(function(t4) {
          return n3.updateProgress(1), t4;
        });
      });
    }, u2.prototype.thenCore = function(t2, e3, n3) {
      n3 = n3 || Promise.prototype.then;
      var r3 = this;
      t2 && (t2 = t2.bind(r3)), e3 && (e3 = e3.bind(r3));
      var i2 = -1 !== Promise.toString().indexOf("[native code]") && "Promise" === Promise.name ? r3 : u2.convert(Object.assign({}, r3), Promise.prototype), a3 = n3.call(i2, t2, e3);
      return u2.convert(a3, r3.__proto__);
    }, u2.prototype.thenExternal = function(t2, e3) {
      return Promise.prototype.then.call(this, t2, e3);
    }, u2.prototype.thenList = function(t2) {
      var e3 = this;
      return t2.forEach(function(t3) {
        e3 = e3.thenCore(t3);
      }), e3;
    }, u2.prototype.catch = function(t2) {
      t2 && (t2 = t2.bind(this));
      var e3 = Promise.prototype.catch.call(this, t2);
      return u2.convert(e3, this);
    }, u2.prototype.catchExternal = function(t2) {
      return Promise.prototype.catch.call(this, t2);
    }, u2.prototype.error = function(t2) {
      return this.then(function() {
        throw new Error(t2);
      });
    }, u2.prototype.using = u2.prototype.set, u2.prototype.saveAs = u2.prototype.save, u2.prototype.export = u2.prototype.output, u2.prototype.run = u2.prototype.then, E$1.getPageSize = function(e3, n3, r3) {
      if ("object" === _typeof$1(e3)) {
        var i2 = e3;
        e3 = i2.orientation, n3 = i2.unit || n3, r3 = i2.format || r3;
      }
      n3 = n3 || "mm", r3 = r3 || "a4", e3 = ("" + (e3 || "P")).toLowerCase();
      var a3, o3 = ("" + r3).toLowerCase(), s3 = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] };
      switch (n3) {
        case "pt":
          a3 = 1;
          break;
        case "mm":
          a3 = 72 / 25.4;
          break;
        case "cm":
          a3 = 72 / 2.54;
          break;
        case "in":
          a3 = 72;
          break;
        case "px":
          a3 = 0.75;
          break;
        case "pc":
        case "em":
          a3 = 12;
          break;
        case "ex":
          a3 = 6;
          break;
        default:
          throw "Invalid unit: " + n3;
      }
      var u3, c2 = 0, l2 = 0;
      if (s3.hasOwnProperty(o3)) c2 = s3[o3][1] / a3, l2 = s3[o3][0] / a3;
      else try {
        c2 = r3[1], l2 = r3[0];
      } catch (h2) {
        throw new Error("Invalid format: " + r3);
      }
      if ("p" === e3 || "portrait" === e3) e3 = "p", l2 > c2 && (u3 = l2, l2 = c2, c2 = u3);
      else {
        if ("l" !== e3 && "landscape" !== e3) throw "Invalid orientation: " + e3;
        e3 = "l", c2 > l2 && (u3 = l2, l2 = c2, c2 = u3);
      }
      return { width: l2, height: c2, unit: n3, k: a3, orientation: e3 };
    }, e2.html = function(t2, e3) {
      (e3 = e3 || {}).callback = e3.callback || function() {
      }, e3.html2canvas = e3.html2canvas || {}, e3.html2canvas.canvas = e3.html2canvas.canvas || this.canvas, e3.jsPDF = e3.jsPDF || this, e3.fontFaces = e3.fontFaces ? e3.fontFaces.map(Ct) : null;
      var n3 = new u2(e3);
      return e3.worker ? n3 : n3.from(t2).doCallback();
    };
  })(E$1.API), E$1.API.addJS = function(t2) {
    return Ut = t2, this.internal.events.subscribe("postPutResources", function() {
      Tt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Tt + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ut + ")"), this.internal.out(">>"), this.internal.out("endobj");
    }), this.internal.events.subscribe("putCatalog", function() {
      void 0 !== Tt && void 0 !== zt && this.internal.out("/Names <</JavaScript " + Tt + " 0 R>>");
    }), this;
  }, /**
   * @license
   * Copyright (c) 2014 Steven Spungin (TwelveTone LLC)  steven@twelvetone.tv
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2;
    t2.events.push(["postPutResources", function() {
      var t3 = this, n2 = /^(\d+) 0 obj$/;
      if (this.outline.root.children.length > 0) for (var r2 = t3.outline.render().split(/\r\n/), i2 = 0; i2 < r2.length; i2++) {
        var a2 = r2[i2], o2 = n2.exec(a2);
        if (null != o2) {
          var s2 = o2[1];
          t3.internal.newObjectDeferredBegin(s2, false);
        }
        t3.internal.write(a2);
      }
      if (this.outline.createNamedDestinations) {
        var u2 = this.internal.pages.length, c2 = [];
        for (i2 = 0; i2 < u2; i2++) {
          var l2 = t3.internal.newObject();
          c2.push(l2);
          var h2 = t3.internal.getPageInfo(i2 + 1);
          t3.internal.write("<< /D[" + h2.objId + " 0 R /XYZ null null null]>> endobj");
        }
        var f2 = t3.internal.newObject();
        for (t3.internal.write("<< /Names [ "), i2 = 0; i2 < c2.length; i2++) t3.internal.write("(page_" + (i2 + 1) + ")" + c2[i2] + " 0 R");
        t3.internal.write(" ] >>", "endobj"), e2 = t3.internal.newObject(), t3.internal.write("<< /Dests " + f2 + " 0 R"), t3.internal.write(">>", "endobj");
      }
    }]), t2.events.push(["putCatalog", function() {
      var t3 = this;
      t3.outline.root.children.length > 0 && (t3.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t3.internal.write("/Names " + e2 + " 0 R"));
    }]), t2.events.push(["initialized", function() {
      var t3 = this;
      t3.outline = { createNamedDestinations: false, root: { children: [] } }, t3.outline.add = function(t4, e3, n2) {
        var r2 = { title: e3, options: n2, children: [] };
        return null == t4 && (t4 = this.root), t4.children.push(r2), r2;
      }, t3.outline.render = function() {
        return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = t3, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
      }, t3.outline.genIds_r = function(e3) {
        e3.id = t3.internal.newObjectDeferred();
        for (var n2 = 0; n2 < e3.children.length; n2++) this.genIds_r(e3.children[n2]);
      }, t3.outline.renderRoot = function(t4) {
        this.objStart(t4), this.line("/Type /Outlines"), t4.children.length > 0 && (this.line("/First " + this.makeRef(t4.children[0])), this.line("/Last " + this.makeRef(t4.children[t4.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, t4)), this.objEnd();
      }, t3.outline.renderItems = function(e3) {
        for (var n2 = this.ctx.pdf.internal.getVerticalCoordinateString, r2 = 0; r2 < e3.children.length; r2++) {
          var i2 = e3.children[r2];
          this.objStart(i2), this.line("/Title " + this.makeString(i2.title)), this.line("/Parent " + this.makeRef(e3)), r2 > 0 && this.line("/Prev " + this.makeRef(e3.children[r2 - 1])), r2 < e3.children.length - 1 && this.line("/Next " + this.makeRef(e3.children[r2 + 1])), i2.children.length > 0 && (this.line("/First " + this.makeRef(i2.children[0])), this.line("/Last " + this.makeRef(i2.children[i2.children.length - 1])));
          var a2 = this.count = this.count_r({ count: 0 }, i2);
          if (a2 > 0 && this.line("/Count " + a2), i2.options && i2.options.pageNumber) {
            var o2 = t3.internal.getPageInfo(i2.options.pageNumber);
            this.line("/Dest [" + o2.objId + " 0 R /XYZ 0 " + n2(0) + " 0]");
          }
          this.objEnd();
        }
        for (var s2 = 0; s2 < e3.children.length; s2++) this.renderItems(e3.children[s2]);
      }, t3.outline.line = function(t4) {
        this.ctx.val += t4 + "\r\n";
      }, t3.outline.makeRef = function(t4) {
        return t4.id + " 0 R";
      }, t3.outline.makeString = function(e3) {
        return "(" + t3.internal.pdfEscape(e3) + ")";
      }, t3.outline.objStart = function(t4) {
        this.ctx.val += "\r\n" + t4.id + " 0 obj\r\n<<\r\n";
      }, t3.outline.objEnd = function() {
        this.ctx.val += ">> \r\nendobj\r\n";
      }, t3.outline.count_r = function(t4, e3) {
        for (var n2 = 0; n2 < e3.children.length; n2++) t4.count++, this.count_r(t4, e3.children[n2]);
        return t4.count;
      };
    }]);
  })(E$1.API), /**
   * @license
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = [192, 193, 194, 195, 196, 197, 198, 199];
    t2.processJPEG = function(t3, n2, r2, i2, a2, o2) {
      var s2, u2 = this.decode.DCT_DECODE, c2 = null;
      if ("string" == typeof t3 || this.__addimage__.isArrayBuffer(t3) || this.__addimage__.isArrayBufferView(t3)) {
        switch (t3 = a2 || t3, t3 = this.__addimage__.isArrayBuffer(t3) ? new Uint8Array(t3) : t3, s2 = (function(t4) {
          for (var n3, r3 = 256 * t4.charCodeAt(4) + t4.charCodeAt(5), i3 = t4.length, a3 = { width: 0, height: 0, numcomponents: 1 }, o3 = 4; o3 < i3; o3 += 2) {
            if (o3 += r3, -1 !== e2.indexOf(t4.charCodeAt(o3 + 1))) {
              n3 = 256 * t4.charCodeAt(o3 + 5) + t4.charCodeAt(o3 + 6), a3 = { width: 256 * t4.charCodeAt(o3 + 7) + t4.charCodeAt(o3 + 8), height: n3, numcomponents: t4.charCodeAt(o3 + 9) };
              break;
            }
            r3 = 256 * t4.charCodeAt(o3 + 2) + t4.charCodeAt(o3 + 3);
          }
          return a3;
        })(t3 = this.__addimage__.isArrayBufferView(t3) ? this.__addimage__.arrayBufferToBinaryString(t3) : t3), s2.numcomponents) {
          case 1:
            o2 = this.color_spaces.DEVICE_GRAY;
            break;
          case 4:
            o2 = this.color_spaces.DEVICE_CMYK;
            break;
          case 3:
            o2 = this.color_spaces.DEVICE_RGB;
        }
        c2 = { data: t3, width: s2.width, height: s2.height, colorSpace: o2, bitsPerComponent: 8, filter: u2, index: n2, alias: r2 };
      }
      return c2;
    };
  })(E$1.API), E$1.API.processPNG = function(t2, i2, a2, o2) {
    if (this.__addimage__.isArrayBuffer(t2) && (t2 = new Uint8Array(t2)), this.__addimage__.isArrayBufferView(t2)) {
      var s2, u2 = decodePng(t2, { checkCrc: true }), c2 = u2.width, l2 = u2.height, h2 = u2.channels, f2 = u2.palette, d2 = u2.depth;
      s2 = f2 && 1 === h2 ? (function(t3) {
        for (var e2 = t3.width, r2 = t3.height, i3 = t3.data, a3 = t3.palette, o3 = t3.depth, s3 = false, u3 = [], c3 = [], l3 = void 0, h3 = false, f3 = 0, d3 = 0; d3 < a3.length; d3++) {
          var p3 = _slicedToArray(a3[d3], 4), g3 = p3[0], m3 = p3[1], v3 = p3[2], b3 = p3[3];
          u3.push(g3, m3, v3), null != b3 && (0 === b3 ? (f3++, c3.length < 1 && c3.push(d3)) : b3 < 255 && (h3 = true));
        }
        if (h3 || f3 > 1) {
          s3 = true, c3 = void 0;
          var y3 = e2 * r2;
          l3 = new Uint8Array(y3);
          for (var w3 = new DataView(i3.buffer), N3 = 0; N3 < y3; N3++) {
            var L3 = re(w3, N3, o3), x3 = _slicedToArray(a3[L3], 4)[3];
            l3[N3] = x3;
          }
        } else 0 === f3 && (c3 = void 0);
        return { colorSpace: "Indexed", colorsPerPixel: 1, sMaskBitsPerComponent: s3 ? 8 : void 0, colorBytes: i3, alphaBytes: l3, needSMask: s3, palette: u3, mask: c3 };
      })(u2) : 2 === h2 || 4 === h2 ? (function(t3) {
        for (var e2 = t3.data, n2 = t3.width, r2 = t3.height, i3 = t3.channels, a3 = t3.depth, o3 = 2 === i3 ? "DeviceGray" : "DeviceRGB", s3 = i3 - 1, u3 = n2 * r2, c3 = s3, l3 = u3 * c3, h3 = 1 * u3, f3 = Math.ceil(l3 * a3 / 8), d3 = Math.ceil(h3 * a3 / 8), p3 = new Uint8Array(f3), g3 = new Uint8Array(d3), m3 = new DataView(e2.buffer), v3 = new DataView(p3.buffer), b3 = new DataView(g3.buffer), y3 = false, w3 = 0; w3 < u3; w3++) {
          for (var N3 = w3 * i3, L3 = 0; L3 < c3; L3++) ie(v3, re(m3, N3 + L3, a3), w3 * c3 + L3, a3);
          var x3 = re(m3, N3 + c3, a3);
          x3 < (1 << a3) - 1 && (y3 = true), ie(b3, x3, 1 * w3, a3);
        }
        return { colorSpace: o3, colorsPerPixel: s3, sMaskBitsPerComponent: y3 ? a3 : void 0, colorBytes: p3, alphaBytes: g3, needSMask: y3 };
      })(u2) : (function(t3) {
        var e2 = t3.data, n2 = 1 === t3.channels ? "DeviceGray" : "DeviceRGB";
        return { colorSpace: n2, colorsPerPixel: "DeviceGray" === n2 ? 1 : 3, colorBytes: e2 instanceof Uint16Array ? (function(t4) {
          for (var e3 = t4.length, n3 = new Uint8Array(2 * e3), r2 = new DataView(n3.buffer, n3.byteOffset, n3.byteLength), i3 = 0; i3 < e3; i3++) r2.setUint16(2 * i3, t4[i3], false);
          return n3;
        })(e2) : e2, needSMask: false };
      })(u2);
      var p2, g2, m2, v2 = s2, b2 = v2.colorSpace, y2 = v2.colorsPerPixel, w2 = v2.sMaskBitsPerComponent, N2 = v2.colorBytes, L2 = v2.alphaBytes, x2 = v2.needSMask, A2 = v2.palette, S2 = v2.mask, _2 = null;
      return o2 !== E$1.API.image_compression.NONE && "function" == typeof zlibSync ? (_2 = (function(t3) {
        var e2;
        switch (t3) {
          case E$1.API.image_compression.FAST:
            e2 = 11;
            break;
          case E$1.API.image_compression.MEDIUM:
            e2 = 13;
            break;
          case E$1.API.image_compression.SLOW:
            e2 = 14;
            break;
          default:
            e2 = 12;
        }
        return e2;
      })(o2), p2 = this.decode.FLATE_DECODE, g2 = "/Predictor ".concat(_2, " /Colors ").concat(y2, " /BitsPerComponent ").concat(d2, " /Columns ").concat(c2), t2 = Xt(N2, Math.ceil(c2 * y2 * d2 / 8), y2, d2, o2), x2 && (m2 = Xt(L2, Math.ceil(c2 * w2 / 8), 1, w2, o2))) : (p2 = void 0, g2 = void 0, t2 = N2, x2 && (m2 = L2)), (this.__addimage__.isArrayBuffer(t2) || this.__addimage__.isArrayBufferView(t2)) && (t2 = this.__addimage__.arrayBufferToBinaryString(t2)), (m2 && this.__addimage__.isArrayBuffer(m2) || this.__addimage__.isArrayBufferView(m2)) && (m2 = this.__addimage__.arrayBufferToBinaryString(m2)), { alias: a2, data: t2, index: i2, filter: p2, decodeParameters: g2, transparency: S2, palette: A2, sMask: m2, predictor: _2, width: c2, height: l2, bitsPerComponent: d2, sMaskBitsPerComponent: w2, colorSpace: b2 };
    }
  }, (function(t2) {
    t2.processGIF89A = function(e2, n2, r2, i2) {
      var a2 = new oe(e2), o2 = a2.width, s2 = a2.height, u2 = [];
      a2.decodeAndBlitFrameRGBA(0, u2);
      var c2 = { data: u2, width: o2, height: s2 }, l2 = new ue(100).encode(c2, 100);
      return t2.processJPEG.call(this, l2, n2, r2, i2);
    }, t2.processGIF87A = t2.processGIF89A;
  })(E$1.API), ce.prototype.parseHeader = function() {
    if (this.fileSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, true), this.pos += 4, this.offset = this.datav.getUint32(this.pos, true), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.width = this.datav.getUint32(this.pos, true), this.pos += 4, this.height = this.datav.getInt32(this.pos, true), this.pos += 4, this.planes = this.datav.getUint16(this.pos, true), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, true), this.pos += 2, this.compress = this.datav.getUint32(this.pos, true), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, true), this.pos += 4, this.hr = this.datav.getUint32(this.pos, true), this.pos += 4, this.vr = this.datav.getUint32(this.pos, true), this.pos += 4, this.colors = this.datav.getUint32(this.pos, true), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, true), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
      var t2 = 0 === this.colors ? 1 << this.bitPP : this.colors;
      this.palette = new Array(t2);
      for (var e2 = 0; e2 < t2; e2++) {
        var n2 = this.datav.getUint8(this.pos++, true), r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true);
        this.palette[e2] = { red: i2, green: r2, blue: n2, quad: a2 };
      }
    }
    this.height < 0 && (this.height *= -1, this.bottom_up = false);
  }, ce.prototype.parseBGR = function() {
    this.pos = this.offset;
    try {
      var t2 = "bit" + this.bitPP, e2 = this.width * this.height * 4;
      this.data = new Uint8Array(e2), this[t2]();
    } catch (n2) {
      o$1.log("bit decode error:" + n2);
    }
  }, ce.prototype.bit1 = function() {
    var t2, e2 = Math.ceil(this.width / 8), n2 = e2 % 4;
    for (t2 = this.height - 1; t2 >= 0; t2--) {
      for (var r2 = this.bottom_up ? t2 : this.height - 1 - t2, i2 = 0; i2 < e2; i2++) for (var a2 = this.datav.getUint8(this.pos++, true), o2 = r2 * this.width * 4 + 8 * i2 * 4, s2 = 0; s2 < 8 && 8 * i2 + s2 < this.width; s2++) {
        var u2 = this.palette[a2 >> 7 - s2 & 1];
        this.data[o2 + 4 * s2] = u2.blue, this.data[o2 + 4 * s2 + 1] = u2.green, this.data[o2 + 4 * s2 + 2] = u2.red, this.data[o2 + 4 * s2 + 3] = 255;
      }
      0 !== n2 && (this.pos += 4 - n2);
    }
  }, ce.prototype.bit4 = function() {
    for (var t2 = Math.ceil(this.width / 2), e2 = t2 % 4, n2 = this.height - 1; n2 >= 0; n2--) {
      for (var r2 = this.bottom_up ? n2 : this.height - 1 - n2, i2 = 0; i2 < t2; i2++) {
        var a2 = this.datav.getUint8(this.pos++, true), o2 = r2 * this.width * 4 + 2 * i2 * 4, s2 = a2 >> 4, u2 = 15 & a2, c2 = this.palette[s2];
        if (this.data[o2] = c2.blue, this.data[o2 + 1] = c2.green, this.data[o2 + 2] = c2.red, this.data[o2 + 3] = 255, 2 * i2 + 1 >= this.width) break;
        c2 = this.palette[u2], this.data[o2 + 4] = c2.blue, this.data[o2 + 4 + 1] = c2.green, this.data[o2 + 4 + 2] = c2.red, this.data[o2 + 4 + 3] = 255;
      }
      0 !== e2 && (this.pos += 4 - e2);
    }
  }, ce.prototype.bit8 = function() {
    for (var t2 = this.width % 4, e2 = this.height - 1; e2 >= 0; e2--) {
      for (var n2 = this.bottom_up ? e2 : this.height - 1 - e2, r2 = 0; r2 < this.width; r2++) {
        var i2 = this.datav.getUint8(this.pos++, true), a2 = n2 * this.width * 4 + 4 * r2;
        if (i2 < this.palette.length) {
          var o2 = this.palette[i2];
          this.data[a2] = o2.red, this.data[a2 + 1] = o2.green, this.data[a2 + 2] = o2.blue, this.data[a2 + 3] = 255;
        } else this.data[a2] = 255, this.data[a2 + 1] = 255, this.data[a2 + 2] = 255, this.data[a2 + 3] = 255;
      }
      0 !== t2 && (this.pos += 4 - t2);
    }
  }, ce.prototype.bit15 = function() {
    for (var t2 = this.width % 3, e2 = parseInt("11111", 2), n2 = this.height - 1; n2 >= 0; n2--) {
      for (var r2 = this.bottom_up ? n2 : this.height - 1 - n2, i2 = 0; i2 < this.width; i2++) {
        var a2 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var o2 = (a2 & e2) / e2 * 255 | 0, s2 = (a2 >> 5 & e2) / e2 * 255 | 0, u2 = (a2 >> 10 & e2) / e2 * 255 | 0, c2 = a2 >> 15 ? 255 : 0, l2 = r2 * this.width * 4 + 4 * i2;
        this.data[l2] = u2, this.data[l2 + 1] = s2, this.data[l2 + 2] = o2, this.data[l2 + 3] = c2;
      }
      this.pos += t2;
    }
  }, ce.prototype.bit16 = function() {
    for (var t2 = this.width % 3, e2 = parseInt("11111", 2), n2 = parseInt("111111", 2), r2 = this.height - 1; r2 >= 0; r2--) {
      for (var i2 = this.bottom_up ? r2 : this.height - 1 - r2, a2 = 0; a2 < this.width; a2++) {
        var o2 = this.datav.getUint16(this.pos, true);
        this.pos += 2;
        var s2 = (o2 & e2) / e2 * 255 | 0, u2 = (o2 >> 5 & n2) / n2 * 255 | 0, c2 = (o2 >> 11) / e2 * 255 | 0, l2 = i2 * this.width * 4 + 4 * a2;
        this.data[l2] = c2, this.data[l2 + 1] = u2, this.data[l2 + 2] = s2, this.data[l2 + 3] = 255;
      }
      this.pos += t2;
    }
  }, ce.prototype.bit24 = function() {
    for (var t2 = this.height - 1; t2 >= 0; t2--) {
      for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, n2 = 0; n2 < this.width; n2++) {
        var r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = e2 * this.width * 4 + 4 * n2;
        this.data[o2] = a2, this.data[o2 + 1] = i2, this.data[o2 + 2] = r2, this.data[o2 + 3] = 255;
      }
      this.pos += this.width % 4;
    }
  }, ce.prototype.bit32 = function() {
    for (var t2 = this.height - 1; t2 >= 0; t2--) for (var e2 = this.bottom_up ? t2 : this.height - 1 - t2, n2 = 0; n2 < this.width; n2++) {
      var r2 = this.datav.getUint8(this.pos++, true), i2 = this.datav.getUint8(this.pos++, true), a2 = this.datav.getUint8(this.pos++, true), o2 = this.datav.getUint8(this.pos++, true), s2 = e2 * this.width * 4 + 4 * n2;
      this.data[s2] = a2, this.data[s2 + 1] = i2, this.data[s2 + 2] = r2, this.data[s2 + 3] = o2;
    }
  }, ce.prototype.getData = function() {
    return this.data;
  }, /**
   * @license
   * Copyright (c) 2018 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    t2.processBMP = function(e2, n2, r2, i2) {
      var a2 = new ce(e2, false), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue(100).encode(u2, 100);
      return t2.processJPEG.call(this, c2, n2, r2, i2);
    };
  })(E$1.API), le.prototype.getData = function() {
    return this.data;
  }, /**
   * @license
   * Copyright (c) 2019 Aras Abbasi
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    t2.processWEBP = function(e2, n2, r2, i2) {
      var a2 = new le(e2), o2 = a2.width, s2 = a2.height, u2 = { data: a2.getData(), width: o2, height: s2 }, c2 = new ue(100).encode(u2, 100);
      return t2.processJPEG.call(this, c2, n2, r2, i2);
    };
  })(E$1.API), E$1.API.processRGBA = function(t2, e2, n2) {
    for (var r2 = t2.data, i2 = r2.length, a2 = new Uint8Array(i2 / 4 * 3), o2 = new Uint8Array(i2 / 4), s2 = 0, u2 = 0, c2 = 0; c2 < i2; c2 += 4) {
      var l2 = r2[c2], h2 = r2[c2 + 1], f2 = r2[c2 + 2], d2 = r2[c2 + 3];
      a2[s2++] = l2, a2[s2++] = h2, a2[s2++] = f2, o2[u2++] = d2;
    }
    var p2 = this.__addimage__.arrayBufferToBinaryString(a2);
    return { alpha: this.__addimage__.arrayBufferToBinaryString(o2), data: p2, index: e2, alias: n2, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: t2.width, height: t2.height };
  }, E$1.API.setLanguage = function(t2) {
    return void 0 === this.internal.languageSettings && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = false), void 0 !== { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[t2] && (this.internal.languageSettings.languageCode = t2, false === this.internal.languageSettings.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
      this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")");
    }), this.internal.languageSettings.isSubscribed = true)), this;
  }, Ht = E$1.API, Wt = Ht.getCharWidthsArray = function(e2, n2) {
    var r2, i2, a2 = (n2 = n2 || {}).font || this.internal.getFont(), o2 = n2.fontSize || this.internal.getFontSize(), s2 = n2.charSpace || this.internal.getCharSpace(), u2 = n2.widths ? n2.widths : a2.metadata.Unicode.widths, c2 = u2.fof ? u2.fof : 1, l2 = n2.kerning ? n2.kerning : a2.metadata.Unicode.kerning, h2 = l2.fof ? l2.fof : 1, f2 = false !== n2.doKerning, d2 = 0, p2 = e2.length, g2 = 0, m2 = u2[0] || c2, v2 = [];
    for (r2 = 0; r2 < p2; r2++) i2 = e2.charCodeAt(r2), "function" == typeof a2.metadata.widthOfString ? v2.push((a2.metadata.widthOfGlyph(a2.metadata.characterToGlyph(i2)) + s2 * (1e3 / o2) || 0) / 1e3) : (d2 = f2 && "object" === _typeof$1(l2[i2]) && !isNaN(parseInt(l2[i2][g2], 10)) ? l2[i2][g2] / h2 : 0, v2.push((u2[i2] || m2) / c2 + d2)), g2 = i2;
    return v2;
  }, Vt = Ht.getStringUnitWidth = function(t2, e2) {
    var n2 = (e2 = e2 || {}).fontSize || this.internal.getFontSize(), r2 = e2.font || this.internal.getFont(), i2 = e2.charSpace || this.internal.getCharSpace();
    return Ht.processArabic && (t2 = Ht.processArabic(t2)), "function" == typeof r2.metadata.widthOfString ? r2.metadata.widthOfString(t2, n2, i2) / n2 : Wt.apply(this, arguments).reduce(function(t3, e3) {
      return t3 + e3;
    }, 0);
  }, Gt = function(t2, e2, n2, r2) {
    for (var i2 = [], a2 = 0, o2 = t2.length, s2 = 0; a2 !== o2 && s2 + e2[a2] < n2; ) s2 += e2[a2], a2++;
    i2.push(t2.slice(0, a2));
    var u2 = a2;
    for (s2 = 0; a2 !== o2; ) s2 + e2[a2] > r2 && (i2.push(t2.slice(u2, a2)), s2 = 0, u2 = a2), s2 += e2[a2], a2++;
    return u2 !== a2 && i2.push(t2.slice(u2, a2)), i2;
  }, Yt = function(t2, e2, n2) {
    n2 || (n2 = {});
    var r2, i2, a2, o2, s2, u2, c2, l2 = [], h2 = [l2], f2 = n2.textIndent || 0, d2 = 0, p2 = 0, g2 = t2.split(" "), m2 = Wt.apply(this, [" ", n2])[0];
    if (u2 = -1 === n2.lineIndent ? g2[0].length + 2 : n2.lineIndent || 0) {
      var v2 = Array(u2).join(" "), b2 = [];
      g2.map(function(t3) {
        (t3 = t3.split(/\s*\n/)).length > 1 ? b2 = b2.concat(t3.map(function(t4, e3) {
          return (e3 && t4.length ? "\n" : "") + t4;
        })) : b2.push(t3[0]);
      }), g2 = b2, u2 = Vt.apply(this, [v2, n2]);
    }
    for (a2 = 0, o2 = g2.length; a2 < o2; a2++) {
      var y2 = 0;
      if (r2 = g2[a2], u2 && "\n" == r2[0] && (r2 = r2.substr(1), y2 = 1), f2 + d2 + (p2 = (i2 = Wt.apply(this, [r2, n2])).reduce(function(t3, e3) {
        return t3 + e3;
      }, 0)) > e2 || y2) {
        if (p2 > e2) {
          for (s2 = Gt.apply(this, [r2, i2, e2 - (f2 + d2), e2]), l2.push(s2.shift()), l2 = [s2.pop()]; s2.length; ) h2.push([s2.shift()]);
          p2 = i2.slice(r2.length - (l2[0] ? l2[0].length : 0)).reduce(function(t3, e3) {
            return t3 + e3;
          }, 0);
        } else l2 = [r2];
        h2.push(l2), f2 = p2 + u2, d2 = m2;
      } else l2.push(r2), f2 += d2 + p2, d2 = m2;
    }
    return c2 = u2 ? function(t3, e3) {
      return (e3 ? v2 : "") + t3.join(" ");
    } : function(t3) {
      return t3.join(" ");
    }, h2.map(c2);
  }, Ht.splitTextToSize = function(t2, e2, n2) {
    var r2, i2 = (n2 = n2 || {}).fontSize || this.internal.getFontSize(), a2 = (function(t3) {
      if (t3.widths && t3.kerning) return { widths: t3.widths, kerning: t3.kerning };
      var e3 = this.internal.getFont(t3.fontName, t3.fontStyle), n3 = "Unicode";
      return e3.metadata[n3] ? { widths: e3.metadata[n3].widths || { 0: 1 }, kerning: e3.metadata[n3].kerning || {} } : { font: e3.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() };
    }).call(this, n2);
    r2 = Array.isArray(t2) ? t2 : String(t2).split(/\r?\n/);
    var o2 = 1 * this.internal.scaleFactor * e2 / i2;
    a2.textIndent = n2.textIndent ? 1 * n2.textIndent * this.internal.scaleFactor / i2 : 0, a2.lineIndent = n2.lineIndent;
    var s2, u2, c2 = [];
    for (s2 = 0, u2 = r2.length; s2 < u2; s2++) c2 = c2.concat(Yt.apply(this, [r2[s2], o2, a2]));
    return c2;
  }, (function(e2) {
    e2.__fontmetrics__ = e2.__fontmetrics__ || {};
    for (var n2 = "0123456789abcdef", r2 = "klmnopqrstuvwxyz", i2 = {}, a2 = {}, o2 = 0; o2 < 16; o2++) i2[r2[o2]] = n2[o2], a2[n2[o2]] = r2[o2];
    var s2 = function(t2) {
      return "0x" + parseInt(t2, 10).toString(16);
    }, u2 = e2.__fontmetrics__.compress = function(e3) {
      var n3, r3, i3, o3, c3 = ["{"];
      for (var l3 in e3) {
        if (n3 = e3[l3], isNaN(parseInt(l3, 10)) ? r3 = "'" + l3 + "'" : (l3 = parseInt(l3, 10), r3 = (r3 = s2(l3).slice(2)).slice(0, -1) + a2[r3.slice(-1)]), "number" == typeof n3) n3 < 0 ? (i3 = s2(n3).slice(3), o3 = "-") : (i3 = s2(n3).slice(2), o3 = ""), i3 = o3 + i3.slice(0, -1) + a2[i3.slice(-1)];
        else {
          if ("object" !== _typeof$1(n3)) throw new Error("Don't know what to do with value type " + _typeof$1(n3) + ".");
          i3 = u2(n3);
        }
        c3.push(r3 + i3);
      }
      return c3.push("}"), c3.join("");
    }, c2 = e2.__fontmetrics__.uncompress = function(t2) {
      if ("string" != typeof t2) throw new Error("Invalid argument passed to uncompress.");
      for (var e3, n3, r3, a3, o3 = {}, s3 = 1, u3 = o3, c3 = [], l3 = "", h3 = "", f3 = t2.length - 1, d2 = 1; d2 < f3; d2 += 1) "'" == (a3 = t2[d2]) ? e3 ? (r3 = e3.join(""), e3 = void 0) : e3 = [] : e3 ? e3.push(a3) : "{" == a3 ? (c3.push([u3, r3]), u3 = {}, r3 = void 0) : "}" == a3 ? ((n3 = c3.pop())[0][n3[1]] = u3, r3 = void 0, u3 = n3[0]) : "-" == a3 ? s3 = -1 : void 0 === r3 ? i2.hasOwnProperty(a3) ? (l3 += i2[a3], r3 = parseInt(l3, 16) * s3, s3 = 1, l3 = "") : l3 += a3 : i2.hasOwnProperty(a3) ? (h3 += i2[a3], u3[r3] = parseInt(h3, 16) * s3, s3 = 1, r3 = void 0, h3 = "") : h3 += a3;
      return o3;
    }, l2 = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: c2("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, h2 = { Unicode: { Courier: l2, "Courier-Bold": l2, "Courier-BoldOblique": l2, "Courier-Oblique": l2, Helvetica: l2, "Helvetica-Bold": l2, "Helvetica-BoldOblique": l2, "Helvetica-Oblique": l2, "Times-Roman": l2, "Times-Bold": l2, "Times-BoldItalic": l2, "Times-Italic": l2 } }, f2 = { Unicode: { "Courier-Oblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": c2("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": c2("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: c2("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": c2("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: c2("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": c2("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": c2("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": c2("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": c2("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } };
    e2.events.push(["addFont", function(t2) {
      var e3 = t2.font, n3 = f2.Unicode[e3.postScriptName];
      n3 && (e3.metadata.Unicode = {}, e3.metadata.Unicode.widths = n3.widths, e3.metadata.Unicode.kerning = n3.kerning);
      var r3 = h2.Unicode[e3.postScriptName];
      r3 && (e3.metadata.Unicode.encoding = r3, e3.encoding = r3.codePages[0]);
    }]);
  })(E$1.API), /**
   * @license
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = function(t3) {
      for (var e3 = t3.length, n2 = new Uint8Array(e3), r2 = 0; r2 < e3; r2++) n2[r2] = t3.charCodeAt(r2);
      return n2;
    };
    t2.API.events.push(["addFont", function(n2) {
      var r2 = void 0, i2 = n2.font, a2 = n2.instance;
      if (!i2.isStandardFont) {
        if (void 0 === a2) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
        if ("string" != typeof (r2 = false === a2.existsFileInVFS(i2.postScriptName) ? a2.loadFile(i2.postScriptName) : a2.getFileFromVFS(i2.postScriptName))) throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + i2.postScriptName + "').");
        !(function(n3, r3) {
          r3 = /^\x00\x01\x00\x00/.test(r3) ? e2(r3) : e2(f$2(r3)), n3.metadata = t2.API.TTFFont.open(r3), n3.metadata.Unicode = n3.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, n3.metadata.glyIdsUsed = [0];
        })(i2, r2);
      }
    }]);
  })(E$1), E$1.API.addSvgAsImage = function(t2, e2, n2, r2, a2, s2, u2, c2) {
    if (isNaN(e2) || isNaN(n2)) throw o$1.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage");
    if (isNaN(r2) || isNaN(a2)) throw o$1.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage");
    var l2 = document.createElement("canvas");
    l2.width = r2, l2.height = a2;
    var h2 = l2.getContext("2d");
    h2.fillStyle = "#fff", h2.fillRect(0, 0, l2.width, l2.height);
    var f2 = { ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true }, d2 = this;
    return (i$5.canvg ? Promise.resolve(i$5.canvg) : Promise.resolve().then(() => index_es)).catch(function(t3) {
      return Promise.reject(new Error("Could not load canvg: " + t3));
    }).then(function(t3) {
      return t3.default ? t3.default : t3;
    }).then(function(e3) {
      return e3.fromString(h2, t2, f2);
    }, function() {
      return Promise.reject(new Error("Could not load canvg."));
    }).then(function(t3) {
      return t3.render(f2);
    }).then(function() {
      d2.addImage(l2.toDataURL("image/jpeg", 1), e2, n2, r2, a2, u2, c2);
    });
  }, E$1.API.putTotalPages = function(t2) {
    var e2, n2 = 0;
    parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (e2 = new RegExp(t2, "g"), n2 = this.internal.getNumberOfPages()) : (e2 = new RegExp(this.pdfEscape16(t2, this.internal.getFont()), "g"), n2 = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont()));
    for (var r2 = 1; r2 <= this.internal.getNumberOfPages(); r2++) for (var i2 = 0; i2 < this.internal.pages[r2].length; i2++) this.internal.pages[r2][i2] = this.internal.pages[r2][i2].replace(e2, n2);
    return this;
  }, E$1.API.viewerPreferences = function(e2, n2) {
    var r2;
    e2 = e2 || {}, n2 = n2 || false;
    var i2, a2, o2, s2 = { HideToolbar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideMenubar: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, FitWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, CenterWindow: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: false, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: false, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: false, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: false, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: false, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: false, value: false, type: "boolean", explicitSet: false, valueSet: [true, false], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: false, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: false, valueSet: null, pdfVersion: 1.7 } }, u2 = Object.keys(s2), c2 = [], l2 = 0, h2 = 0, f2 = 0;
    function d2(t2, e3) {
      var n3, r3 = false;
      for (n3 = 0; n3 < t2.length; n3 += 1) t2[n3] === e3 && (r3 = true);
      return r3;
    }
    if (void 0 === this.internal.viewerpreferences && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(s2)), this.internal.viewerpreferences.isSubscribed = false), r2 = this.internal.viewerpreferences.configuration, "reset" === e2 || true === n2) {
      var p2 = u2.length;
      for (f2 = 0; f2 < p2; f2 += 1) r2[u2[f2]].value = r2[u2[f2]].defaultValue, r2[u2[f2]].explicitSet = false;
    }
    if ("object" === _typeof$1(e2)) {
      for (a2 in e2) if (o2 = e2[a2], d2(u2, a2) && void 0 !== o2) {
        if ("boolean" === r2[a2].type && "boolean" == typeof o2) r2[a2].value = o2;
        else if ("name" === r2[a2].type && d2(r2[a2].valueSet, o2)) r2[a2].value = o2;
        else if ("integer" === r2[a2].type && Number.isInteger(o2)) r2[a2].value = o2;
        else if ("array" === r2[a2].type) {
          for (l2 = 0; l2 < o2.length; l2 += 1) if (i2 = true, 1 === o2[l2].length && "number" == typeof o2[l2][0]) c2.push(String(o2[l2] - 1));
          else if (o2[l2].length > 1) {
            for (h2 = 0; h2 < o2[l2].length; h2 += 1) "number" != typeof o2[l2][h2] && (i2 = false);
            true === i2 && c2.push([o2[l2][0] - 1, o2[l2][1] - 1].join(" "));
          }
          r2[a2].value = "[" + c2.join(" ") + "]";
        } else r2[a2].value = r2[a2].defaultValue;
        r2[a2].explicitSet = true;
      }
    }
    return false === this.internal.viewerpreferences.isSubscribed && (this.internal.events.subscribe("putCatalog", function() {
      var t2, e3 = [];
      for (t2 in r2) true === r2[t2].explicitSet && ("name" === r2[t2].type ? e3.push("/" + t2 + " /" + r2[t2].value) : e3.push("/" + t2 + " " + r2[t2].value));
      0 !== e3.length && this.internal.write("/ViewerPreferences\n<<\n" + e3.join("\n") + "\n>>");
    }), this.internal.viewerpreferences.isSubscribed = true), this.internal.viewerpreferences.configuration = r2, this;
  }, /** ====================================================================
   * @license
   * jsPDF XMP metadata plugin
   * Copyright (c) 2016 Jussi Utunen, u-jussi@suomi24.fi
   *
   * Permission is hereby granted, free of charge, to any person obtaining
   * a copy of this software and associated documentation files (the
   * "Software"), to deal in the Software without restriction, including
   * without limitation the rights to use, copy, modify, merge, publish,
   * distribute, sublicense, and/or sell copies of the Software, and to
   * permit persons to whom the Software is furnished to do so, subject to
   * the following conditions:
   *
   * The above copyright notice and this permission notice shall be
   * included in all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
   * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
   * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
   * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
   * ====================================================================
   */
  (function(t2) {
    var e2 = function() {
      var t3 = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', e3 = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), n3 = unescape(encodeURIComponent(t3)), r2 = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), i2 = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), a2 = unescape(encodeURIComponent("</x:xmpmeta>")), o2 = n3.length + r2.length + i2.length + e3.length + a2.length;
      this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + o2 + " >>"), this.internal.write("stream"), this.internal.write(e3 + n3 + r2 + i2 + a2), this.internal.write("endstream"), this.internal.write("endobj");
    }, n2 = function() {
      this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R");
    };
    t2.addMetadata = function(t3, r2) {
      return void 0 === this.internal.__metadata__ && (this.internal.__metadata__ = { metadata: t3, namespaceuri: r2 || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", n2), this.internal.events.subscribe("postPutResources", e2)), this;
    };
  })(E$1.API), (function(t2) {
    var e2 = t2.API, n2 = e2.pdfEscape16 = function(t3, e3) {
      for (var n3, r3 = e3.metadata.Unicode.widths, i3 = ["", "0", "00", "000", "0000"], a2 = [""], o2 = 0, s2 = t3.length; o2 < s2; ++o2) {
        if (n3 = e3.metadata.characterToGlyph(t3.charCodeAt(o2)), e3.metadata.glyIdsUsed.push(n3), e3.metadata.toUnicode[n3] = t3.charCodeAt(o2), -1 == r3.indexOf(n3) && (r3.push(n3), r3.push([parseInt(e3.metadata.widthOfGlyph(n3), 10)])), "0" == n3) return a2.join("");
        n3 = n3.toString(16), a2.push(i3[4 - n3.length], n3);
      }
      return a2.join("");
    }, r2 = function(t3) {
      var e3, n3, r3, i3, a2, o2, s2;
      for (a2 = "/CIDInit /ProcSet findresource begin\n12 dict begin\nbegincmap\n/CIDSystemInfo <<\n  /Registry (Adobe)\n  /Ordering (UCS)\n  /Supplement 0\n>> def\n/CMapName /Adobe-Identity-UCS def\n/CMapType 2 def\n1 begincodespacerange\n<0000><ffff>\nendcodespacerange", r3 = [], o2 = 0, s2 = (n3 = Object.keys(t3).sort(function(t4, e4) {
        return t4 - e4;
      })).length; o2 < s2; o2++) e3 = n3[o2], r3.length >= 100 && (a2 += "\n" + r3.length + " beginbfchar\n" + r3.join("\n") + "\nendbfchar", r3 = []), void 0 !== t3[e3] && null !== t3[e3] && "function" == typeof t3[e3].toString && (i3 = ("0000" + t3[e3].toString(16)).slice(-4), e3 = ("0000" + (+e3).toString(16)).slice(-4), r3.push("<" + e3 + "><" + i3 + ">"));
      return r3.length && (a2 += "\n" + r3.length + " beginbfchar\n" + r3.join("\n") + "\nendbfchar\n"), a2 + "endcmap\nCMapName currentdict /CMap defineresource pop\nend\nend";
    };
    e2.events.push(["putFont", function(e3) {
      !(function(e4) {
        var n3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
        if (n3.metadata instanceof t2.API.TTFFont && "Identity-H" === n3.encoding) {
          for (var s2 = n3.metadata.Unicode.widths, u2 = n3.metadata.subset.encode(n3.metadata.glyIdsUsed, 1), c2 = "", l2 = 0; l2 < u2.length; l2++) c2 += String.fromCharCode(u2[l2]);
          var h2 = a2();
          o2({ data: c2, addLength1: true, objectId: h2 }), i3("endobj");
          var f2 = a2();
          o2({ data: r2(n3.metadata.toUnicode), addLength1: true, objectId: f2 }), i3("endobj");
          var d2 = a2();
          i3("<<"), i3("/Type /FontDescriptor"), i3("/FontName /" + j(n3.fontName)), i3("/FontFile2 " + h2 + " 0 R"), i3("/FontBBox " + t2.API.PDFObject.convert(n3.metadata.bbox)), i3("/Flags " + n3.metadata.flags), i3("/StemV " + n3.metadata.stemV), i3("/ItalicAngle " + n3.metadata.italicAngle), i3("/Ascent " + n3.metadata.ascender), i3("/Descent " + n3.metadata.decender), i3("/CapHeight " + n3.metadata.capHeight), i3(">>"), i3("endobj");
          var p2 = a2();
          i3("<<"), i3("/Type /Font"), i3("/BaseFont /" + j(n3.fontName)), i3("/FontDescriptor " + d2 + " 0 R"), i3("/W " + t2.API.PDFObject.convert(s2)), i3("/CIDToGIDMap /Identity"), i3("/DW 1000"), i3("/Subtype /CIDFontType2"), i3("/CIDSystemInfo"), i3("<<"), i3("/Supplement 0"), i3("/Registry (Adobe)"), i3("/Ordering (" + n3.encoding + ")"), i3(">>"), i3(">>"), i3("endobj"), n3.objectNumber = a2(), i3("<<"), i3("/Type /Font"), i3("/Subtype /Type0"), i3("/ToUnicode " + f2 + " 0 R"), i3("/BaseFont /" + j(n3.fontName)), i3("/Encoding /" + n3.encoding), i3("/DescendantFonts [" + p2 + " 0 R]"), i3(">>"), i3("endobj"), n3.isAlreadyPutted = true;
        }
      })(e3);
    }]), e2.events.push(["putFont", function(e3) {
      !(function(e4) {
        var n3 = e4.font, i3 = e4.out, a2 = e4.newObject, o2 = e4.putStream;
        if (n3.metadata instanceof t2.API.TTFFont && "WinAnsiEncoding" === n3.encoding) {
          for (var s2 = n3.metadata.rawData, u2 = "", c2 = 0; c2 < s2.length; c2++) u2 += String.fromCharCode(s2[c2]);
          var l2 = a2();
          o2({ data: u2, addLength1: true, objectId: l2 }), i3("endobj");
          var h2 = a2();
          o2({ data: r2(n3.metadata.toUnicode), addLength1: true, objectId: h2 }), i3("endobj");
          var f2 = a2();
          i3("<<"), i3("/Descent " + n3.metadata.decender), i3("/CapHeight " + n3.metadata.capHeight), i3("/StemV " + n3.metadata.stemV), i3("/Type /FontDescriptor"), i3("/FontFile2 " + l2 + " 0 R"), i3("/Flags 96"), i3("/FontBBox " + t2.API.PDFObject.convert(n3.metadata.bbox)), i3("/FontName /" + j(n3.fontName)), i3("/ItalicAngle " + n3.metadata.italicAngle), i3("/Ascent " + n3.metadata.ascender), i3(">>"), i3("endobj"), n3.objectNumber = a2();
          for (var d2 = 0; d2 < n3.metadata.hmtx.widths.length; d2++) n3.metadata.hmtx.widths[d2] = parseInt(n3.metadata.hmtx.widths[d2] * (1e3 / n3.metadata.head.unitsPerEm));
          i3("<</Subtype/TrueType/Type/Font/ToUnicode " + h2 + " 0 R/BaseFont/" + j(n3.fontName) + "/FontDescriptor " + f2 + " 0 R/Encoding/" + n3.encoding + " /FirstChar 29 /LastChar 255 /Widths " + t2.API.PDFObject.convert(n3.metadata.hmtx.widths) + ">>"), i3("endobj"), n3.isAlreadyPutted = true;
        }
      })(e3);
    }]);
    var i2 = function(t3) {
      var e3, r3 = t3.text || "", i3 = t3.x, a2 = t3.y, o2 = t3.options || {}, s2 = t3.mutex || {}, u2 = s2.pdfEscape, c2 = s2.activeFontKey, l2 = s2.fonts, h2 = c2, f2 = "", d2 = 0, p2 = "", g2 = l2[h2].encoding;
      if ("Identity-H" !== l2[h2].encoding) return { text: r3, x: i3, y: a2, options: o2, mutex: s2 };
      for (p2 = r3, h2 = c2, Array.isArray(r3) && (p2 = r3[0]), d2 = 0; d2 < p2.length; d2 += 1) l2[h2].metadata.hasOwnProperty("cmap") && (e3 = l2[h2].metadata.cmap.unicode.codeMap[p2[d2].charCodeAt(0)]), e3 || p2[d2].charCodeAt(0) < 256 && l2[h2].metadata.hasOwnProperty("Unicode") ? f2 += p2[d2] : f2 += "";
      var m2 = "";
      return parseInt(h2.slice(1)) < 14 || "WinAnsiEncoding" === g2 ? m2 = u2(f2, h2).split("").map(function(t4) {
        return t4.charCodeAt(0).toString(16);
      }).join("") : "Identity-H" === g2 && (m2 = n2(f2, l2[h2])), s2.isHex = true, { text: m2, x: i3, y: a2, options: o2, mutex: s2 };
    };
    e2.events.push(["postProcessText", function(t3) {
      var e3 = t3.text || "", n3 = [], r3 = { text: e3, x: t3.x, y: t3.y, options: t3.options, mutex: t3.mutex };
      if (Array.isArray(e3)) {
        var a2 = 0;
        for (a2 = 0; a2 < e3.length; a2 += 1) Array.isArray(e3[a2]) && 3 === e3[a2].length ? n3.push([i2(Object.assign({}, r3, { text: e3[a2][0] })).text, e3[a2][1], e3[a2][2]]) : n3.push(i2(Object.assign({}, r3, { text: e3[a2] })).text);
        t3.text = n3;
      } else t3.text = i2(Object.assign({}, r3, { text: e3 })).text;
    }]);
  })(E$1), /**
   * @license
   * jsPDF virtual FileSystem functionality
   *
   * Licensed under the MIT License.
   * http://opensource.org/licenses/mit-license
   */
  (function(t2) {
    var e2 = function() {
      return void 0 === this.internal.vFS && (this.internal.vFS = {}), true;
    };
    t2.existsFileInVFS = function(t3) {
      return e2.call(this), void 0 !== this.internal.vFS[t3];
    }, t2.addFileToVFS = function(t3, n2) {
      return e2.call(this), this.internal.vFS[t3] = n2, this;
    }, t2.getFileFromVFS = function(t3) {
      return e2.call(this), void 0 !== this.internal.vFS[t3] ? this.internal.vFS[t3] : null;
    };
  })(E$1.API), /**
   * @license
   * Unicode Bidi Engine based on the work of Alex Shensis (@asthensis)
   * MIT License
   */
  (function(t2) {
    t2.__bidiEngine__ = t2.prototype.__bidiEngine__ = function(t3) {
      var n3, r2, i2, a2, o2, s2, u2, c2 = e2, l2 = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], h2 = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], f2 = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, d2 = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, p2 = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""], g2 = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), m2 = false, v2 = 0;
      this.__bidiEngine__ = {};
      var b2 = function(t4) {
        var e3 = t4.charCodeAt(), n4 = e3 >> 8, r3 = d2[n4];
        return void 0 !== r3 ? c2[256 * r3 + (255 & e3)] : 252 === n4 || 253 === n4 ? "AL" : g2.test(n4) ? "L" : 8 === n4 ? "R" : "N";
      }, y2 = function(t4) {
        for (var e3, n4 = 0; n4 < t4.length; n4++) {
          if ("L" === (e3 = b2(t4.charAt(n4)))) return false;
          if ("R" === e3) return true;
        }
        return false;
      }, w2 = function(t4, e3, o3, s3) {
        var u3, c3, l3, h3, f3 = e3[s3];
        switch (f3) {
          case "L":
          case "R":
          case "LRE":
          case "RLE":
          case "LRO":
          case "RLO":
          case "PDF":
            m2 = false;
            break;
          case "N":
          case "AN":
            break;
          case "EN":
            m2 && (f3 = "AN");
            break;
          case "AL":
            m2 = true, f3 = "R";
            break;
          case "WS":
          case "BN":
            f3 = "N";
            break;
          case "CS":
            s3 < 1 || s3 + 1 >= e3.length || "EN" !== (u3 = o3[s3 - 1]) && "AN" !== u3 || "EN" !== (c3 = e3[s3 + 1]) && "AN" !== c3 ? f3 = "N" : m2 && (c3 = "AN"), f3 = c3 === u3 ? c3 : "N";
            break;
          case "ES":
            f3 = "EN" === (u3 = s3 > 0 ? o3[s3 - 1] : "B") && s3 + 1 < e3.length && "EN" === e3[s3 + 1] ? "EN" : "N";
            break;
          case "ET":
            if (s3 > 0 && "EN" === o3[s3 - 1]) {
              f3 = "EN";
              break;
            }
            if (m2) {
              f3 = "N";
              break;
            }
            for (l3 = s3 + 1, h3 = e3.length; l3 < h3 && "ET" === e3[l3]; ) l3++;
            f3 = l3 < h3 && "EN" === e3[l3] ? "EN" : "N";
            break;
          case "NSM":
            if (i2 && !a2) {
              for (h3 = e3.length, l3 = s3 + 1; l3 < h3 && "NSM" === e3[l3]; ) l3++;
              if (l3 < h3) {
                var d3 = t4[s3], p3 = d3 >= 1425 && d3 <= 2303 || 64286 === d3;
                if (u3 = e3[l3], p3 && ("R" === u3 || "AL" === u3)) {
                  f3 = "R";
                  break;
                }
              }
            }
            f3 = s3 < 1 || "B" === (u3 = e3[s3 - 1]) ? "N" : o3[s3 - 1];
            break;
          case "B":
            m2 = false, n3 = true, f3 = v2;
            break;
          case "S":
            r2 = true, f3 = "N";
        }
        return f3;
      }, N2 = function(t4, e3, n4) {
        var r3 = t4.split("");
        return n4 && L2(r3, n4, { hiLevel: v2 }), r3.reverse(), e3 && e3.reverse(), r3.join("");
      }, L2 = function(t4, e3, i3) {
        var a3, o3, s3, u3, c3, d3 = -1, p3 = t4.length, g3 = 0, y3 = [], N3 = v2 ? h2 : l2, L3 = [];
        for (m2 = false, n3 = false, r2 = false, o3 = 0; o3 < p3; o3++) L3[o3] = b2(t4[o3]);
        for (s3 = 0; s3 < p3; s3++) {
          if (c3 = g3, y3[s3] = w2(t4, L3, y3, s3), a3 = 240 & (g3 = N3[c3][f2[y3[s3]]]), g3 &= 15, e3[s3] = u3 = N3[g3][5], a3 > 0) if (16 === a3) {
            for (o3 = d3; o3 < s3; o3++) e3[o3] = 1;
            d3 = -1;
          } else d3 = -1;
          if (N3[g3][6]) -1 === d3 && (d3 = s3);
          else if (d3 > -1) {
            for (o3 = d3; o3 < s3; o3++) e3[o3] = u3;
            d3 = -1;
          }
          "B" === L3[s3] && (e3[s3] = 0), i3.hiLevel |= u3;
        }
        r2 && (function(t5, e4, n4) {
          for (var r3 = 0; r3 < n4; r3++) if ("S" === t5[r3]) {
            e4[r3] = v2;
            for (var i4 = r3 - 1; i4 >= 0 && "WS" === t5[i4]; i4--) e4[i4] = v2;
          }
        })(L3, e3, p3);
      }, x2 = function(t4, e3, r3, i3, a3) {
        if (!(a3.hiLevel < t4)) {
          if (1 === t4 && 1 === v2 && !n3) return e3.reverse(), void (r3 && r3.reverse());
          for (var o3, s3, u3, c3, l3 = e3.length, h3 = 0; h3 < l3; ) {
            if (i3[h3] >= t4) {
              for (u3 = h3 + 1; u3 < l3 && i3[u3] >= t4; ) u3++;
              for (c3 = h3, s3 = u3 - 1; c3 < s3; c3++, s3--) o3 = e3[c3], e3[c3] = e3[s3], e3[s3] = o3, r3 && (o3 = r3[c3], r3[c3] = r3[s3], r3[s3] = o3);
              h3 = u3;
            }
            h3++;
          }
        }
      }, A2 = function(t4, e3, n4) {
        var r3 = t4.split(""), i3 = { hiLevel: v2 };
        return n4 || (n4 = []), L2(r3, n4, i3), (function(t5, e4, n5) {
          if (0 !== n5.hiLevel && u2) for (var r4, i4 = 0; i4 < t5.length; i4++) 1 === e4[i4] && (r4 = p2.indexOf(t5[i4])) >= 0 && (t5[i4] = p2[r4 + 1]);
        })(r3, n4, i3), x2(2, r3, e3, n4, i3), x2(1, r3, e3, n4, i3), r3.join("");
      };
      return this.__bidiEngine__.doBidiReorder = function(t4, e3, n4) {
        if ((function(t5, e4) {
          if (e4) for (var n5 = 0; n5 < t5.length; n5++) e4[n5] = n5;
          void 0 === a2 && (a2 = y2(t5)), void 0 === s2 && (s2 = y2(t5));
        })(t4, e3), i2 || !o2 || s2) if (i2 && o2 && a2 ^ s2) v2 = a2 ? 1 : 0, t4 = N2(t4, e3, n4);
        else if (!i2 && o2 && s2) v2 = a2 ? 1 : 0, t4 = A2(t4, e3, n4), t4 = N2(t4, e3);
        else if (!i2 || a2 || o2 || s2) {
          if (i2 && !o2 && a2 ^ s2) t4 = N2(t4, e3), a2 ? (v2 = 0, t4 = A2(t4, e3, n4)) : (v2 = 1, t4 = A2(t4, e3, n4), t4 = N2(t4, e3));
          else if (i2 && a2 && !o2 && s2) v2 = 1, t4 = A2(t4, e3, n4), t4 = N2(t4, e3);
          else if (!i2 && !o2 && a2 ^ s2) {
            var r3 = u2;
            a2 ? (v2 = 1, t4 = A2(t4, e3, n4), v2 = 0, u2 = false, t4 = A2(t4, e3, n4), u2 = r3) : (v2 = 0, t4 = A2(t4, e3, n4), t4 = N2(t4, e3), v2 = 1, u2 = false, t4 = A2(t4, e3, n4), u2 = r3, t4 = N2(t4, e3));
          }
        } else v2 = 0, t4 = A2(t4, e3, n4);
        else v2 = a2 ? 1 : 0, t4 = A2(t4, e3, n4);
        return t4;
      }, this.__bidiEngine__.setOptions = function(t4) {
        t4 && (i2 = t4.isInputVisual, o2 = t4.isOutputVisual, a2 = t4.isInputRtl, s2 = t4.isOutputRtl, u2 = t4.isSymmetricSwapping);
      }, this.__bidiEngine__.setOptions(t3), this.__bidiEngine__;
    };
    var e2 = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], n2 = new t2.__bidiEngine__({ isInputVisual: true });
    t2.API.events.push(["postProcessText", function(t3) {
      var e3 = t3.text;
      t3.x, t3.y;
      var r2 = t3.options || {};
      t3.mutex, r2.lang;
      var i2 = [];
      if (r2.isInputVisual = "boolean" != typeof r2.isInputVisual || r2.isInputVisual, n2.setOptions(r2), "[object Array]" === Object.prototype.toString.call(e3)) {
        var a2 = 0;
        for (i2 = [], a2 = 0; a2 < e3.length; a2 += 1) "[object Array]" === Object.prototype.toString.call(e3[a2]) ? i2.push([n2.doBidiReorder(e3[a2][0]), e3[a2][1], e3[a2][2]]) : i2.push([n2.doBidiReorder(e3[a2])]);
        t3.text = i2;
      } else t3.text = n2.doBidiReorder(e3);
      n2.setOptions({ isInputVisual: true });
    }]);
  })(E$1), E$1.API.TTFFont = (function() {
    function t2(t3) {
      var e2;
      if (this.rawData = t3, e2 = this.contents = new fe(t3), this.contents.pos = 4, "ttcf" === e2.readString(4)) throw new Error("TTCF not supported.");
      e2.pos = 0, this.parse(), this.subset = new je(this), this.registerTTF();
    }
    return t2.open = function(e2) {
      return new t2(e2);
    }, t2.prototype.parse = function() {
      return this.directory = new de(this.contents), this.head = new me(this), this.name = new xe(this), this.cmap = new be(this), this.toUnicode = {}, this.hhea = new ye(this), this.maxp = new Ae(this), this.hmtx = new Se(this), this.post = new Ne(this), this.os2 = new we(this), this.loca = new Ie(this), this.glyf = new Pe(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax];
    }, t2.prototype.registerTTF = function() {
      var t3, e2, n2, r2, i2;
      if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function() {
        var e3, n3, r3, i3;
        for (i3 = [], e3 = 0, n3 = (r3 = this.bbox).length; e3 < n3; e3++) t3 = r3[e3], i3.push(Math.round(t3 * this.scaleFactor));
        return i3;
      }).call(this), this.stemV = 0, this.post.exists ? (n2 = 255 & (r2 = this.post.italic_angle), 32768 & (e2 = r2 >> 16) && (e2 = -(1 + (65535 ^ e2))), this.italicAngle = +(e2 + "." + n2)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = 1 === (i2 = this.familyClass) || 2 === i2 || 3 === i2 || 4 === i2 || 5 === i2 || 7 === i2, this.isScript = 10 === this.familyClass, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), 0 !== this.italicAngle && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font");
    }, t2.prototype.characterToGlyph = function(t3) {
      var e2;
      return (null != (e2 = this.cmap.unicode) ? e2.codeMap[t3] : void 0) || 0;
    }, t2.prototype.widthOfGlyph = function(t3) {
      var e2;
      return e2 = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t3).advance * e2;
    }, t2.prototype.widthOfString = function(t3, e2, n2) {
      var r2, i2, a2, o2;
      for (a2 = 0, i2 = 0, o2 = (t3 = "" + t3).length; 0 <= o2 ? i2 < o2 : i2 > o2; i2 = 0 <= o2 ? ++i2 : --i2) r2 = t3.charCodeAt(i2), a2 += this.widthOfGlyph(this.characterToGlyph(r2)) + n2 * (1e3 / e2) || 0;
      return a2 * (e2 / 1e3);
    }, t2.prototype.lineHeight = function(t3, e2) {
      var n2;
      return null == e2 && (e2 = false), n2 = e2 ? this.lineGap : 0, (this.ascender + n2 - this.decender) / 1e3 * t3;
    }, t2;
  })();
  var he, fe = (function() {
    function t2(t3) {
      this.data = null != t3 ? t3 : [], this.pos = 0, this.length = this.data.length;
    }
    return t2.prototype.readByte = function() {
      return this.data[this.pos++];
    }, t2.prototype.writeByte = function(t3) {
      return this.data[this.pos++] = t3;
    }, t2.prototype.readUInt32 = function() {
      return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte();
    }, t2.prototype.writeUInt32 = function(t3) {
      return this.writeByte(t3 >>> 24 & 255), this.writeByte(t3 >> 16 & 255), this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
    }, t2.prototype.readInt32 = function() {
      var t3;
      return (t3 = this.readUInt32()) >= 2147483648 ? t3 - 4294967296 : t3;
    }, t2.prototype.writeInt32 = function(t3) {
      return t3 < 0 && (t3 += 4294967296), this.writeUInt32(t3);
    }, t2.prototype.readUInt16 = function() {
      return this.readByte() << 8 | this.readByte();
    }, t2.prototype.writeUInt16 = function(t3) {
      return this.writeByte(t3 >> 8 & 255), this.writeByte(255 & t3);
    }, t2.prototype.readInt16 = function() {
      var t3;
      return (t3 = this.readUInt16()) >= 32768 ? t3 - 65536 : t3;
    }, t2.prototype.writeInt16 = function(t3) {
      return t3 < 0 && (t3 += 65536), this.writeUInt16(t3);
    }, t2.prototype.readString = function(t3) {
      var e2, n2;
      for (n2 = [], e2 = 0; 0 <= t3 ? e2 < t3 : e2 > t3; e2 = 0 <= t3 ? ++e2 : --e2) n2[e2] = String.fromCharCode(this.readByte());
      return n2.join("");
    }, t2.prototype.writeString = function(t3) {
      var e2, n2, r2;
      for (r2 = [], e2 = 0, n2 = t3.length; 0 <= n2 ? e2 < n2 : e2 > n2; e2 = 0 <= n2 ? ++e2 : --e2) r2.push(this.writeByte(t3.charCodeAt(e2)));
      return r2;
    }, t2.prototype.readShort = function() {
      return this.readInt16();
    }, t2.prototype.writeShort = function(t3) {
      return this.writeInt16(t3);
    }, t2.prototype.readLongLong = function() {
      var t3, e2, n2, r2, i2, a2, o2, s2;
      return t3 = this.readByte(), e2 = this.readByte(), n2 = this.readByte(), r2 = this.readByte(), i2 = this.readByte(), a2 = this.readByte(), o2 = this.readByte(), s2 = this.readByte(), 128 & t3 ? -1 * (72057594037927940 * (255 ^ t3) + 281474976710656 * (255 ^ e2) + 1099511627776 * (255 ^ n2) + 4294967296 * (255 ^ r2) + 16777216 * (255 ^ i2) + 65536 * (255 ^ a2) + 256 * (255 ^ o2) + (255 ^ s2) + 1) : 72057594037927940 * t3 + 281474976710656 * e2 + 1099511627776 * n2 + 4294967296 * r2 + 16777216 * i2 + 65536 * a2 + 256 * o2 + s2;
    }, t2.prototype.writeLongLong = function(t3) {
      var e2, n2;
      return e2 = Math.floor(t3 / 4294967296), n2 = 4294967295 & t3, this.writeByte(e2 >> 24 & 255), this.writeByte(e2 >> 16 & 255), this.writeByte(e2 >> 8 & 255), this.writeByte(255 & e2), this.writeByte(n2 >> 24 & 255), this.writeByte(n2 >> 16 & 255), this.writeByte(n2 >> 8 & 255), this.writeByte(255 & n2);
    }, t2.prototype.readInt = function() {
      return this.readInt32();
    }, t2.prototype.writeInt = function(t3) {
      return this.writeInt32(t3);
    }, t2.prototype.read = function(t3) {
      var e2, n2;
      for (e2 = [], n2 = 0; 0 <= t3 ? n2 < t3 : n2 > t3; n2 = 0 <= t3 ? ++n2 : --n2) e2.push(this.readByte());
      return e2;
    }, t2.prototype.write = function(t3) {
      var e2, n2, r2, i2;
      for (i2 = [], n2 = 0, r2 = t3.length; n2 < r2; n2++) e2 = t3[n2], i2.push(this.writeByte(e2));
      return i2;
    }, t2;
  })(), de = (function() {
    var t2;
    function e2(t3) {
      var e3, n2, r2;
      for (this.scalarType = t3.readInt(), this.tableCount = t3.readShort(), this.searchRange = t3.readShort(), this.entrySelector = t3.readShort(), this.rangeShift = t3.readShort(), this.tables = {}, n2 = 0, r2 = this.tableCount; 0 <= r2 ? n2 < r2 : n2 > r2; n2 = 0 <= r2 ? ++n2 : --n2) e3 = { tag: t3.readString(4), checksum: t3.readInt(), offset: t3.readInt(), length: t3.readInt() }, this.tables[e3.tag] = e3;
    }
    return e2.prototype.encode = function(e3) {
      var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2;
      for (p2 in f2 = Object.keys(e3).length, s2 = Math.log(2), l2 = 16 * Math.floor(Math.log(f2) / s2), a2 = Math.floor(l2 / s2), c2 = 16 * f2 - l2, (r2 = new fe()).writeInt(this.scalarType), r2.writeShort(f2), r2.writeShort(l2), r2.writeShort(a2), r2.writeShort(c2), i2 = 16 * f2, u2 = r2.pos + i2, o2 = null, d2 = [], e3) for (h2 = e3[p2], r2.writeString(p2), r2.writeInt(t2(h2)), r2.writeInt(u2), r2.writeInt(h2.length), d2 = d2.concat(h2), "head" === p2 && (o2 = u2), u2 += h2.length; u2 % 4; ) d2.push(0), u2++;
      return r2.write(d2), n2 = 2981146554 - t2(r2.data), r2.pos = o2 + 8, r2.writeUInt32(n2), r2.data;
    }, t2 = function(t3) {
      var e3, n2, r2, i2;
      for (t3 = _e.call(t3); t3.length % 4; ) t3.push(0);
      for (r2 = new fe(t3), n2 = 0, e3 = 0, i2 = t3.length; e3 < i2; e3 = e3 += 4) n2 += r2.readUInt32();
      return 4294967295 & n2;
    }, e2;
  })(), pe = {}.hasOwnProperty, ge = function(t2, e2) {
    for (var n2 in e2) pe.call(e2, n2) && (t2[n2] = e2[n2]);
    function r2() {
      this.constructor = t2;
    }
    return r2.prototype = e2.prototype, t2.prototype = new r2(), t2.__super__ = e2.prototype, t2;
  };
  he = (function() {
    function t2(t3) {
      var e2;
      this.file = t3, e2 = this.file.directory.tables[this.tag], this.exists = !!e2, e2 && (this.offset = e2.offset, this.length = e2.length, this.parse(this.file.contents));
    }
    return t2.prototype.parse = function() {
    }, t2.prototype.encode = function() {
    }, t2.prototype.raw = function() {
      return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null;
    }, t2;
  })();
  var me = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "head", t2.prototype.parse = function(t3) {
      return t3.pos = this.offset, this.version = t3.readInt(), this.revision = t3.readInt(), this.checkSumAdjustment = t3.readInt(), this.magicNumber = t3.readInt(), this.flags = t3.readShort(), this.unitsPerEm = t3.readShort(), this.created = t3.readLongLong(), this.modified = t3.readLongLong(), this.xMin = t3.readShort(), this.yMin = t3.readShort(), this.xMax = t3.readShort(), this.yMax = t3.readShort(), this.macStyle = t3.readShort(), this.lowestRecPPEM = t3.readShort(), this.fontDirectionHint = t3.readShort(), this.indexToLocFormat = t3.readShort(), this.glyphDataFormat = t3.readShort();
    }, t2.prototype.encode = function(t3) {
      var e2;
      return (e2 = new fe()).writeInt(this.version), e2.writeInt(this.revision), e2.writeInt(this.checkSumAdjustment), e2.writeInt(this.magicNumber), e2.writeShort(this.flags), e2.writeShort(this.unitsPerEm), e2.writeLongLong(this.created), e2.writeLongLong(this.modified), e2.writeShort(this.xMin), e2.writeShort(this.yMin), e2.writeShort(this.xMax), e2.writeShort(this.yMax), e2.writeShort(this.macStyle), e2.writeShort(this.lowestRecPPEM), e2.writeShort(this.fontDirectionHint), e2.writeShort(t3), e2.writeShort(this.glyphDataFormat), e2.data;
    }, t2;
  })(), ve = (function() {
    function t2(t3, e2) {
      var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2, v2, b2;
      switch (this.platformID = t3.readUInt16(), this.encodingID = t3.readShort(), this.offset = e2 + t3.readInt(), l2 = t3.pos, t3.pos = this.offset, this.format = t3.readUInt16(), this.length = t3.readUInt16(), this.language = t3.readUInt16(), this.isUnicode = 3 === this.platformID && 1 === this.encodingID && 4 === this.format || 0 === this.platformID && 4 === this.format, this.codeMap = {}, this.format) {
        case 0:
          for (s2 = 0; s2 < 256; ++s2) this.codeMap[s2] = t3.readByte();
          break;
        case 4:
          for (f2 = t3.readUInt16(), h2 = f2 / 2, t3.pos += 6, i2 = (function() {
            var e3, n3;
            for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t3.readUInt16());
            return n3;
          })(), t3.pos += 2, p2 = (function() {
            var e3, n3;
            for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t3.readUInt16());
            return n3;
          })(), u2 = (function() {
            var e3, n3;
            for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t3.readUInt16());
            return n3;
          })(), c2 = (function() {
            var e3, n3;
            for (n3 = [], s2 = e3 = 0; 0 <= h2 ? e3 < h2 : e3 > h2; s2 = 0 <= h2 ? ++e3 : --e3) n3.push(t3.readUInt16());
            return n3;
          })(), r2 = (this.length - t3.pos + this.offset) / 2, o2 = (function() {
            var e3, n3;
            for (n3 = [], s2 = e3 = 0; 0 <= r2 ? e3 < r2 : e3 > r2; s2 = 0 <= r2 ? ++e3 : --e3) n3.push(t3.readUInt16());
            return n3;
          })(), s2 = m2 = 0, b2 = i2.length; m2 < b2; s2 = ++m2) for (g2 = i2[s2], n2 = v2 = d2 = p2[s2]; d2 <= g2 ? v2 <= g2 : v2 >= g2; n2 = d2 <= g2 ? ++v2 : --v2) 0 === c2[s2] ? a2 = n2 + u2[s2] : 0 !== (a2 = o2[c2[s2] / 2 + (n2 - d2) - (h2 - s2)] || 0) && (a2 += u2[s2]), this.codeMap[n2] = 65535 & a2;
      }
      t3.pos = l2;
    }
    return t2.encode = function(t3, e2) {
      var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2, v2, b2, y2, w2, N2, L2, x2, A2, S2, _2, P2, k2, F2, I2, j2, C2, O2, B3, M2, q2, E2, R2, D2, T2, z2, U2, H4, W2, V2, G2, Y2;
      switch (F2 = new fe(), a2 = Object.keys(t3).sort(function(t4, e3) {
        return t4 - e3;
      }), e2) {
        case "macroman":
          for (p2 = 0, g2 = (function() {
            var t4 = [];
            for (d2 = 0; d2 < 256; ++d2) t4.push(0);
            return t4;
          })(), v2 = { 0: 0 }, i2 = {}, I2 = 0, B3 = a2.length; I2 < B3; I2++) null == v2[W2 = t3[r2 = a2[I2]]] && (v2[W2] = ++p2), i2[r2] = { old: t3[r2], new: v2[t3[r2]] }, g2[r2] = v2[t3[r2]];
          return F2.writeUInt16(1), F2.writeUInt16(0), F2.writeUInt32(12), F2.writeUInt16(0), F2.writeUInt16(262), F2.writeUInt16(0), F2.write(g2), { charMap: i2, subtable: F2.data, maxGlyphID: p2 + 1 };
        case "unicode":
          for (P2 = [], l2 = [], b2 = 0, v2 = {}, n2 = {}, m2 = u2 = null, j2 = 0, M2 = a2.length; j2 < M2; j2++) null == v2[w2 = t3[r2 = a2[j2]]] && (v2[w2] = ++b2), n2[r2] = { old: w2, new: v2[w2] }, o2 = v2[w2] - r2, null != m2 && o2 === u2 || (m2 && l2.push(m2), P2.push(r2), u2 = o2), m2 = r2;
          for (m2 && l2.push(m2), l2.push(65535), P2.push(65535), S2 = 2 * (A2 = P2.length), x2 = 2 * Math.pow(Math.log(A2) / Math.LN2, 2), h2 = Math.log(x2 / 2) / Math.LN2, L2 = 2 * A2 - x2, s2 = [], N2 = [], f2 = [], d2 = C2 = 0, q2 = P2.length; C2 < q2; d2 = ++C2) {
            if (_2 = P2[d2], c2 = l2[d2], 65535 === _2) {
              s2.push(0), N2.push(0);
              break;
            }
            if (_2 - (k2 = n2[_2].new) >= 32768) for (s2.push(0), N2.push(2 * (f2.length + A2 - d2)), r2 = O2 = _2; _2 <= c2 ? O2 <= c2 : O2 >= c2; r2 = _2 <= c2 ? ++O2 : --O2) f2.push(n2[r2].new);
            else s2.push(k2 - _2), N2.push(0);
          }
          for (F2.writeUInt16(3), F2.writeUInt16(1), F2.writeUInt32(12), F2.writeUInt16(4), F2.writeUInt16(16 + 8 * A2 + 2 * f2.length), F2.writeUInt16(0), F2.writeUInt16(S2), F2.writeUInt16(x2), F2.writeUInt16(h2), F2.writeUInt16(L2), U2 = 0, E2 = l2.length; U2 < E2; U2++) r2 = l2[U2], F2.writeUInt16(r2);
          for (F2.writeUInt16(0), H4 = 0, R2 = P2.length; H4 < R2; H4++) r2 = P2[H4], F2.writeUInt16(r2);
          for (V2 = 0, D2 = s2.length; V2 < D2; V2++) o2 = s2[V2], F2.writeUInt16(o2);
          for (G2 = 0, T2 = N2.length; G2 < T2; G2++) y2 = N2[G2], F2.writeUInt16(y2);
          for (Y2 = 0, z2 = f2.length; Y2 < z2; Y2++) p2 = f2[Y2], F2.writeUInt16(p2);
          return { charMap: n2, subtable: F2.data, maxGlyphID: b2 + 1 };
      }
    }, t2;
  })(), be = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "cmap", t2.prototype.parse = function(t3) {
      var e2, n2, r2;
      for (t3.pos = this.offset, this.version = t3.readUInt16(), r2 = t3.readUInt16(), this.tables = [], this.unicode = null, n2 = 0; 0 <= r2 ? n2 < r2 : n2 > r2; n2 = 0 <= r2 ? ++n2 : --n2) e2 = new ve(t3, this.offset), this.tables.push(e2), e2.isUnicode && null == this.unicode && (this.unicode = e2);
      return true;
    }, t2.encode = function(t3, e2) {
      var n2, r2;
      return null == e2 && (e2 = "macroman"), n2 = ve.encode(t3, e2), (r2 = new fe()).writeUInt16(0), r2.writeUInt16(1), n2.table = r2.data.concat(n2.subtable), n2;
    }, t2;
  })(), ye = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "hhea", t2.prototype.parse = function(t3) {
      return t3.pos = this.offset, this.version = t3.readInt(), this.ascender = t3.readShort(), this.decender = t3.readShort(), this.lineGap = t3.readShort(), this.advanceWidthMax = t3.readShort(), this.minLeftSideBearing = t3.readShort(), this.minRightSideBearing = t3.readShort(), this.xMaxExtent = t3.readShort(), this.caretSlopeRise = t3.readShort(), this.caretSlopeRun = t3.readShort(), this.caretOffset = t3.readShort(), t3.pos += 8, this.metricDataFormat = t3.readShort(), this.numberOfMetrics = t3.readUInt16();
    }, t2;
  })(), we = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "OS/2", t2.prototype.parse = function(t3) {
      if (t3.pos = this.offset, this.version = t3.readUInt16(), this.averageCharWidth = t3.readShort(), this.weightClass = t3.readUInt16(), this.widthClass = t3.readUInt16(), this.type = t3.readShort(), this.ySubscriptXSize = t3.readShort(), this.ySubscriptYSize = t3.readShort(), this.ySubscriptXOffset = t3.readShort(), this.ySubscriptYOffset = t3.readShort(), this.ySuperscriptXSize = t3.readShort(), this.ySuperscriptYSize = t3.readShort(), this.ySuperscriptXOffset = t3.readShort(), this.ySuperscriptYOffset = t3.readShort(), this.yStrikeoutSize = t3.readShort(), this.yStrikeoutPosition = t3.readShort(), this.familyClass = t3.readShort(), this.panose = (function() {
        var e2, n2;
        for (n2 = [], e2 = 0; e2 < 10; ++e2) n2.push(t3.readByte());
        return n2;
      })(), this.charRange = (function() {
        var e2, n2;
        for (n2 = [], e2 = 0; e2 < 4; ++e2) n2.push(t3.readInt());
        return n2;
      })(), this.vendorID = t3.readString(4), this.selection = t3.readShort(), this.firstCharIndex = t3.readShort(), this.lastCharIndex = t3.readShort(), this.version > 0 && (this.ascent = t3.readShort(), this.descent = t3.readShort(), this.lineGap = t3.readShort(), this.winAscent = t3.readShort(), this.winDescent = t3.readShort(), this.codePageRange = (function() {
        var e2, n2;
        for (n2 = [], e2 = 0; e2 < 2; e2 = ++e2) n2.push(t3.readInt());
        return n2;
      })(), this.version > 1)) return this.xHeight = t3.readShort(), this.capHeight = t3.readShort(), this.defaultChar = t3.readShort(), this.breakChar = t3.readShort(), this.maxContext = t3.readShort();
    }, t2;
  })(), Ne = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "post", t2.prototype.parse = function(t3) {
      var e2, n2, r2;
      switch (t3.pos = this.offset, this.format = t3.readInt(), this.italicAngle = t3.readInt(), this.underlinePosition = t3.readShort(), this.underlineThickness = t3.readShort(), this.isFixedPitch = t3.readInt(), this.minMemType42 = t3.readInt(), this.maxMemType42 = t3.readInt(), this.minMemType1 = t3.readInt(), this.maxMemType1 = t3.readInt(), this.format) {
        case 65536:
        case 196608:
          break;
        case 131072:
          var i2;
          for (n2 = t3.readUInt16(), this.glyphNameIndex = [], i2 = 0; 0 <= n2 ? i2 < n2 : i2 > n2; i2 = 0 <= n2 ? ++i2 : --i2) this.glyphNameIndex.push(t3.readUInt16());
          for (this.names = [], r2 = []; t3.pos < this.offset + this.length; ) e2 = t3.readByte(), r2.push(this.names.push(t3.readString(e2)));
          return r2;
        case 151552:
          return n2 = t3.readUInt16(), this.offsets = t3.read(n2);
        case 262144:
          return this.map = (function() {
            var e3, n3, r3;
            for (r3 = [], i2 = e3 = 0, n3 = this.file.maxp.numGlyphs; 0 <= n3 ? e3 < n3 : e3 > n3; i2 = 0 <= n3 ? ++e3 : --e3) r3.push(t3.readUInt32());
            return r3;
          }).call(this);
      }
    }, t2;
  })(), Le = function(t2, e2) {
    this.raw = t2, this.length = t2.length, this.platformID = e2.platformID, this.encodingID = e2.encodingID, this.languageID = e2.languageID;
  }, xe = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "name", t2.prototype.parse = function(t3) {
      var e2, n2, r2, i2, a2, o2, s2, u2, c2, l2, h2;
      for (t3.pos = this.offset, t3.readShort(), e2 = t3.readShort(), o2 = t3.readShort(), n2 = [], i2 = 0; 0 <= e2 ? i2 < e2 : i2 > e2; i2 = 0 <= e2 ? ++i2 : --i2) n2.push({ platformID: t3.readShort(), encodingID: t3.readShort(), languageID: t3.readShort(), nameID: t3.readShort(), length: t3.readShort(), offset: this.offset + o2 + t3.readShort() });
      for (s2 = {}, i2 = c2 = 0, l2 = n2.length; c2 < l2; i2 = ++c2) r2 = n2[i2], t3.pos = r2.offset, u2 = t3.readString(r2.length), a2 = new Le(u2, r2), null == s2[h2 = r2.nameID] && (s2[h2] = []), s2[r2.nameID].push(a2);
      this.strings = s2, this.copyright = s2[0], this.fontFamily = s2[1], this.fontSubfamily = s2[2], this.uniqueSubfamily = s2[3], this.fontName = s2[4], this.version = s2[5];
      try {
        this.postscriptName = s2[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      } catch (f2) {
        this.postscriptName = s2[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "");
      }
      return this.trademark = s2[7], this.manufacturer = s2[8], this.designer = s2[9], this.description = s2[10], this.vendorUrl = s2[11], this.designerUrl = s2[12], this.license = s2[13], this.licenseUrl = s2[14], this.preferredFamily = s2[15], this.preferredSubfamily = s2[17], this.compatibleFull = s2[18], this.sampleText = s2[19];
    }, t2;
  })(), Ae = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "maxp", t2.prototype.parse = function(t3) {
      return t3.pos = this.offset, this.version = t3.readInt(), this.numGlyphs = t3.readUInt16(), this.maxPoints = t3.readUInt16(), this.maxContours = t3.readUInt16(), this.maxCompositePoints = t3.readUInt16(), this.maxComponentContours = t3.readUInt16(), this.maxZones = t3.readUInt16(), this.maxTwilightPoints = t3.readUInt16(), this.maxStorage = t3.readUInt16(), this.maxFunctionDefs = t3.readUInt16(), this.maxInstructionDefs = t3.readUInt16(), this.maxStackElements = t3.readUInt16(), this.maxSizeOfInstructions = t3.readUInt16(), this.maxComponentElements = t3.readUInt16(), this.maxComponentDepth = t3.readUInt16();
    }, t2;
  })(), Se = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "hmtx", t2.prototype.parse = function(t3) {
      var e2, n2, r2, i2, a2, o2, s2;
      for (t3.pos = this.offset, this.metrics = [], e2 = 0, o2 = this.file.hhea.numberOfMetrics; 0 <= o2 ? e2 < o2 : e2 > o2; e2 = 0 <= o2 ? ++e2 : --e2) this.metrics.push({ advance: t3.readUInt16(), lsb: t3.readInt16() });
      for (r2 = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = (function() {
        var n3, i3;
        for (i3 = [], e2 = n3 = 0; 0 <= r2 ? n3 < r2 : n3 > r2; e2 = 0 <= r2 ? ++n3 : --n3) i3.push(t3.readInt16());
        return i3;
      })(), this.widths = (function() {
        var t4, e3, n3, r3;
        for (r3 = [], t4 = 0, e3 = (n3 = this.metrics).length; t4 < e3; t4++) i2 = n3[t4], r3.push(i2.advance);
        return r3;
      }).call(this), n2 = this.widths[this.widths.length - 1], s2 = [], e2 = a2 = 0; 0 <= r2 ? a2 < r2 : a2 > r2; e2 = 0 <= r2 ? ++a2 : --a2) s2.push(this.widths.push(n2));
      return s2;
    }, t2.prototype.forGlyph = function(t3) {
      return t3 in this.metrics ? this.metrics[t3] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[t3 - this.metrics.length] };
    }, t2;
  })(), _e = [].slice, Pe = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "glyf", t2.prototype.parse = function() {
      return this.cache = {};
    }, t2.prototype.glyphFor = function(t3) {
      var e2, n2, r2, i2, a2, o2, s2, u2, c2, l2;
      return t3 in this.cache ? this.cache[t3] : (i2 = this.file.loca, e2 = this.file.contents, n2 = i2.indexOf(t3), 0 === (r2 = i2.lengthOf(t3)) ? this.cache[t3] = null : (e2.pos = this.offset + n2, a2 = (o2 = new fe(e2.read(r2))).readShort(), u2 = o2.readShort(), l2 = o2.readShort(), s2 = o2.readShort(), c2 = o2.readShort(), this.cache[t3] = -1 === a2 ? new Fe(o2, u2, l2, s2, c2) : new ke(o2, a2, u2, l2, s2, c2), this.cache[t3]));
    }, t2.prototype.encode = function(t3, e2, n2) {
      var r2, i2, a2, o2, s2;
      for (a2 = [], i2 = [], o2 = 0, s2 = e2.length; o2 < s2; o2++) r2 = t3[e2[o2]], i2.push(a2.length), r2 && (a2 = a2.concat(r2.encode(n2)));
      return i2.push(a2.length), { table: a2, offsets: i2 };
    }, t2;
  })(), ke = (function() {
    function t2(t3, e2, n2, r2, i2, a2) {
      this.raw = t3, this.numberOfContours = e2, this.xMin = n2, this.yMin = r2, this.xMax = i2, this.yMax = a2, this.compound = false;
    }
    return t2.prototype.encode = function() {
      return this.raw.data;
    }, t2;
  })(), Fe = (function() {
    function t2(t3, e2, n2, r2, i2) {
      var a2, o2;
      for (this.raw = t3, this.xMin = e2, this.yMin = n2, this.xMax = r2, this.yMax = i2, this.compound = true, this.glyphIDs = [], this.glyphOffsets = [], a2 = this.raw; o2 = a2.readShort(), this.glyphOffsets.push(a2.pos), this.glyphIDs.push(a2.readUInt16()), 32 & o2; ) a2.pos += 1 & o2 ? 4 : 2, 128 & o2 ? a2.pos += 8 : 64 & o2 ? a2.pos += 4 : 8 & o2 && (a2.pos += 2);
    }
    return t2.prototype.encode = function() {
      var t3, e2, n2;
      for (e2 = new fe(_e.call(this.raw.data)), t3 = 0, n2 = this.glyphIDs.length; t3 < n2; ++t3) e2.pos = this.glyphOffsets[t3];
      return e2.data;
    }, t2;
  })(), Ie = (function() {
    function t2() {
      return t2.__super__.constructor.apply(this, arguments);
    }
    return ge(t2, he), t2.prototype.tag = "loca", t2.prototype.parse = function(t3) {
      var e2, n2;
      return t3.pos = this.offset, e2 = this.file.head.indexToLocFormat, this.offsets = 0 === e2 ? (function() {
        var e3, r2;
        for (r2 = [], n2 = 0, e3 = this.length; n2 < e3; n2 += 2) r2.push(2 * t3.readUInt16());
        return r2;
      }).call(this) : (function() {
        var e3, r2;
        for (r2 = [], n2 = 0, e3 = this.length; n2 < e3; n2 += 4) r2.push(t3.readUInt32());
        return r2;
      }).call(this);
    }, t2.prototype.indexOf = function(t3) {
      return this.offsets[t3];
    }, t2.prototype.lengthOf = function(t3) {
      return this.offsets[t3 + 1] - this.offsets[t3];
    }, t2.prototype.encode = function(t3, e2) {
      for (var n2 = new Uint32Array(this.offsets.length), r2 = 0, i2 = 0, a2 = 0; a2 < n2.length; ++a2) if (n2[a2] = r2, i2 < e2.length && e2[i2] == a2) {
        ++i2, n2[a2] = r2;
        var o2 = this.offsets[a2], s2 = this.offsets[a2 + 1] - o2;
        s2 > 0 && (r2 += s2);
      }
      for (var u2 = new Array(4 * n2.length), c2 = 0; c2 < n2.length; ++c2) u2[4 * c2 + 3] = 255 & n2[c2], u2[4 * c2 + 2] = (65280 & n2[c2]) >> 8, u2[4 * c2 + 1] = (16711680 & n2[c2]) >> 16, u2[4 * c2] = (4278190080 & n2[c2]) >> 24;
      return u2;
    }, t2;
  })(), je = (function() {
    function t2(t3) {
      this.font = t3, this.subset = {}, this.unicodes = {}, this.next = 33;
    }
    return t2.prototype.generateCmap = function() {
      var t3, e2, n2, r2, i2;
      for (e2 in r2 = this.font.cmap.tables[0].codeMap, t3 = {}, i2 = this.subset) n2 = i2[e2], t3[e2] = r2[n2];
      return t3;
    }, t2.prototype.glyphsFor = function(t3) {
      var e2, n2, r2, i2, a2, o2, s2;
      for (r2 = {}, a2 = 0, o2 = t3.length; a2 < o2; a2++) r2[i2 = t3[a2]] = this.font.glyf.glyphFor(i2);
      for (i2 in e2 = [], r2) (null != (n2 = r2[i2]) ? n2.compound : void 0) && e2.push.apply(e2, n2.glyphIDs);
      if (e2.length > 0) for (i2 in s2 = this.glyphsFor(e2)) n2 = s2[i2], r2[i2] = n2;
      return r2;
    }, t2.prototype.encode = function(t3, e2) {
      var n2, r2, i2, a2, o2, s2, u2, c2, l2, h2, f2, d2, p2, g2, m2;
      for (r2 in n2 = be.encode(this.generateCmap(), "unicode"), a2 = this.glyphsFor(t3), f2 = { 0: 0 }, m2 = n2.charMap) f2[(s2 = m2[r2]).old] = s2.new;
      for (d2 in h2 = n2.maxGlyphID, a2) d2 in f2 || (f2[d2] = h2++);
      return c2 = (function(t4) {
        var e3, n3;
        for (e3 in n3 = {}, t4) n3[t4[e3]] = e3;
        return n3;
      })(f2), l2 = Object.keys(c2).sort(function(t4, e3) {
        return t4 - e3;
      }), p2 = (function() {
        var t4, e3, n3;
        for (n3 = [], t4 = 0, e3 = l2.length; t4 < e3; t4++) o2 = l2[t4], n3.push(c2[o2]);
        return n3;
      })(), i2 = this.font.glyf.encode(a2, p2, f2), u2 = this.font.loca.encode(i2.offsets, p2), g2 = { cmap: this.font.cmap.raw(), glyf: i2.table, loca: u2, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(e2) }, this.font.os2.exists && (g2["OS/2"] = this.font.os2.raw()), this.font.directory.encode(g2);
    }, t2;
  })();
  E$1.API.PDFObject = (function() {
    var t2;
    function e2() {
    }
    return t2 = function(t3, e3) {
      return (Array(e3 + 1).join("0") + t3).slice(-e3);
    }, e2.convert = function(n2) {
      var r2, i2, a2, o2;
      if (Array.isArray(n2)) return "[" + (function() {
        var t3, i3, a3;
        for (a3 = [], t3 = 0, i3 = n2.length; t3 < i3; t3++) r2 = n2[t3], a3.push(e2.convert(r2));
        return a3;
      })().join(" ") + "]";
      if ("string" == typeof n2) return "/" + n2;
      if (null != n2 ? n2.isString : void 0) return "(" + n2 + ")";
      if (n2 instanceof Date) return "(D:" + t2(n2.getUTCFullYear(), 4) + t2(n2.getUTCMonth(), 2) + t2(n2.getUTCDate(), 2) + t2(n2.getUTCHours(), 2) + t2(n2.getUTCMinutes(), 2) + t2(n2.getUTCSeconds(), 2) + "Z)";
      if ("[object Object]" === {}.toString.call(n2)) {
        for (i2 in a2 = ["<<"], n2) o2 = n2[i2], a2.push("/" + i2 + " " + e2.convert(o2));
        return a2.push(">>"), a2.join("\n");
      }
      return "" + n2;
    }, e2;
  })();
  const registerLoadedFonts = (doc, cfg) => {
    const loadedFonts = cfg.loadedFonts;
    if (!loadedFonts || loadedFonts.length === 0) return;
    for (const font of loadedFonts) {
      try {
        doc.addFileToVFS(`${font.name}.ttf`, font.data);
        doc.addFont(`${font.name}.ttf`, font.name, "normal");
        if (cfg.debug) {
          console.log(`[html_to_vector_pdf] Registered font to jsPDF: ${font.name}`);
        }
      } catch (err) {
        console.warn(`[html_to_vector_pdf] Failed to register font ${font.name}:`, err);
      }
    }
  };
  const createBreakCounter = (uniqueBreaks) => {
    return (y2) => {
      let lo = 0;
      let hi = uniqueBreaks.length;
      while (lo < hi) {
        const mid = lo + hi >> 1;
        if (uniqueBreaks[mid] <= y2) lo = mid + 1;
        else hi = mid;
      }
      return lo;
    };
  };
  const normalizePageBreaks = (pageBreakBeforeYs) => {
    return Array.from(
      new Set(pageBreakBeforeYs.filter((y2) => Number.isFinite(y2) && y2 > 0))
    ).sort((a2, b2) => a2 - b2);
  };
  const detectRequiredFont = (text2) => {
    if (/^[\x00-\xFF]*$/.test(text2)) {
      return null;
    }
    if (/[\u4E00-\u9FFF]/.test(text2)) {
      return "NotoSansSC";
    }
    if (/[\u3040-\u309F\u30A0-\u30FF]/.test(text2)) {
      return "NotoSansJP";
    }
    if (/[\uAC00-\uD7AF]/.test(text2)) {
      return "NotoSansKR";
    }
    return "NotoSans";
  };
  const FONT_CDN_URLS = {
    NotoSansSC: {
      name: "NotoSansSC",
      url: "EMBEDDED",
      format: "truetype"
    },
    NotoSansJP: {
      name: "NotoSansJP",
      url: "EMBEDDED",
      format: "truetype"
    },
    NotoSansKR: {
      name: "NotoSansKR",
      url: "EMBEDDED",
      format: "truetype"
    },
    NotoSans: {
      name: "NotoSans",
      url: "EMBEDDED",
      format: "truetype"
    }
  };
  const loadFont = async (fontName) => {
    const fontDef = FONT_CDN_URLS[fontName];
    if (!fontDef) {
      throw new HtmlToVectorPdfError(`Font ${fontName} not found`);
    }
    if (fontDef.url === "EMBEDDED") {
      {
        throw new HtmlToVectorPdfError(
          "Font data not injected. Please run build script first."
        );
      }
    }
    throw new HtmlToVectorPdfError("CDN loading not implemented");
  };
  const detectRequiredFonts = (texts) => {
    const requiredFonts = /* @__PURE__ */ new Set();
    for (const text2 of texts) {
      const fontName = detectRequiredFont(text2);
      if (fontName) {
        requiredFonts.add(fontName);
      }
    }
    return requiredFonts;
  };
  const loadFontFromCDN = async (fontName) => {
    const fontDef = FONT_CDN_URLS[fontName];
    if (!fontDef) {
      throw new HtmlToVectorPdfError(`Font ${fontName} not found`);
    }
    const arrayBuffer = await loadFont(fontName);
    const bytes = new Uint8Array(arrayBuffer);
    let binary = "";
    for (let i2 = 0; i2 < bytes.length; i2++) {
      binary += String.fromCharCode(bytes[i2]);
    }
    const base642 = btoa(binary);
    return {
      name: fontDef.name,
      data: base642,
      format: fontDef.format
    };
  };
  const pickPdfFontFamily = (cssFontFamily) => {
    if (!cssFontFamily) return "helvetica";
    const fam = cssFontFamily.toLowerCase();
    if (fam.includes("notosanssc")) return "NotoSansSC";
    if (fam.includes("notosansjp")) return "NotoSansJP";
    if (fam.includes("notosanstc")) return "NotoSansTC";
    if (fam.includes("notosanskr")) return "NotoSansKR";
    if (fam.includes("times") || fam.includes("serif")) return "times";
    if (fam.includes("courier") || fam.includes("mono")) return "courier";
    return "helvetica";
  };
  const determinePdfFontStyle = (fontStyle2, fontWeight2) => {
    const isItalic = fontStyle2 === "italic" || fontStyle2 === "oblique";
    const isBold = fontWeight2 === "bold" || parseInt(fontWeight2 || "400") >= 700;
    if (isItalic && isBold) return "bolditalic";
    if (isItalic) return "italic";
    if (isBold) return "bold";
    return "normal";
  };
  const applyTextStyle = (doc, style, textScale, text2) => {
    let fontName = pickPdfFontFamily(style.fontFamily);
    if (text2 && ["helvetica", "times", "courier"].includes(fontName)) {
      const requiredFont = detectRequiredFont(text2);
      if (requiredFont) {
        fontName = requiredFont;
      }
    }
    const pdfFontStyle = determinePdfFontStyle(style.fontStyle, style.fontWeight);
    try {
      doc.setFont(fontName, pdfFontStyle);
    } catch (e2) {
      doc.setFont(fontName, "normal");
    }
    const fontSizePx = parseFloat(style.fontSize);
    const fontSizePt = px2pt(fontSizePx) * textScale;
    doc.setFontSize(fontSizePt);
    const color2 = parseColor$1(style.color);
    if (color2) doc.setTextColor(color2[0], color2[1], color2[2]);
  };
  const groupInlineText = (items) => {
    const groups = /* @__PURE__ */ new Map();
    for (const item of items) {
      if (item.type === "text" && item.inlineGroupId) {
        const existing = groups.get(item.inlineGroupId);
        if (existing) {
          existing.push(item);
        } else {
          groups.set(item.inlineGroupId, [item]);
        }
      }
    }
    return groups;
  };
  const processInlineTextGroups = (doc, items, cfg) => {
    const inlineTextGroups = groupInlineText(items);
    for (const groupItems of inlineTextGroups.values()) {
      groupItems.sort((a2, b2) => (a2.inlineOrder ?? 0) - (b2.inlineOrder ?? 0));
      const first = groupItems[0];
      const contentLeftMm = first.contentLeftMm ?? first.x;
      const contentRightMm = first.contentRightMm ?? (first.maxWidthMm ? contentLeftMm + first.maxWidthMm : contentLeftMm);
      const align = first.textAlign || "left";
      const widthsMm = [];
      let totalWidthMm = 0;
      for (let i2 = 0; i2 < groupItems.length; i2++) {
        const item = groupItems[i2];
        applyTextStyle(doc, item.style, cfg.text.scale, item.text);
        const w2 = doc.getTextWidth(item.text || "");
        widthsMm.push(w2);
        totalWidthMm += w2;
      }
      const availableWidthMm = Math.max(0, contentRightMm - contentLeftMm);
      let startX = contentLeftMm;
      if (align === "center") startX = contentLeftMm + (availableWidthMm - totalWidthMm) / 2;
      else if (align === "right") startX = contentRightMm - totalWidthMm;
      let cursorX = startX;
      for (let i2 = 0; i2 < groupItems.length; i2++) {
        const item = groupItems[i2];
        item.computedX = cursorX;
        item.textAlign = "left";
        cursorX += widthsMm[i2];
      }
    }
  };
  const drawBorderSide = (doc, x1, y1, x2, y2, widthPx, color2, style, side, px2mm) => {
    if (widthPx <= 0) return;
    doc.setDrawColor(color2[0], color2[1], color2[2]);
    doc.setLineDashPattern([], 0);
    doc.setLineCap(2);
    if (style === "double" && widthPx >= 3) {
      const widthMm = px2mm(widthPx);
      const lineThicknessMm = Math.max(widthMm / 3, 0.15);
      const gapMm = widthMm - 2 * lineThicknessMm;
      doc.setLineWidth(lineThicknessMm);
      if (side === "t") {
        doc.line(x1, y1, x2, y1);
        doc.line(x1, y1 + lineThicknessMm + gapMm, x2, y1 + lineThicknessMm + gapMm);
      } else if (side === "b") {
        doc.line(x1, y2, x2, y2);
        doc.line(x1, y2 - lineThicknessMm - gapMm, x2, y2 - lineThicknessMm - gapMm);
      } else if (side === "l") {
        doc.line(x1, y1, x1, y2);
        doc.line(x1 + lineThicknessMm + gapMm, y1, x1 + lineThicknessMm + gapMm, y2);
      } else if (side === "r") {
        doc.line(x2, y1, x2, y2);
        doc.line(x2 - lineThicknessMm - gapMm, y1, x2 - lineThicknessMm - gapMm, y2);
      }
    } else {
      const lineWidthMm = px2pt(widthPx) / 72 * 25.4;
      const overlapMm = 0.2;
      doc.setFillColor(color2[0], color2[1], color2[2]);
      if (side === "l" || side === "r") {
        const h2 = Math.abs(y2 - y1);
        const minY = Math.min(y1, y2);
        doc.rect(x1 - lineWidthMm / 2, minY - overlapMm, lineWidthMm, h2 + overlapMm * 2, "F");
      } else {
        const w2 = Math.abs(x2 - x1);
        const minX = Math.min(x1, x2);
        doc.rect(minX - overlapMm, y1 - lineWidthMm / 2, w2 + overlapMm * 2, lineWidthMm, "F");
      }
    }
  };
  const hasUniformBorder = (borderSides, borderColors, borderStyles) => {
    const { t: t2, r: r2, b: b2, l: l2 } = borderSides;
    const isUniformWidth = t2 === r2 && r2 === b2 && b2 === l2 && t2 > 0;
    const isUniformColor = borderColors.t[0] === borderColors.r[0] && borderColors.t[1] === borderColors.r[1] && borderColors.t[2] === borderColors.r[2] && borderColors.r[0] === borderColors.b[0] && borderColors.r[1] === borderColors.b[1] && borderColors.r[2] === borderColors.b[2] && borderColors.b[0] === borderColors.l[0] && borderColors.b[1] === borderColors.l[1] && borderColors.b[2] === borderColors.l[2];
    const isUniformStyle = borderStyles.t === borderStyles.r && borderStyles.r === borderStyles.b && borderStyles.b === borderStyles.l;
    return isUniformWidth && isUniformColor && isUniformStyle && borderStyles.t === "solid";
  };
  const renderBorder = (doc, item, renderY, px2mm) => {
    if (item.type !== "border" || !item.borderSides || !item.borderColors) return;
    const { t: t2, r: r2, b: b2, l: l2 } = item.borderSides;
    const colors = item.borderColors;
    const styles = item.borderStyles || { t: "solid", r: "solid", b: "solid", l: "solid" };
    if (hasUniformBorder(item.borderSides, colors, styles)) {
      doc.setDrawColor(colors.t[0], colors.t[1], colors.t[2]);
      doc.setLineWidth(px2pt(t2) / 72 * 25.4);
      doc.setLineDashPattern([], 0);
      doc.setLineCap(2);
      doc.rect(item.x, renderY, item.w, item.h, "D");
    } else {
      drawBorderSide(doc, item.x, renderY, item.x + item.w, renderY, t2, colors.t, styles.t, "t", px2mm);
      drawBorderSide(doc, item.x, renderY + item.h, item.x + item.w, renderY + item.h, b2, colors.b, styles.b, "b", px2mm);
      drawBorderSide(doc, item.x, renderY, item.x, renderY + item.h, l2, colors.l, styles.l, "l", px2mm);
      drawBorderSide(doc, item.x + item.w, renderY, item.x + item.w, renderY + item.h, r2, colors.r, styles.r, "r", px2mm);
    }
  };
  const renderBackground = (doc, item, renderY) => {
    if (item.type !== "background") return;
    const [r2, g2, b2] = parseColor$1(item.style.backgroundColor);
    doc.setFillColor(r2, g2, b2);
    doc.rect(item.x, renderY, item.w, item.h, "F");
  };
  const calculateDecorationPositions = (baseY, lineIndex, lineHeightMm, fontSizeMm) => ({
    underlineY: baseY + lineIndex * lineHeightMm + fontSizeMm * 0.1,
    strikeThroughY: baseY + lineIndex * lineHeightMm - fontSizeMm * 0.3
  });
  const drawTextDecorations = (doc, lineText, x2, baseY, lineIndex, lineHeightMm, fontSizeMm, align, color2, hasUnderline, hasLineThrough) => {
    if (!hasUnderline && !hasLineThrough) return;
    const lineWidth = doc.getTextWidth(lineText);
    let lineStartX = x2;
    if (align === "center") lineStartX = x2 - lineWidth / 2;
    else if (align === "right") lineStartX = x2 - lineWidth;
    doc.setDrawColor(color2[0], color2[1], color2[2]);
    doc.setLineWidth(fontSizeMm / 15);
    const { underlineY, strikeThroughY } = calculateDecorationPositions(
      baseY,
      lineIndex,
      lineHeightMm,
      fontSizeMm
    );
    if (hasUnderline) {
      doc.line(lineStartX, underlineY, lineStartX + lineWidth, underlineY);
    }
    if (hasLineThrough) {
      doc.line(lineStartX, strikeThroughY, lineStartX + lineWidth, strikeThroughY);
    }
  };
  const renderText = (doc, item, renderY, cfg, px2mm, debugTextRows) => {
    if (item.type !== "text" || !item.text) return;
    applyTextStyle(doc, item.style, cfg.text.scale, item.text);
    const x2 = item.computedX ?? item.x;
    const align = item.computedX != null ? "left" : item.textAlign || "left";
    const maxWidthMm = item.maxWidthMm ?? 0;
    const lineHeightMm = item.lineHeightMm ?? px2mm(parseFloat(item.style.fontSize)) * 1.2 * cfg.text.scale;
    const pdfTextWidthMm = doc.getTextWidth(item.text);
    const lines = item.noWrap ? [item.text] : wrapTextToWidth(doc, item.text, maxWidthMm);
    const baseY = renderY;
    if (cfg.debug && cfg.debugOverlay.enabled && maxWidthMm > 0) {
      debugTextRows.push({
        text: item.text.length > 60 ? `${item.text.slice(0, 57)}...` : item.text,
        rectsLen: item.rectsLen ?? null,
        cssNoWrap: item.cssNoWrap ?? null,
        noWrapFinal: item.noWrap ?? null,
        maxWidthMm: Number(maxWidthMm.toFixed(2)),
        pdfTextWidthMm: Number(pdfTextWidthMm.toFixed(2)),
        wrappedLines: lines.length,
        align
      });
    }
    const decoration = (item.style.textDecorationLine || item.style.textDecoration || "").toLowerCase();
    const hasUnderline = decoration.includes("underline");
    const hasLineThrough = decoration.includes("line-through");
    const fontSizeMm = px2mm(parseFloat(item.style.fontSize)) * cfg.text.scale;
    for (let i2 = 0; i2 < lines.length; i2++) {
      const lineText = lines[i2];
      doc.text(lineText, x2, baseY + i2 * lineHeightMm, { baseline: "alphabetic", align });
      if (hasUnderline || hasLineThrough) {
        const color2 = parseColor$1(item.style.color);
        drawTextDecorations(
          doc,
          lineText,
          x2,
          baseY,
          i2,
          lineHeightMm,
          fontSizeMm,
          align,
          color2,
          hasUnderline,
          hasLineThrough
        );
      }
    }
  };
  const renderImage = (doc, item, renderY, cfg) => {
    var _a2, _b2;
    if (item.type !== "image" || !item.imageSrc) return;
    try {
      const format = item.imageFormat || "PNG";
      doc.addImage(item.imageSrc, format, item.x, renderY, item.w, item.h);
    } catch (e2) {
      const err = new HtmlToVectorPdfError(
        "ASSET_LOAD_FAILED",
        "Failed to add image to PDF",
        { imageSrc: item.imageSrc },
        e2
      );
      (_b2 = (_a2 = cfg.callbacks).onError) == null ? void 0 : _b2.call(_a2, err);
      if (cfg.errors.failOnAssetError) throw err;
      if (cfg.debug) console.warn("[html_to_vector_pdf] Failed to add image:", e2);
    }
  };
  const renderDebugRect = (doc, item, renderY, cfg) => {
    if (item.type !== "debugRect" || !cfg.debugOverlay.enabled) return;
    const [r2, g2, b2] = cfg.debugOverlay.strokeColorRgb;
    doc.setDrawColor(r2, g2, b2);
    doc.setLineWidth(cfg.debugOverlay.lineWidthMm);
    doc.rect(item.x, renderY, item.w, item.h, "D");
  };
  const logDebugInfo = (doc, allElementItems, debugTextRows, cfg) => {
    if (!cfg.debug) return;
    console.log(
      `[html_to_vector_pdf] Generated ${doc.getNumberOfPages()} page(s) from ${allElementItems.length} element(s)`
    );
    if (cfg.debugOverlay.enabled && debugTextRows.length > 0) {
      console.table(debugTextRows);
    }
  };
  const calculatePagination = (itemY, forcedBreakCount, uniqueBreaks, contentH, marginTop2, currentStartPage) => {
    const forcedOffset = forcedBreakCount > 0 ? uniqueBreaks[forcedBreakCount - 1] : 0;
    const relativeY = itemY - forcedOffset;
    let renderY = marginTop2 + relativeY;
    const localPageIndex = forcedBreakCount + Math.floor(relativeY / contentH) + 1;
    const absolutePageIndex = currentStartPage + localPageIndex - 1;
    if (localPageIndex > 1) {
      renderY = marginTop2 + relativeY % contentH;
    }
    return {
      renderY,
      localPageIndex,
      absolutePageIndex
    };
  };
  const ensurePageExists = (doc, targetPage) => {
    while (doc.getNumberOfPages() < targetPage) {
      doc.addPage();
    }
    doc.setPage(targetPage);
  };
  const renderToPdf = async (allElementItems, cfg, px2mm) => {
    var _a2, _b2, _c, _d;
    const doc = new E$1({
      orientation: cfg.orientation,
      unit: "mm",
      format: cfg.pageSize
    });
    registerLoadedFonts(doc, cfg);
    const pageH = doc.internal.pageSize.getHeight();
    const contentH = pageH - cfg.margins.top - cfg.margins.bottom;
    const maybeYield = createYieldController({
      yieldEveryNodes: cfg.performance.yieldEveryNodes,
      yieldEveryMs: cfg.performance.yieldEveryMs,
      strategy: cfg.performance.yieldStrategy
    });
    const debugTextRows = [];
    let currentStartPage = 1;
    for (let elemIdx = 0; elemIdx < allElementItems.length; elemIdx++) {
      (_b2 = (_a2 = cfg.callbacks).onProgress) == null ? void 0 : _b2.call(_a2, "render:element:start", { elementIndex: elemIdx, elementCount: allElementItems.length });
      const { items, pageBreakBeforeYs } = allElementItems[elemIdx];
      if (elemIdx > 0) {
        doc.addPage();
        currentStartPage = doc.getNumberOfPages();
      }
      const uniqueBreaks = normalizePageBreaks(pageBreakBeforeYs);
      const countBreaksAtOrBefore = createBreakCounter(uniqueBreaks);
      processInlineTextGroups(doc, items, cfg);
      const sorted = items.slice().sort((a2, b2) => a2.zIndex - b2.zIndex);
      for (let itemIdx = 0; itemIdx < sorted.length; itemIdx++) {
        await maybeYield(itemIdx + 1);
        const item = sorted[itemIdx];
        const forcedBreakCount = uniqueBreaks.length ? countBreaksAtOrBefore(item.y) : 0;
        const pagination = calculatePagination(
          item.y,
          forcedBreakCount,
          uniqueBreaks,
          contentH,
          cfg.margins.top,
          currentStartPage
        );
        ensurePageExists(doc, pagination.absolutePageIndex);
        if (item.type === "background") {
          renderBackground(doc, item, pagination.renderY);
          continue;
        }
        if (item.type === "border") {
          renderBorder(doc, item, pagination.renderY, px2mm);
          continue;
        }
        if (item.type === "debugRect") {
          renderDebugRect(doc, item, pagination.renderY, cfg);
          continue;
        }
        if (item.type === "text") {
          renderText(doc, item, pagination.renderY, cfg, px2mm, debugTextRows);
          continue;
        }
        if (item.type === "image") {
          renderImage(doc, item, pagination.renderY, cfg);
          continue;
        }
      }
      currentStartPage = doc.getNumberOfPages() + 1;
      (_d = (_c = cfg.callbacks).onProgress) == null ? void 0 : _d.call(_c, "render:element:done", { elementIndex: elemIdx, elementCount: allElementItems.length });
    }
    logDebugInfo(doc, allElementItems, debugTextRows, cfg);
    return doc;
  };
  const getGlobalOverrides = () => {
    if (typeof window === "undefined") {
      return {};
    }
    const win = window;
    return {
      margins: win.html_to_vector_pdf_margins,
      pageSize: win.html_to_vector_pdf_page_size,
      orientation: win.html_to_vector_pdf_orientation
    };
  };
  const mergeConfigSection = (defaultValue, userValue) => ({
    ...defaultValue,
    ...userValue || {}
  });
  const mergeConfig = (config) => {
    var _a2;
    const globalOverrides = getGlobalOverrides();
    return {
      ...DEFAULT_CONFIG,
      ...config,
      // Global overrides (highest priority)
      ...globalOverrides.pageSize ? { pageSize: globalOverrides.pageSize } : {},
      ...globalOverrides.orientation ? { orientation: globalOverrides.orientation } : {},
      margins: {
        ...DEFAULT_CONFIG.margins,
        ...config.margins,
        ...globalOverrides.margins || {}
      },
      excludeSelectors: [
        ...DEFAULT_EXCLUDE_SELECTORS,
        ...config.excludeSelectors || []
      ],
      callbacks: mergeConfigSection(DEFAULT_CONFIG.callbacks, config.callbacks),
      performance: mergeConfigSection(DEFAULT_CONFIG.performance, config.performance),
      errors: mergeConfigSection(DEFAULT_CONFIG.errors, config.errors),
      text: mergeConfigSection(DEFAULT_CONFIG.text, config.text),
      render: mergeConfigSection(DEFAULT_CONFIG.render, config.render),
      pagination: {
        ...DEFAULT_CONFIG.pagination,
        ...config.pagination || {},
        pageBreakBeforeSelectors: [
          ...DEFAULT_CONFIG.pagination.pageBreakBeforeSelectors || [],
          ...((_a2 = config.pagination) == null ? void 0 : _a2.pageBreakBeforeSelectors) || []
        ]
      },
      debugOverlay: mergeConfigSection(DEFAULT_CONFIG.debugOverlay, config.debugOverlay)
    };
  };
  const findElements = (elementOrSelector) => {
    let elements2 = [];
    if (typeof elementOrSelector === "string") {
      const byId = document.getElementById(elementOrSelector);
      if (byId) {
        elements2 = [byId];
      } else {
        const nodeList = document.querySelectorAll(elementOrSelector);
        elements2 = Array.from(nodeList);
      }
    } else {
      elements2 = [elementOrSelector];
    }
    if (elements2.length === 0) {
      throw new HtmlToVectorPdfError(
        "ELEMENT_NOT_FOUND",
        "Element not found",
        { target: elementOrSelector }
      );
    }
    return elements2;
  };
  const validateElementSizes = (elements2, elementOrSelector) => {
    for (const el of elements2) {
      const rect = el.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) {
        throw new HtmlToVectorPdfError(
          "ELEMENT_ZERO_SIZE",
          "Element has zero size",
          {
            target: typeof elementOrSelector === "string" ? elementOrSelector : "HTMLElement",
            width: rect.width,
            height: rect.height
          }
        );
      }
    }
  };
  const extractTextsFromItems = (allElementItems) => {
    return allElementItems.flatMap(
      (elemItems) => elemItems.items.filter(
        (item) => item.type === "text" && typeof item.text === "string"
      ).map((item) => item.text)
    );
  };
  const processFontLoadResults = (loadedResults, requiredFontsArray, cfg) => {
    var _a2, _b2;
    const loadedFonts = [];
    for (let i2 = 0; i2 < loadedResults.length; i2++) {
      const result = loadedResults[i2];
      if (result.status === "fulfilled") {
        loadedFonts.push(result.value);
        if (cfg.debug) {
          console.log(`[html_to_vector_pdf] Loaded font: ${result.value.name}`);
        }
      } else {
        const fontName = requiredFontsArray[i2];
        console.warn(`[html_to_vector_pdf] Failed to load font ${fontName}:`, result.reason);
        (_b2 = (_a2 = cfg.callbacks).onError) == null ? void 0 : _b2.call(_a2, result.reason);
      }
    }
    return loadedFonts;
  };
  const processFonts = async (allTexts, cfg) => {
    var _a2, _b2, _c, _d, _e2, _f;
    (_b2 = (_a2 = cfg.callbacks).onProgress) == null ? void 0 : _b2.call(_a2, "font:detect:start", {});
    const requiredFonts = detectRequiredFonts(allTexts);
    const loadedFonts = [];
    if (requiredFonts.size === 0) {
      return { loadedFonts, requiredFonts };
    }
    const requiredFontsArray = Array.from(requiredFonts);
    (_d = (_c = cfg.callbacks).onProgress) == null ? void 0 : _d.call(_c, "font:load:start", { fonts: requiredFontsArray });
    if (cfg.debug) {
      console.log("[html_to_vector_pdf] Loading fonts from CDN:", requiredFontsArray);
    }
    const fontPromises = requiredFontsArray.map((fontName) => loadFontFromCDN(fontName));
    const loadedResults = await Promise.allSettled(fontPromises);
    const successfullyLoadedFonts = processFontLoadResults(loadedResults, requiredFontsArray, cfg);
    (_f = (_e2 = cfg.callbacks).onProgress) == null ? void 0 : _f.call(_e2, "font:load:done", { loadedCount: successfullyLoadedFonts.length });
    return { loadedFonts: successfullyLoadedFonts, requiredFonts };
  };
  const DEFAULT_OPTIONS = {
    timeout: 1e4,
    debug: false,
    minFrames: 2,
    settleDelay: 50
  };
  const waitForFrames = (count) => {
    return new Promise((resolve) => {
      let remaining = count;
      const tick = () => {
        remaining--;
        if (remaining <= 0) {
          resolve();
        } else {
          requestAnimationFrame(tick);
        }
      };
      requestAnimationFrame(tick);
    });
  };
  const waitForFonts = async (debug) => {
    var _a2;
    if (typeof document === "undefined") return;
    if (!((_a2 = document.fonts) == null ? void 0 : _a2.ready)) {
      if (debug) console.log("[renderReady] document.fonts.ready not supported, skipping font wait");
      return;
    }
    try {
      await document.fonts.ready;
      if (debug) console.log("[renderReady] Fonts ready");
    } catch (e2) {
      if (debug) console.warn("[renderReady] Font loading check failed:", e2);
    }
  };
  const waitForImages = (element, debug) => {
    return new Promise((resolve) => {
      const images = element.querySelectorAll("img");
      if (images.length === 0) {
        if (debug) console.log("[renderReady] No images found");
        resolve();
        return;
      }
      let loadedCount = 0;
      let errorCount = 0;
      const totalImages = images.length;
      const checkComplete = () => {
        if (loadedCount + errorCount >= totalImages) {
          if (debug) {
            console.log(`[renderReady] Images complete: ${loadedCount} loaded, ${errorCount} errors, ${totalImages} total`);
          }
          resolve();
        }
      };
      images.forEach((img) => {
        if (img.complete && img.naturalHeight > 0) {
          loadedCount++;
          checkComplete();
        } else if (img.complete) {
          errorCount++;
          checkComplete();
        } else {
          const onLoad = () => {
            loadedCount++;
            img.removeEventListener("load", onLoad);
            img.removeEventListener("error", onError);
            checkComplete();
          };
          const onError = () => {
            errorCount++;
            img.removeEventListener("load", onLoad);
            img.removeEventListener("error", onError);
            checkComplete();
          };
          img.addEventListener("load", onLoad);
          img.addEventListener("error", onError);
        }
      });
      checkComplete();
    });
  };
  const waitForBackgroundImages = async (element, debug) => {
    const bgUrls = /* @__PURE__ */ new Set();
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT);
    let node2 = walker.currentNode;
    while (node2) {
      const style = window.getComputedStyle(node2);
      const bgImage = style.backgroundImage;
      if (bgImage && bgImage !== "none") {
        const urlMatch = bgImage.match(/url\(["']?([^"')]+)["']?\)/);
        if (urlMatch && urlMatch[1]) {
          bgUrls.add(urlMatch[1]);
        }
      }
      node2 = walker.nextNode();
    }
    if (bgUrls.size === 0) {
      if (debug) console.log("[renderReady] No background images found");
      return;
    }
    if (debug) console.log(`[renderReady] Found ${bgUrls.size} background images to preload`);
    const preloadPromises = Array.from(bgUrls).map((url) => {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve();
        img.onerror = () => resolve();
        img.src = url;
      });
    });
    await Promise.all(preloadPromises);
    if (debug) console.log("[renderReady] Background images loaded");
  };
  const waitForElementsReady = async (elements2, options = {}) => {
    const opts = { ...DEFAULT_OPTIONS, ...options };
    const { debug } = opts;
    if (elements2.length === 0) return;
    if (debug) console.log(`[renderReady] Checking ${elements2.length} element(s)...`);
    await waitForFonts(debug);
    const imagePromises = elements2.flatMap((el) => [
      waitForImages(el, debug),
      waitForBackgroundImages(el, debug)
    ]);
    await Promise.all(imagePromises);
    await waitForFrames(opts.minFrames);
    if (opts.settleDelay > 0) {
      await new Promise((r2) => setTimeout(r2, opts.settleDelay));
    }
    await waitForFrames(1);
    if (debug) console.log("[renderReady] All elements ready");
  };
  const LOADER_ID$1 = "html-vector-pdf-loader-gen";
  const showLoaderUI = (label = "Generating PDF...") => {
    if (typeof document === "undefined") return;
    let loader = document.getElementById(LOADER_ID$1);
    if (!loader) {
      loader = document.createElement("div");
      loader.id = LOADER_ID$1;
      loader.style.cssText = `
      position: fixed; inset: 0; z-index: 2147483648;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; font-family: system-ui, sans-serif; transition: opacity 0.2s;
    `;
      loader.innerHTML = `
      <style>
        .hv-pdf-spinner-gen {
          width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
          border-top-color: white; border-radius: 50%;
          animation: hv-pdf-spin-gen 1s linear infinite; margin-bottom: 16px;
        }
        @keyframes hv-pdf-spin-gen { to { transform: rotate(360deg); } }
      </style>
      <div class="hv-pdf-spinner-gen"></div>
      <div id="${LOADER_ID$1}-text" style="font-size: 16px; font-weight: 500;">${label}</div>
    `;
      document.body.appendChild(loader);
    } else {
      const textEl = document.getElementById(`${LOADER_ID$1}-text`);
      if (textEl) textEl.textContent = label;
      loader.style.display = "flex";
    }
  };
  const hideLoaderUI = () => {
    if (typeof document === "undefined") return;
    const loader = document.getElementById(LOADER_ID$1);
    if (loader) {
      loader.style.opacity = "0";
      setTimeout(() => loader.remove(), 200);
    }
  };
  const generatePdf = async (elementOrSelector, config = {}) => {
    var _a2, _b2, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t2, _u, _v, _w;
    const cfg = mergeConfig(config);
    const pxToMm = cfg.render.pxToMm ?? getPxToMm();
    const px2mm = (px) => px * pxToMm;
    const maybeYield = createYieldController({
      yieldEveryNodes: cfg.performance.yieldEveryNodes,
      yieldEveryMs: cfg.performance.yieldEveryMs,
      strategy: cfg.performance.yieldStrategy
    });
    const showLoader2 = ((_a2 = config.ui) == null ? void 0 : _a2.showLoader) !== false;
    if (showLoader2) showLoaderUI("Generating PDF...");
    try {
      (_c = (_b2 = cfg.callbacks).onProgress) == null ? void 0 : _c.call(_b2, "select:start", {
        target: typeof elementOrSelector === "string" ? elementOrSelector : "HTMLElement"
      });
      const elements2 = findElements(elementOrSelector);
      validateElementSizes(elements2, elementOrSelector);
      (_e2 = (_d = cfg.callbacks).onProgress) == null ? void 0 : _e2.call(_d, "select:done", { elementCount: elements2.length });
      (_g = (_f = cfg.callbacks).onProgress) == null ? void 0 : _g.call(_f, "render:wait:start", { elementCount: elements2.length });
      await waitForElementsReady(elements2, {
        timeout: cfg.performance.renderReadyTimeout ?? 1e4,
        debug: cfg.debug,
        minFrames: 2,
        settleDelay: 50
      });
      (_i = (_h = cfg.callbacks).onProgress) == null ? void 0 : _i.call(_h, "render:wait:done", { elementCount: elements2.length });
      if (cfg.debug) {
        console.log(`[html_to_vector_pdf] Found ${elements2.length} element(s) to convert`);
        console.log("[html_to_vector_pdf] debug", {
          pxToMm,
          marginsMm: cfg.margins,
          textScale: cfg.text.scale,
          pageBreakBeforeSelectors: cfg.pagination.pageBreakBeforeSelectors
        });
      }
      const allElementItems = [];
      for (let elemIdx = 0; elemIdx < elements2.length; elemIdx++) {
        (_k = (_j = cfg.callbacks).onProgress) == null ? void 0 : _k.call(_j, "parse:element:start", { elementIndex: elemIdx, elementCount: elements2.length });
        const element = elements2[elemIdx];
        const parsed = await parseElementToItems(element, cfg, px2mm);
        if (cfg.debug) {
          console.log(`[html_to_vector_pdf] Element ${elemIdx + 1}: Parsed ${parsed.items.length} render items`);
        }
        allElementItems.push(parsed);
        (_m = (_l = cfg.callbacks).onProgress) == null ? void 0 : _m.call(_l, "parse:element:done", {
          elementIndex: elemIdx,
          elementCount: elements2.length,
          renderItemCount: parsed.items.length
        });
        await maybeYield(elemIdx + 1);
      }
      const allTexts = extractTextsFromItems(allElementItems);
      const { loadedFonts } = await processFonts(allTexts, cfg);
      if (loadedFonts.length > 0) {
        cfg.loadedFonts = loadedFonts;
      }
      (_o = (_n = cfg.callbacks).onProgress) == null ? void 0 : _o.call(_n, "render:start", { elementCount: allElementItems.length });
      const doc = await renderToPdf(allElementItems, cfg, px2mm);
      (_q = (_p = cfg.callbacks).onProgress) == null ? void 0 : _q.call(_p, "render:done", { pageCount: doc.getNumberOfPages() });
      (_s = (_r = cfg.callbacks).onProgress) == null ? void 0 : _s.call(_r, "save:start", { filename: cfg.filename });
      doc.save(cfg.filename);
      (_u = (_t2 = cfg.callbacks).onProgress) == null ? void 0 : _u.call(_t2, "save:done", { filename: cfg.filename });
    } catch (err) {
      const e2 = asHtmlToVectorPdfError(err, { code: "GENERATION_FAILED", message: "PDF generation failed" });
      (_w = (_v = cfg.callbacks).onError) == null ? void 0 : _w.call(_v, e2);
      throw e2;
    } finally {
      if (showLoader2) hideLoaderUI();
    }
  };
  const defaultFileName = ({ now }) => {
    const pad2 = (n2) => String(n2).padStart(2, "0");
    const yyyy = now.getFullYear();
    const mm = pad2(now.getMonth() + 1);
    const dd = pad2(now.getDate());
    const hh = pad2(now.getHours());
    const mi = pad2(now.getMinutes());
    const ss = pad2(now.getSeconds());
    return `html_export_${yyyy}${mm}${dd}_${hh}${mi}${ss}.pdf`;
  };
  const DEFAULT_INIT_OPTIONS = {
    selector: ".html_to_vector_pdf",
    button: {
      mode: "inject",
      targetSelector: "",
      label: "Download PDF",
      generatingLabel: "Generating",
      fixed: true
    },
    pdf: {},
    generate: {},
    filename: defaultFileName,
    onProgress: void 0,
    onError: void 0,
    showLoader: true
  };
  let state = null;
  const applyButtonStyles = (btn) => {
    btn.type = "button";
    btn.style.fontFamily = "system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif";
    btn.style.fontSize = "14px";
    btn.style.lineHeight = "1";
    btn.style.padding = "10px 12px";
    btn.style.borderRadius = "10px";
    btn.style.border = "1px solid rgba(0,0,0,0.12)";
    btn.style.background = "white";
    btn.style.color = "#111827";
    btn.style.boxShadow = "0 6px 24px rgba(0,0,0,0.12)";
    btn.style.cursor = "pointer";
    btn.style.userSelect = "none";
    btn.style.touchAction = "manipulation";
  };
  const ensureContainerPosition = (container) => {
    const style = window.getComputedStyle(container);
    if (style.position === "static") container.style.position = "relative";
  };
  const injectButton = (options) => {
    const container = document.querySelector(options.selector);
    if (!container) return null;
    ensureContainerPosition(container);
    const btn = document.createElement("button");
    btn.id = "html-to-vector-pdf-btn";
    btn.textContent = options.button.label;
    applyButtonStyles(btn);
    if (options.button.fixed) {
      btn.style.position = "fixed";
      btn.style.right = "16px";
      btn.style.top = "16px";
      btn.style.zIndex = "2147483647";
    } else {
      btn.style.position = "absolute";
      btn.style.right = "12px";
      btn.style.top = "12px";
      btn.style.zIndex = "10";
    }
    (options.button.fixed ? document.body : container).appendChild(btn);
    return btn;
  };
  const bindButton = (options) => {
    if (!options.button.targetSelector) return null;
    return document.querySelector(options.button.targetSelector);
  };
  const setButtonBusy = (btn, busy, options) => {
    if (btn instanceof HTMLButtonElement) btn.disabled = busy;
    btn.textContent = busy ? options.button.generatingLabel : options.button.label;
    btn.style.opacity = busy ? "0.65" : "1";
    btn.style.cursor = busy ? "not-allowed" : "pointer";
  };
  const LOADER_ID = "html-vector-pdf-loader";
  const showLoader = (label = "Generating PDF...") => {
    let loader = document.getElementById(LOADER_ID);
    if (!loader) {
      loader = document.createElement("div");
      loader.id = LOADER_ID;
      loader.style.cssText = `
      position: fixed; inset: 0; z-index: 2147483648;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(2px);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      color: white; font-family: system-ui, sans-serif; transition: opacity 0.2s;
    `;
      loader.innerHTML = `
      <style>
        .hv-pdf-spinner {
          width: 40px; height: 40px; border: 4px solid rgba(255,255,255,0.3);
          border-top-color: white; border-radius: 50%;
          animation: hv-pdf-spin 1s linear infinite; margin-bottom: 16px;
        }
        @keyframes hv-pdf-spin { to { transform: rotate(360deg); } }
      </style>
      <div class="hv-pdf-spinner"></div>
      <div id="${LOADER_ID}-text" style="font-size: 16px; font-weight: 500;">${label}</div>
    `;
      document.body.appendChild(loader);
    } else {
      const textEl = document.getElementById(`${LOADER_ID}-text`);
      if (textEl) textEl.textContent = label;
      loader.style.display = "flex";
    }
  };
  const hideLoader = () => {
    const loader = document.getElementById(LOADER_ID);
    if (loader) {
      loader.style.opacity = "0";
      setTimeout(() => {
        loader.remove();
      }, 200);
    }
  };
  const exportPdf = async (override) => {
    if (!state) throw new Error("HtmlToVectorPDF is not initialized. Call init(options) first.");
    const merged = {
      ...state.options,
      ...override || {},
      button: { ...state.options.button, ...(override == null ? void 0 : override.button) || {} },
      pdf: { ...state.options.pdf, ...(override == null ? void 0 : override.pdf) || {} },
      generate: { ...state.options.generate, ...(override == null ? void 0 : override.generate) || {} }
    };
    const filenameSource = merged.filename ?? state.options.filename;
    const filename = typeof filenameSource === "function" ? filenameSource({ now: /* @__PURE__ */ new Date() }) : filenameSource;
    await generatePdf(merged.selector, {
      ...merged.generate || {},
      ...merged.pdf || {},
      filename,
      callbacks: {
        onProgress: merged.onProgress,
        onError: merged.onError
      }
    });
  };
  const init = (options = {}) => {
    const merged = {
      ...DEFAULT_INIT_OPTIONS,
      ...options,
      button: { ...DEFAULT_INIT_OPTIONS.button, ...options.button || {} },
      pdf: { ...DEFAULT_INIT_OPTIONS.pdf, ...options.pdf || {} },
      generate: { ...DEFAULT_INIT_OPTIONS.generate, ...options.generate || {} }
    };
    if (state == null ? void 0 : state.clickHandler) {
      if (state.buttonEl) state.buttonEl.removeEventListener("click", state.clickHandler);
      if (state.boundEl) state.boundEl.removeEventListener("click", state.clickHandler);
    }
    if (state == null ? void 0 : state.buttonEl) state.buttonEl.remove();
    const clickHandler = (ev) => {
      ev.preventDefault();
      void (async () => {
        const btn = (state == null ? void 0 : state.buttonEl) || (state == null ? void 0 : state.boundEl);
        if (btn) setButtonBusy(btn, true, merged);
        if (merged.showLoader) showLoader(merged.button.generatingLabel);
        try {
          await exportPdf();
        } finally {
          if (btn) setButtonBusy(btn, false, merged);
          if (merged.showLoader) hideLoader();
        }
      })();
    };
    let buttonEl = null;
    let boundEl = null;
    if (merged.button.mode === "inject") {
      buttonEl = injectButton(merged);
      if (buttonEl) buttonEl.addEventListener("click", clickHandler);
    } else if (merged.button.mode === "bind") {
      boundEl = bindButton(merged);
      if (boundEl) boundEl.addEventListener("click", clickHandler);
    }
    state = { options: merged, buttonEl, boundEl, clickHandler };
  };
  const destroy = () => {
    if (!state) return;
    if (state.clickHandler) {
      if (state.buttonEl) state.buttonEl.removeEventListener("click", state.clickHandler);
      if (state.boundEl) state.boundEl.removeEventListener("click", state.clickHandler);
    }
    if (state.buttonEl) state.buttonEl.remove();
    state = null;
  };
  const HtmlToVectorPDF = { init, export: exportPdf, destroy };
  try {
    if (typeof window !== "undefined") window.HtmlToVectorPDF = HtmlToVectorPDF;
  } catch {
  }
  const pdfGenerator = { generatePdf, init, exportPdf, destroy, DEFAULT_CONFIG };
  /*!
   * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
   * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
   * Released under MIT License
   */
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s2 = arguments[i2];
        for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  function __awaiter(thisArg, _arguments, P2, generator) {
    function adopt(value) {
      return value instanceof P2 ? value : new P2(function(resolve) {
        resolve(value);
      });
    }
    return new (P2 || (P2 = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e2) {
          reject(e2);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e2) {
          reject(e2);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _2 = { label: 0, sent: function() {
      if (t2[0] & 1) throw t2[1];
      return t2[1];
    }, trys: [], ops: [] }, f2, y2, t2, g2;
    return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
      return this;
    }), g2;
    function verb(n2) {
      return function(v2) {
        return step([n2, v2]);
      };
    }
    function step(op) {
      if (f2) throw new TypeError("Generator is already executing.");
      while (_2) try {
        if (f2 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
        if (y2 = 0, t2) op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y2 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t2[1]) {
              _2.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _2.label < t2[2]) {
              _2.label = t2[2];
              _2.ops.push(op);
              break;
            }
            if (t2[2]) _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e2) {
        op = [6, e2];
        y2 = 0;
      } finally {
        f2 = t2 = 0;
      }
      if (op[0] & 5) throw op[1];
      return { value: op[0] ? op[1] : void 0, done: true };
    }
  }
  function __spreadArray(to, from, pack2) {
    if (arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
      if (ar || !(i2 in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
        ar[i2] = from[i2];
      }
    }
    return to.concat(ar || from);
  }
  var Bounds = (
    /** @class */
    (function() {
      function Bounds2(left, top, width, height) {
        this.left = left;
        this.top = top;
        this.width = width;
        this.height = height;
      }
      Bounds2.prototype.add = function(x2, y2, w2, h2) {
        return new Bounds2(this.left + x2, this.top + y2, this.width + w2, this.height + h2);
      };
      Bounds2.fromClientRect = function(context, clientRect) {
        return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
      };
      Bounds2.fromDOMRectList = function(context, domRectList) {
        var domRect = Array.from(domRectList).find(function(rect) {
          return rect.width !== 0;
        });
        return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
      };
      Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
      return Bounds2;
    })()
  );
  var parseBounds = function(context, node2) {
    return Bounds.fromClientRect(context, node2.getBoundingClientRect());
  };
  var parseDocumentSize = function(document2) {
    var body = document2.body;
    var documentElement = document2.documentElement;
    if (!body || !documentElement) {
      throw new Error("Unable to get document size");
    }
    var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
    var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
    return new Bounds(0, 0, width, height);
  };
  var toCodePoints$1 = function(str) {
    var codePoints = [];
    var i2 = 0;
    var length = str.length;
    while (i2 < length) {
      var value = str.charCodeAt(i2++);
      if (value >= 55296 && value <= 56319 && i2 < length) {
        var extra = str.charCodeAt(i2++);
        if ((extra & 64512) === 56320) {
          codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          codePoints.push(value);
          i2--;
        }
      } else {
        codePoints.push(value);
      }
    }
    return codePoints;
  };
  var fromCodePoint$1 = function() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    if (String.fromCodePoint) {
      return String.fromCodePoint.apply(String, codePoints);
    }
    var length = codePoints.length;
    if (!length) {
      return "";
    }
    var codeUnits = [];
    var index2 = -1;
    var result = "";
    while (++index2 < length) {
      var codePoint = codePoints[index2];
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
      }
      if (index2 + 1 === length || codeUnits.length > 16384) {
        result += String.fromCharCode.apply(String, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
  var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
    lookup$2[chars$2.charCodeAt(i$2)] = i$2;
  }
  var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
    lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
  }
  var decode$1 = function(base642) {
    var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base642[base642.length - 1] === "=") {
      bufferLength--;
      if (base642[base642.length - 2] === "=") {
        bufferLength--;
      }
    }
    var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
    var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
    for (i2 = 0; i2 < len; i2 += 4) {
      encoded1 = lookup$1$1[base642.charCodeAt(i2)];
      encoded2 = lookup$1$1[base642.charCodeAt(i2 + 1)];
      encoded3 = lookup$1$1[base642.charCodeAt(i2 + 2)];
      encoded4 = lookup$1$1[base642.charCodeAt(i2 + 3)];
      bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
  };
  var polyUint16Array$1 = function(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i2 = 0; i2 < length; i2 += 2) {
      bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
    }
    return bytes;
  };
  var polyUint32Array$1 = function(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i2 = 0; i2 < length; i2 += 4) {
      bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
    }
    return bytes;
  };
  var UTRIE2_SHIFT_2$1 = 5;
  var UTRIE2_SHIFT_1$1 = 6 + 5;
  var UTRIE2_INDEX_SHIFT$1 = 2;
  var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
  var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
  var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
  var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
  var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
  var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
  var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
  var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
  var slice16$1 = function(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32$1 = function(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64$1 = function(base642, _byteLength) {
    var buffer = decode$1(base642);
    var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
    var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
    var headerLength = 24;
    var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
    var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
    return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
  };
  var Trie$1 = (
    /** @class */
    (function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index2;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    })()
  );
  var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
    lookup$3[chars$3.charCodeAt(i$3)] = i$3;
  }
  var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
  var LETTER_NUMBER_MODIFIER = 50;
  var BK = 1;
  var CR$1 = 2;
  var LF$1 = 3;
  var CM = 4;
  var NL = 5;
  var WJ = 7;
  var ZW = 8;
  var GL = 9;
  var SP = 10;
  var ZWJ$1 = 11;
  var B2 = 12;
  var BA = 13;
  var BB = 14;
  var HY = 15;
  var CB = 16;
  var CL = 17;
  var CP = 18;
  var EX = 19;
  var IN = 20;
  var NS = 21;
  var OP = 22;
  var QU = 23;
  var IS = 24;
  var NU = 25;
  var PO = 26;
  var PR = 27;
  var SY = 28;
  var AI = 29;
  var AL = 30;
  var CJ = 31;
  var EB = 32;
  var EM = 33;
  var H2 = 34;
  var H3 = 35;
  var HL = 36;
  var ID = 37;
  var JL = 38;
  var JV = 39;
  var JT = 40;
  var RI$1 = 41;
  var SA = 42;
  var XX = 43;
  var ea_OP = [9001, 65288];
  var BREAK_MANDATORY = "!";
  var BREAK_NOT_ALLOWED$1 = "";
  var BREAK_ALLOWED$1 = "";
  var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
  var ALPHABETICS = [AL, HL];
  var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
  var SPACE$1 = [SP, ZW];
  var PREFIX_POSTFIX = [PR, PO];
  var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
  var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
  var HYPHEN = [HY, BA];
  var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
    if (lineBreak2 === void 0) {
      lineBreak2 = "strict";
    }
    var types = [];
    var indices = [];
    var categories = [];
    codePoints.forEach(function(codePoint, index2) {
      var classType = UnicodeTrie$1.get(codePoint);
      if (classType > LETTER_NUMBER_MODIFIER) {
        categories.push(true);
        classType -= LETTER_NUMBER_MODIFIER;
      } else {
        categories.push(false);
      }
      if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
        if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
          indices.push(index2);
          return types.push(CB);
        }
      }
      if (classType === CM || classType === ZWJ$1) {
        if (index2 === 0) {
          indices.push(index2);
          return types.push(AL);
        }
        var prev = types[index2 - 1];
        if (LINE_BREAKS.indexOf(prev) === -1) {
          indices.push(indices[index2 - 1]);
          return types.push(prev);
        }
        indices.push(index2);
        return types.push(AL);
      }
      indices.push(index2);
      if (classType === CJ) {
        return types.push(lineBreak2 === "strict" ? NS : ID);
      }
      if (classType === SA) {
        return types.push(AL);
      }
      if (classType === AI) {
        return types.push(AL);
      }
      if (classType === XX) {
        if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
          return types.push(ID);
        } else {
          return types.push(AL);
        }
      }
      types.push(classType);
    });
    return [indices, types, categories];
  };
  var isAdjacentWithSpaceIgnored = function(a2, b2, currentIndex, classTypes) {
    var current = classTypes[currentIndex];
    if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
      var i2 = currentIndex;
      while (i2 <= classTypes.length) {
        i2++;
        var next = classTypes[i2];
        if (next === b2) {
          return true;
        }
        if (next !== SP) {
          break;
        }
      }
    }
    if (current === SP) {
      var i2 = currentIndex;
      while (i2 > 0) {
        i2--;
        var prev = classTypes[i2];
        if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
          var n2 = currentIndex;
          while (n2 <= classTypes.length) {
            n2++;
            var next = classTypes[n2];
            if (next === b2) {
              return true;
            }
            if (next !== SP) {
              break;
            }
          }
        }
        if (prev !== SP) {
          break;
        }
      }
    }
    return false;
  };
  var previousNonSpaceClassType = function(currentIndex, classTypes) {
    var i2 = currentIndex;
    while (i2 >= 0) {
      var type = classTypes[i2];
      if (type === SP) {
        i2--;
      } else {
        return type;
      }
    }
    return 0;
  };
  var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
    if (indicies[index2] === 0) {
      return BREAK_NOT_ALLOWED$1;
    }
    var currentIndex = index2 - 1;
    if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
      return BREAK_NOT_ALLOWED$1;
    }
    var beforeIndex = currentIndex - 1;
    var afterIndex = currentIndex + 1;
    var current = classTypes[currentIndex];
    var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
    var next = classTypes[afterIndex];
    if (current === CR$1 && next === LF$1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
      return BREAK_MANDATORY;
    }
    if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (SPACE$1.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
      return BREAK_ALLOWED$1;
    }
    if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === WJ || next === WJ) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === GL) {
      return BREAK_NOT_ALLOWED$1;
    }
    if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
      return BREAK_NOT_ALLOWED$1;
    }
    if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === SP) {
      return BREAK_ALLOWED$1;
    }
    if (current === QU || next === QU) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (next === CB || current === CB) {
      return BREAK_ALLOWED$1;
    }
    if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (before === HL && HYPHEN.indexOf(current) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === SY && next === HL) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (next === IN) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (
      // (PR | PO)  ( OP | HY )? NU
      [PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || // ( OP | HY )  NU
      [OP, HY].indexOf(current) !== -1 && next === NU || // NU 	(NU | SY | IS)
      current === NU && [NU, SY, IS].indexOf(next) !== -1
    ) {
      return BREAK_NOT_ALLOWED$1;
    }
    if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
      var prevIndex = currentIndex;
      while (prevIndex >= 0) {
        var type = classTypes[prevIndex];
        if (type === NU) {
          return BREAK_NOT_ALLOWED$1;
        } else if ([SY, IS].indexOf(type) !== -1) {
          prevIndex--;
        } else {
          break;
        }
      }
    }
    if ([PR, PO].indexOf(next) !== -1) {
      var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
      while (prevIndex >= 0) {
        var type = classTypes[prevIndex];
        if (type === NU) {
          return BREAK_NOT_ALLOWED$1;
        } else if ([SY, IS].indexOf(type) !== -1) {
          prevIndex--;
        } else {
          break;
        }
      }
    }
    if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
      return BREAK_NOT_ALLOWED$1;
    }
    if (current === RI$1 && next === RI$1) {
      var i2 = indicies[currentIndex];
      var count = 1;
      while (i2 > 0) {
        i2--;
        if (classTypes[i2] === RI$1) {
          count++;
        } else {
          break;
        }
      }
      if (count % 2 !== 0) {
        return BREAK_NOT_ALLOWED$1;
      }
    }
    if (current === EB && next === EM) {
      return BREAK_NOT_ALLOWED$1;
    }
    return BREAK_ALLOWED$1;
  };
  var cssFormattedClasses = function(codePoints, options) {
    if (!options) {
      options = { lineBreak: "normal", wordBreak: "normal" };
    }
    var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
    if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
      classTypes = classTypes.map(function(type) {
        return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
      });
    }
    var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i2) {
      return letterNumber && codePoints[i2] >= 19968 && codePoints[i2] <= 40959;
    }) : void 0;
    return [indicies, classTypes, forbiddenBreakpoints];
  };
  var Break = (
    /** @class */
    (function() {
      function Break2(codePoints, lineBreak2, start, end) {
        this.codePoints = codePoints;
        this.required = lineBreak2 === BREAK_MANDATORY;
        this.start = start;
        this.end = end;
      }
      Break2.prototype.slice = function() {
        return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
      };
      return Break2;
    })()
  );
  var LineBreaker = function(str, options) {
    var codePoints = toCodePoints$1(str);
    var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
    var length = codePoints.length;
    var lastEnd = 0;
    var nextIndex = 0;
    return {
      next: function() {
        if (nextIndex >= length) {
          return { done: true, value: null };
        }
        var lineBreak2 = BREAK_NOT_ALLOWED$1;
        while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
        }
        if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
          var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
          lastEnd = nextIndex;
          return { value, done: false };
        }
        return { done: true, value: null };
      }
    };
  };
  var FLAG_UNRESTRICTED = 1 << 0;
  var FLAG_ID = 1 << 1;
  var FLAG_INTEGER = 1 << 2;
  var FLAG_NUMBER = 1 << 3;
  var LINE_FEED = 10;
  var SOLIDUS = 47;
  var REVERSE_SOLIDUS = 92;
  var CHARACTER_TABULATION = 9;
  var SPACE = 32;
  var QUOTATION_MARK = 34;
  var EQUALS_SIGN = 61;
  var NUMBER_SIGN = 35;
  var DOLLAR_SIGN = 36;
  var PERCENTAGE_SIGN = 37;
  var APOSTROPHE = 39;
  var LEFT_PARENTHESIS = 40;
  var RIGHT_PARENTHESIS = 41;
  var LOW_LINE = 95;
  var HYPHEN_MINUS = 45;
  var EXCLAMATION_MARK = 33;
  var LESS_THAN_SIGN = 60;
  var GREATER_THAN_SIGN = 62;
  var COMMERCIAL_AT = 64;
  var LEFT_SQUARE_BRACKET = 91;
  var RIGHT_SQUARE_BRACKET = 93;
  var CIRCUMFLEX_ACCENT = 61;
  var LEFT_CURLY_BRACKET = 123;
  var QUESTION_MARK = 63;
  var RIGHT_CURLY_BRACKET = 125;
  var VERTICAL_LINE = 124;
  var TILDE = 126;
  var CONTROL = 128;
  var REPLACEMENT_CHARACTER = 65533;
  var ASTERISK = 42;
  var PLUS_SIGN = 43;
  var COMMA = 44;
  var COLON = 58;
  var SEMICOLON = 59;
  var FULL_STOP = 46;
  var NULL = 0;
  var BACKSPACE = 8;
  var LINE_TABULATION = 11;
  var SHIFT_OUT = 14;
  var INFORMATION_SEPARATOR_ONE = 31;
  var DELETE = 127;
  var EOF = -1;
  var ZERO = 48;
  var a$1 = 97;
  var e$1 = 101;
  var f$1 = 102;
  var u$1 = 117;
  var z = 122;
  var A = 65;
  var E = 69;
  var F = 70;
  var U = 85;
  var Z = 90;
  var isDigit = function(codePoint) {
    return codePoint >= ZERO && codePoint <= 57;
  };
  var isSurrogateCodePoint = function(codePoint) {
    return codePoint >= 55296 && codePoint <= 57343;
  };
  var isHex = function(codePoint) {
    return isDigit(codePoint) || codePoint >= A && codePoint <= F || codePoint >= a$1 && codePoint <= f$1;
  };
  var isLowerCaseLetter = function(codePoint) {
    return codePoint >= a$1 && codePoint <= z;
  };
  var isUpperCaseLetter = function(codePoint) {
    return codePoint >= A && codePoint <= Z;
  };
  var isLetter = function(codePoint) {
    return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
  };
  var isNonASCIICodePoint = function(codePoint) {
    return codePoint >= CONTROL;
  };
  var isWhiteSpace = function(codePoint) {
    return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
  };
  var isNameStartCodePoint = function(codePoint) {
    return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
  };
  var isNameCodePoint = function(codePoint) {
    return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
  };
  var isNonPrintableCodePoint = function(codePoint) {
    return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
  };
  var isValidEscape = function(c1, c2) {
    if (c1 !== REVERSE_SOLIDUS) {
      return false;
    }
    return c2 !== LINE_FEED;
  };
  var isIdentifierStart = function(c1, c2, c3) {
    if (c1 === HYPHEN_MINUS) {
      return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
    } else if (isNameStartCodePoint(c1)) {
      return true;
    } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
      return true;
    }
    return false;
  };
  var isNumberStart = function(c1, c2, c3) {
    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
      if (isDigit(c2)) {
        return true;
      }
      return c2 === FULL_STOP && isDigit(c3);
    }
    if (c1 === FULL_STOP) {
      return isDigit(c2);
    }
    return isDigit(c1);
  };
  var stringToNumber = function(codePoints) {
    var c2 = 0;
    var sign = 1;
    if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
      if (codePoints[c2] === HYPHEN_MINUS) {
        sign = -1;
      }
      c2++;
    }
    var integers = [];
    while (isDigit(codePoints[c2])) {
      integers.push(codePoints[c2++]);
    }
    var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
    if (codePoints[c2] === FULL_STOP) {
      c2++;
    }
    var fraction = [];
    while (isDigit(codePoints[c2])) {
      fraction.push(codePoints[c2++]);
    }
    var fracd = fraction.length;
    var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
    if (codePoints[c2] === E || codePoints[c2] === e$1) {
      c2++;
    }
    var expsign = 1;
    if (codePoints[c2] === PLUS_SIGN || codePoints[c2] === HYPHEN_MINUS) {
      if (codePoints[c2] === HYPHEN_MINUS) {
        expsign = -1;
      }
      c2++;
    }
    var exponent = [];
    while (isDigit(codePoints[c2])) {
      exponent.push(codePoints[c2++]);
    }
    var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
    return sign * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
  };
  var LEFT_PARENTHESIS_TOKEN = {
    type: 2
    /* LEFT_PARENTHESIS_TOKEN */
  };
  var RIGHT_PARENTHESIS_TOKEN = {
    type: 3
    /* RIGHT_PARENTHESIS_TOKEN */
  };
  var COMMA_TOKEN = {
    type: 4
    /* COMMA_TOKEN */
  };
  var SUFFIX_MATCH_TOKEN = {
    type: 13
    /* SUFFIX_MATCH_TOKEN */
  };
  var PREFIX_MATCH_TOKEN = {
    type: 8
    /* PREFIX_MATCH_TOKEN */
  };
  var COLUMN_TOKEN = {
    type: 21
    /* COLUMN_TOKEN */
  };
  var DASH_MATCH_TOKEN = {
    type: 9
    /* DASH_MATCH_TOKEN */
  };
  var INCLUDE_MATCH_TOKEN = {
    type: 10
    /* INCLUDE_MATCH_TOKEN */
  };
  var LEFT_CURLY_BRACKET_TOKEN = {
    type: 11
    /* LEFT_CURLY_BRACKET_TOKEN */
  };
  var RIGHT_CURLY_BRACKET_TOKEN = {
    type: 12
    /* RIGHT_CURLY_BRACKET_TOKEN */
  };
  var SUBSTRING_MATCH_TOKEN = {
    type: 14
    /* SUBSTRING_MATCH_TOKEN */
  };
  var BAD_URL_TOKEN = {
    type: 23
    /* BAD_URL_TOKEN */
  };
  var BAD_STRING_TOKEN = {
    type: 1
    /* BAD_STRING_TOKEN */
  };
  var CDO_TOKEN = {
    type: 25
    /* CDO_TOKEN */
  };
  var CDC_TOKEN = {
    type: 24
    /* CDC_TOKEN */
  };
  var COLON_TOKEN = {
    type: 26
    /* COLON_TOKEN */
  };
  var SEMICOLON_TOKEN = {
    type: 27
    /* SEMICOLON_TOKEN */
  };
  var LEFT_SQUARE_BRACKET_TOKEN = {
    type: 28
    /* LEFT_SQUARE_BRACKET_TOKEN */
  };
  var RIGHT_SQUARE_BRACKET_TOKEN = {
    type: 29
    /* RIGHT_SQUARE_BRACKET_TOKEN */
  };
  var WHITESPACE_TOKEN = {
    type: 31
    /* WHITESPACE_TOKEN */
  };
  var EOF_TOKEN = {
    type: 32
    /* EOF_TOKEN */
  };
  var Tokenizer = (
    /** @class */
    (function() {
      function Tokenizer2() {
        this._value = [];
      }
      Tokenizer2.prototype.write = function(chunk) {
        this._value = this._value.concat(toCodePoints$1(chunk));
      };
      Tokenizer2.prototype.read = function() {
        var tokens = [];
        var token = this.consumeToken();
        while (token !== EOF_TOKEN) {
          tokens.push(token);
          token = this.consumeToken();
        }
        return tokens;
      };
      Tokenizer2.prototype.consumeToken = function() {
        var codePoint = this.consumeCodePoint();
        switch (codePoint) {
          case QUOTATION_MARK:
            return this.consumeStringToken(QUOTATION_MARK);
          case NUMBER_SIGN:
            var c1 = this.peekCodePoint(0);
            var c2 = this.peekCodePoint(1);
            var c3 = this.peekCodePoint(2);
            if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
              var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
              var value = this.consumeName();
              return { type: 5, value, flags };
            }
            break;
          case DOLLAR_SIGN:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUFFIX_MATCH_TOKEN;
            }
            break;
          case APOSTROPHE:
            return this.consumeStringToken(APOSTROPHE);
          case LEFT_PARENTHESIS:
            return LEFT_PARENTHESIS_TOKEN;
          case RIGHT_PARENTHESIS:
            return RIGHT_PARENTHESIS_TOKEN;
          case ASTERISK:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return SUBSTRING_MATCH_TOKEN;
            }
            break;
          case PLUS_SIGN:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case COMMA:
            return COMMA_TOKEN;
          case HYPHEN_MINUS:
            var e1 = codePoint;
            var e2 = this.peekCodePoint(0);
            var e3 = this.peekCodePoint(1);
            if (isNumberStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            if (isIdentifierStart(e1, e2, e3)) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDC_TOKEN;
            }
            break;
          case FULL_STOP:
            if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeNumericToken();
            }
            break;
          case SOLIDUS:
            if (this.peekCodePoint(0) === ASTERISK) {
              this.consumeCodePoint();
              while (true) {
                var c4 = this.consumeCodePoint();
                if (c4 === ASTERISK) {
                  c4 = this.consumeCodePoint();
                  if (c4 === SOLIDUS) {
                    return this.consumeToken();
                  }
                }
                if (c4 === EOF) {
                  return this.consumeToken();
                }
              }
            }
            break;
          case COLON:
            return COLON_TOKEN;
          case SEMICOLON:
            return SEMICOLON_TOKEN;
          case LESS_THAN_SIGN:
            if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
              this.consumeCodePoint();
              this.consumeCodePoint();
              return CDO_TOKEN;
            }
            break;
          case COMMERCIAL_AT:
            var a1 = this.peekCodePoint(0);
            var a2 = this.peekCodePoint(1);
            var a3 = this.peekCodePoint(2);
            if (isIdentifierStart(a1, a2, a3)) {
              var value = this.consumeName();
              return { type: 7, value };
            }
            break;
          case LEFT_SQUARE_BRACKET:
            return LEFT_SQUARE_BRACKET_TOKEN;
          case REVERSE_SOLIDUS:
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              this.reconsumeCodePoint(codePoint);
              return this.consumeIdentLikeToken();
            }
            break;
          case RIGHT_SQUARE_BRACKET:
            return RIGHT_SQUARE_BRACKET_TOKEN;
          case CIRCUMFLEX_ACCENT:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return PREFIX_MATCH_TOKEN;
            }
            break;
          case LEFT_CURLY_BRACKET:
            return LEFT_CURLY_BRACKET_TOKEN;
          case RIGHT_CURLY_BRACKET:
            return RIGHT_CURLY_BRACKET_TOKEN;
          case u$1:
          case U:
            var u1 = this.peekCodePoint(0);
            var u2 = this.peekCodePoint(1);
            if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
              this.consumeCodePoint();
              this.consumeUnicodeRangeToken();
            }
            this.reconsumeCodePoint(codePoint);
            return this.consumeIdentLikeToken();
          case VERTICAL_LINE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return DASH_MATCH_TOKEN;
            }
            if (this.peekCodePoint(0) === VERTICAL_LINE) {
              this.consumeCodePoint();
              return COLUMN_TOKEN;
            }
            break;
          case TILDE:
            if (this.peekCodePoint(0) === EQUALS_SIGN) {
              this.consumeCodePoint();
              return INCLUDE_MATCH_TOKEN;
            }
            break;
          case EOF:
            return EOF_TOKEN;
        }
        if (isWhiteSpace(codePoint)) {
          this.consumeWhiteSpace();
          return WHITESPACE_TOKEN;
        }
        if (isDigit(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isNameStartCodePoint(codePoint)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        return { type: 6, value: fromCodePoint$1(codePoint) };
      };
      Tokenizer2.prototype.consumeCodePoint = function() {
        var value = this._value.shift();
        return typeof value === "undefined" ? -1 : value;
      };
      Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
        this._value.unshift(codePoint);
      };
      Tokenizer2.prototype.peekCodePoint = function(delta) {
        if (delta >= this._value.length) {
          return -1;
        }
        return this._value[delta];
      };
      Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
        var digits = [];
        var codePoint = this.consumeCodePoint();
        while (isHex(codePoint) && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
        }
        var questionMarks = false;
        while (codePoint === QUESTION_MARK && digits.length < 6) {
          digits.push(codePoint);
          codePoint = this.consumeCodePoint();
          questionMarks = true;
        }
        if (questionMarks) {
          var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
            return digit === QUESTION_MARK ? ZERO : digit;
          })), 16);
          var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
            return digit === QUESTION_MARK ? F : digit;
          })), 16);
          return { type: 30, start: start_1, end };
        }
        var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
        if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
          this.consumeCodePoint();
          codePoint = this.consumeCodePoint();
          var endDigits = [];
          while (isHex(codePoint) && endDigits.length < 6) {
            endDigits.push(codePoint);
            codePoint = this.consumeCodePoint();
          }
          var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
          return { type: 30, start, end };
        } else {
          return { type: 30, start, end: start };
        }
      };
      Tokenizer2.prototype.consumeIdentLikeToken = function() {
        var value = this.consumeName();
        if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return this.consumeUrlToken();
        } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 19, value };
        }
        return { type: 20, value };
      };
      Tokenizer2.prototype.consumeUrlToken = function() {
        var value = [];
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF) {
          return { type: 22, value: "" };
        }
        var next = this.peekCodePoint(0);
        if (next === APOSTROPHE || next === QUOTATION_MARK) {
          var stringToken = this.consumeStringToken(this.consumeCodePoint());
          if (stringToken.type === 0) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: stringToken.value };
            }
          }
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
            return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
          } else if (isWhiteSpace(codePoint)) {
            this.consumeWhiteSpace();
            if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
              this.consumeCodePoint();
              return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
            }
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
            this.consumeBadUrlRemnants();
            return BAD_URL_TOKEN;
          } else if (codePoint === REVERSE_SOLIDUS) {
            if (isValidEscape(codePoint, this.peekCodePoint(0))) {
              value.push(this.consumeEscapedCodePoint());
            } else {
              this.consumeBadUrlRemnants();
              return BAD_URL_TOKEN;
            }
          } else {
            value.push(codePoint);
          }
        }
      };
      Tokenizer2.prototype.consumeWhiteSpace = function() {
        while (isWhiteSpace(this.peekCodePoint(0))) {
          this.consumeCodePoint();
        }
      };
      Tokenizer2.prototype.consumeBadUrlRemnants = function() {
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
            return;
          }
          if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            this.consumeEscapedCodePoint();
          }
        }
      };
      Tokenizer2.prototype.consumeStringSlice = function(count) {
        var SLICE_STACK_SIZE = 5e4;
        var value = "";
        while (count > 0) {
          var amount = Math.min(SLICE_STACK_SIZE, count);
          value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
          count -= amount;
        }
        this._value.shift();
        return value;
      };
      Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
        var value = "";
        var i2 = 0;
        do {
          var codePoint = this._value[i2];
          if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
            value += this.consumeStringSlice(i2);
            return { type: 0, value };
          }
          if (codePoint === LINE_FEED) {
            this._value.splice(0, i2);
            return BAD_STRING_TOKEN;
          }
          if (codePoint === REVERSE_SOLIDUS) {
            var next = this._value[i2 + 1];
            if (next !== EOF && next !== void 0) {
              if (next === LINE_FEED) {
                value += this.consumeStringSlice(i2);
                i2 = -1;
                this._value.shift();
              } else if (isValidEscape(codePoint, next)) {
                value += this.consumeStringSlice(i2);
                value += fromCodePoint$1(this.consumeEscapedCodePoint());
                i2 = -1;
              }
            }
          }
          i2++;
        } while (true);
      };
      Tokenizer2.prototype.consumeNumber = function() {
        var repr = [];
        var type = FLAG_INTEGER;
        var c1 = this.peekCodePoint(0);
        if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
          repr.push(this.consumeCodePoint());
        }
        while (isDigit(this.peekCodePoint(0))) {
          repr.push(this.consumeCodePoint());
        }
        c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        if (c1 === FULL_STOP && isDigit(c2)) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        c1 = this.peekCodePoint(0);
        c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if ((c1 === E || c1 === e$1) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
          repr.push(this.consumeCodePoint(), this.consumeCodePoint());
          type = FLAG_NUMBER;
          while (isDigit(this.peekCodePoint(0))) {
            repr.push(this.consumeCodePoint());
          }
        }
        return [stringToNumber(repr), type];
      };
      Tokenizer2.prototype.consumeNumericToken = function() {
        var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isIdentifierStart(c1, c2, c3)) {
          var unit = this.consumeName();
          return { type: 15, number, flags, unit };
        }
        if (c1 === PERCENTAGE_SIGN) {
          this.consumeCodePoint();
          return { type: 16, number, flags };
        }
        return { type: 17, number, flags };
      };
      Tokenizer2.prototype.consumeEscapedCodePoint = function() {
        var codePoint = this.consumeCodePoint();
        if (isHex(codePoint)) {
          var hex = fromCodePoint$1(codePoint);
          while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
            hex += fromCodePoint$1(this.consumeCodePoint());
          }
          if (isWhiteSpace(this.peekCodePoint(0))) {
            this.consumeCodePoint();
          }
          var hexCodePoint = parseInt(hex, 16);
          if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
            return REPLACEMENT_CHARACTER;
          }
          return hexCodePoint;
        }
        if (codePoint === EOF) {
          return REPLACEMENT_CHARACTER;
        }
        return codePoint;
      };
      Tokenizer2.prototype.consumeName = function() {
        var result = "";
        while (true) {
          var codePoint = this.consumeCodePoint();
          if (isNameCodePoint(codePoint)) {
            result += fromCodePoint$1(codePoint);
          } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
            result += fromCodePoint$1(this.consumeEscapedCodePoint());
          } else {
            this.reconsumeCodePoint(codePoint);
            return result;
          }
        }
      };
      return Tokenizer2;
    })()
  );
  var Parser$1 = (
    /** @class */
    (function() {
      function Parser2(tokens) {
        this._tokens = tokens;
      }
      Parser2.create = function(value) {
        var tokenizer = new Tokenizer();
        tokenizer.write(value);
        return new Parser2(tokenizer.read());
      };
      Parser2.parseValue = function(value) {
        return Parser2.create(value).parseComponentValue();
      };
      Parser2.parseValues = function(value) {
        return Parser2.create(value).parseComponentValues();
      };
      Parser2.prototype.parseComponentValue = function() {
        var token = this.consumeToken();
        while (token.type === 31) {
          token = this.consumeToken();
        }
        if (token.type === 32) {
          throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
        }
        this.reconsumeToken(token);
        var value = this.consumeComponentValue();
        do {
          token = this.consumeToken();
        } while (token.type === 31);
        if (token.type === 32) {
          return value;
        }
        throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
      };
      Parser2.prototype.parseComponentValues = function() {
        var values = [];
        while (true) {
          var value = this.consumeComponentValue();
          if (value.type === 32) {
            return values;
          }
          values.push(value);
          values.push();
        }
      };
      Parser2.prototype.consumeComponentValue = function() {
        var token = this.consumeToken();
        switch (token.type) {
          case 11:
          case 28:
          case 2:
            return this.consumeSimpleBlock(token.type);
          case 19:
            return this.consumeFunction(token);
        }
        return token;
      };
      Parser2.prototype.consumeSimpleBlock = function(type) {
        var block = { type, values: [] };
        var token = this.consumeToken();
        while (true) {
          if (token.type === 32 || isEndingTokenFor(token, type)) {
            return block;
          }
          this.reconsumeToken(token);
          block.values.push(this.consumeComponentValue());
          token = this.consumeToken();
        }
      };
      Parser2.prototype.consumeFunction = function(functionToken) {
        var cssFunction = {
          name: functionToken.value,
          values: [],
          type: 18
          /* FUNCTION */
        };
        while (true) {
          var token = this.consumeToken();
          if (token.type === 32 || token.type === 3) {
            return cssFunction;
          }
          this.reconsumeToken(token);
          cssFunction.values.push(this.consumeComponentValue());
        }
      };
      Parser2.prototype.consumeToken = function() {
        var token = this._tokens.shift();
        return typeof token === "undefined" ? EOF_TOKEN : token;
      };
      Parser2.prototype.reconsumeToken = function(token) {
        this._tokens.unshift(token);
      };
      return Parser2;
    })()
  );
  var isDimensionToken = function(token) {
    return token.type === 15;
  };
  var isNumberToken = function(token) {
    return token.type === 17;
  };
  var isIdentToken = function(token) {
    return token.type === 20;
  };
  var isStringToken = function(token) {
    return token.type === 0;
  };
  var isIdentWithValue = function(token, value) {
    return isIdentToken(token) && token.value === value;
  };
  var nonWhiteSpace = function(token) {
    return token.type !== 31;
  };
  var nonFunctionArgSeparator = function(token) {
    return token.type !== 31 && token.type !== 4;
  };
  var parseFunctionArgs = function(tokens) {
    var args = [];
    var arg = [];
    tokens.forEach(function(token) {
      if (token.type === 4) {
        if (arg.length === 0) {
          throw new Error("Error parsing function args, zero tokens for arg");
        }
        args.push(arg);
        arg = [];
        return;
      }
      if (token.type !== 31) {
        arg.push(token);
      }
    });
    if (arg.length) {
      args.push(arg);
    }
    return args;
  };
  var isEndingTokenFor = function(token, type) {
    if (type === 11 && token.type === 12) {
      return true;
    }
    if (type === 28 && token.type === 29) {
      return true;
    }
    return type === 2 && token.type === 3;
  };
  var isLength = function(token) {
    return token.type === 17 || token.type === 15;
  };
  var isLengthPercentage = function(token) {
    return token.type === 16 || isLength(token);
  };
  var parseLengthPercentageTuple = function(tokens) {
    return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
  };
  var ZERO_LENGTH = {
    type: 17,
    number: 0,
    flags: FLAG_INTEGER
  };
  var FIFTY_PERCENT = {
    type: 16,
    number: 50,
    flags: FLAG_INTEGER
  };
  var HUNDRED_PERCENT = {
    type: 16,
    number: 100,
    flags: FLAG_INTEGER
  };
  var getAbsoluteValueForTuple = function(tuple, width, height) {
    var x2 = tuple[0], y2 = tuple[1];
    return [getAbsoluteValue(x2, width), getAbsoluteValue(typeof y2 !== "undefined" ? y2 : x2, height)];
  };
  var getAbsoluteValue = function(token, parent) {
    if (token.type === 16) {
      return token.number / 100 * parent;
    }
    if (isDimensionToken(token)) {
      switch (token.unit) {
        case "rem":
        case "em":
          return 16 * token.number;
        // TODO use correct font-size
        case "px":
        default:
          return token.number;
      }
    }
    return token.number;
  };
  var DEG = "deg";
  var GRAD = "grad";
  var RAD = "rad";
  var TURN = "turn";
  var angle = {
    name: "angle",
    parse: function(_context, value) {
      if (value.type === 15) {
        switch (value.unit) {
          case DEG:
            return Math.PI * value.number / 180;
          case GRAD:
            return Math.PI / 200 * value.number;
          case RAD:
            return value.number;
          case TURN:
            return Math.PI * 2 * value.number;
        }
      }
      throw new Error("Unsupported angle type");
    }
  };
  var isAngle = function(value) {
    if (value.type === 15) {
      if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
        return true;
      }
    }
    return false;
  };
  var parseNamedSide = function(tokens) {
    var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
      return ident.value;
    }).join(" ");
    switch (sideOrCorner) {
      case "to bottom right":
      case "to right bottom":
      case "left top":
      case "top left":
        return [ZERO_LENGTH, ZERO_LENGTH];
      case "to top":
      case "bottom":
        return deg(0);
      case "to bottom left":
      case "to left bottom":
      case "right top":
      case "top right":
        return [ZERO_LENGTH, HUNDRED_PERCENT];
      case "to right":
      case "left":
        return deg(90);
      case "to top left":
      case "to left top":
      case "right bottom":
      case "bottom right":
        return [HUNDRED_PERCENT, HUNDRED_PERCENT];
      case "to bottom":
      case "top":
        return deg(180);
      case "to top right":
      case "to right top":
      case "left bottom":
      case "bottom left":
        return [HUNDRED_PERCENT, ZERO_LENGTH];
      case "to left":
      case "right":
        return deg(270);
    }
    return 0;
  };
  var deg = function(deg2) {
    return Math.PI * deg2 / 180;
  };
  var color$1 = {
    name: "color",
    parse: function(context, value) {
      if (value.type === 18) {
        var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
        if (typeof colorFunction === "undefined") {
          throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
        }
        return colorFunction(context, value.values);
      }
      if (value.type === 5) {
        if (value.value.length === 3) {
          var r2 = value.value.substring(0, 1);
          var g2 = value.value.substring(1, 2);
          var b2 = value.value.substring(2, 3);
          return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), 1);
        }
        if (value.value.length === 4) {
          var r2 = value.value.substring(0, 1);
          var g2 = value.value.substring(1, 2);
          var b2 = value.value.substring(2, 3);
          var a2 = value.value.substring(3, 4);
          return pack(parseInt(r2 + r2, 16), parseInt(g2 + g2, 16), parseInt(b2 + b2, 16), parseInt(a2 + a2, 16) / 255);
        }
        if (value.value.length === 6) {
          var r2 = value.value.substring(0, 2);
          var g2 = value.value.substring(2, 4);
          var b2 = value.value.substring(4, 6);
          return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), 1);
        }
        if (value.value.length === 8) {
          var r2 = value.value.substring(0, 2);
          var g2 = value.value.substring(2, 4);
          var b2 = value.value.substring(4, 6);
          var a2 = value.value.substring(6, 8);
          return pack(parseInt(r2, 16), parseInt(g2, 16), parseInt(b2, 16), parseInt(a2, 16) / 255);
        }
      }
      if (value.type === 20) {
        var namedColor = COLORS[value.value.toUpperCase()];
        if (typeof namedColor !== "undefined") {
          return namedColor;
        }
      }
      return COLORS.TRANSPARENT;
    }
  };
  var isTransparent = function(color2) {
    return (255 & color2) === 0;
  };
  var asString = function(color2) {
    var alpha = 255 & color2;
    var blue = 255 & color2 >> 8;
    var green = 255 & color2 >> 16;
    var red = 255 & color2 >> 24;
    return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
  };
  var pack = function(r2, g2, b2, a2) {
    return (r2 << 24 | g2 << 16 | b2 << 8 | Math.round(a2 * 255) << 0) >>> 0;
  };
  var getTokenColorValue = function(token, i2) {
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 16) {
      var max = i2 === 3 ? 1 : 255;
      return i2 === 3 ? token.number / 100 * max : Math.round(token.number / 100 * max);
    }
    return 0;
  };
  var rgb = function(_context, args) {
    var tokens = args.filter(nonFunctionArgSeparator);
    if (tokens.length === 3) {
      var _a2 = tokens.map(getTokenColorValue), r2 = _a2[0], g2 = _a2[1], b2 = _a2[2];
      return pack(r2, g2, b2, 1);
    }
    if (tokens.length === 4) {
      var _b2 = tokens.map(getTokenColorValue), r2 = _b2[0], g2 = _b2[1], b2 = _b2[2], a2 = _b2[3];
      return pack(r2, g2, b2, a2);
    }
    return 0;
  };
  function hue2rgb(t1, t2, hue) {
    if (hue < 0) {
      hue += 1;
    }
    if (hue >= 1) {
      hue -= 1;
    }
    if (hue < 1 / 6) {
      return (t2 - t1) * hue * 6 + t1;
    } else if (hue < 1 / 2) {
      return t2;
    } else if (hue < 2 / 3) {
      return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
    } else {
      return t1;
    }
  }
  var hsl = function(context, args) {
    var tokens = args.filter(nonFunctionArgSeparator);
    var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
    var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
    var s2 = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
    var l2 = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
    var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
    if (s2 === 0) {
      return pack(l2 * 255, l2 * 255, l2 * 255, 1);
    }
    var t2 = l2 <= 0.5 ? l2 * (s2 + 1) : l2 + s2 - l2 * s2;
    var t1 = l2 * 2 - t2;
    var r2 = hue2rgb(t1, t2, h2 + 1 / 3);
    var g2 = hue2rgb(t1, t2, h2);
    var b2 = hue2rgb(t1, t2, h2 - 1 / 3);
    return pack(r2 * 255, g2 * 255, b2 * 255, a2);
  };
  var SUPPORTED_COLOR_FUNCTIONS = {
    hsl,
    hsla: hsl,
    rgb,
    rgba: rgb
  };
  var parseColor = function(context, value) {
    return color$1.parse(context, Parser$1.create(value).parseComponentValue());
  };
  var COLORS = {
    ALICEBLUE: 4042850303,
    ANTIQUEWHITE: 4209760255,
    AQUA: 16777215,
    AQUAMARINE: 2147472639,
    AZURE: 4043309055,
    BEIGE: 4126530815,
    BISQUE: 4293182719,
    BLACK: 255,
    BLANCHEDALMOND: 4293643775,
    BLUE: 65535,
    BLUEVIOLET: 2318131967,
    BROWN: 2771004159,
    BURLYWOOD: 3736635391,
    CADETBLUE: 1604231423,
    CHARTREUSE: 2147418367,
    CHOCOLATE: 3530104575,
    CORAL: 4286533887,
    CORNFLOWERBLUE: 1687547391,
    CORNSILK: 4294499583,
    CRIMSON: 3692313855,
    CYAN: 16777215,
    DARKBLUE: 35839,
    DARKCYAN: 9145343,
    DARKGOLDENROD: 3095837695,
    DARKGRAY: 2846468607,
    DARKGREEN: 6553855,
    DARKGREY: 2846468607,
    DARKKHAKI: 3182914559,
    DARKMAGENTA: 2332068863,
    DARKOLIVEGREEN: 1433087999,
    DARKORANGE: 4287365375,
    DARKORCHID: 2570243327,
    DARKRED: 2332033279,
    DARKSALMON: 3918953215,
    DARKSEAGREEN: 2411499519,
    DARKSLATEBLUE: 1211993087,
    DARKSLATEGRAY: 793726975,
    DARKSLATEGREY: 793726975,
    DARKTURQUOISE: 13554175,
    DARKVIOLET: 2483082239,
    DEEPPINK: 4279538687,
    DEEPSKYBLUE: 12582911,
    DIMGRAY: 1768516095,
    DIMGREY: 1768516095,
    DODGERBLUE: 512819199,
    FIREBRICK: 2988581631,
    FLORALWHITE: 4294635775,
    FORESTGREEN: 579543807,
    FUCHSIA: 4278255615,
    GAINSBORO: 3705462015,
    GHOSTWHITE: 4177068031,
    GOLD: 4292280575,
    GOLDENROD: 3668254975,
    GRAY: 2155905279,
    GREEN: 8388863,
    GREENYELLOW: 2919182335,
    GREY: 2155905279,
    HONEYDEW: 4043305215,
    HOTPINK: 4285117695,
    INDIANRED: 3445382399,
    INDIGO: 1258324735,
    IVORY: 4294963455,
    KHAKI: 4041641215,
    LAVENDER: 3873897215,
    LAVENDERBLUSH: 4293981695,
    LAWNGREEN: 2096890111,
    LEMONCHIFFON: 4294626815,
    LIGHTBLUE: 2916673279,
    LIGHTCORAL: 4034953471,
    LIGHTCYAN: 3774873599,
    LIGHTGOLDENRODYELLOW: 4210742015,
    LIGHTGRAY: 3553874943,
    LIGHTGREEN: 2431553791,
    LIGHTGREY: 3553874943,
    LIGHTPINK: 4290167295,
    LIGHTSALMON: 4288707327,
    LIGHTSEAGREEN: 548580095,
    LIGHTSKYBLUE: 2278488831,
    LIGHTSLATEGRAY: 2005441023,
    LIGHTSLATEGREY: 2005441023,
    LIGHTSTEELBLUE: 2965692159,
    LIGHTYELLOW: 4294959359,
    LIME: 16711935,
    LIMEGREEN: 852308735,
    LINEN: 4210091775,
    MAGENTA: 4278255615,
    MAROON: 2147483903,
    MEDIUMAQUAMARINE: 1724754687,
    MEDIUMBLUE: 52735,
    MEDIUMORCHID: 3126187007,
    MEDIUMPURPLE: 2473647103,
    MEDIUMSEAGREEN: 1018393087,
    MEDIUMSLATEBLUE: 2070474495,
    MEDIUMSPRINGGREEN: 16423679,
    MEDIUMTURQUOISE: 1221709055,
    MEDIUMVIOLETRED: 3340076543,
    MIDNIGHTBLUE: 421097727,
    MINTCREAM: 4127193855,
    MISTYROSE: 4293190143,
    MOCCASIN: 4293178879,
    NAVAJOWHITE: 4292783615,
    NAVY: 33023,
    OLDLACE: 4260751103,
    OLIVE: 2155872511,
    OLIVEDRAB: 1804477439,
    ORANGE: 4289003775,
    ORANGERED: 4282712319,
    ORCHID: 3664828159,
    PALEGOLDENROD: 4008225535,
    PALEGREEN: 2566625535,
    PALETURQUOISE: 2951671551,
    PALEVIOLETRED: 3681588223,
    PAPAYAWHIP: 4293907967,
    PEACHPUFF: 4292524543,
    PERU: 3448061951,
    PINK: 4290825215,
    PLUM: 3718307327,
    POWDERBLUE: 2967529215,
    PURPLE: 2147516671,
    REBECCAPURPLE: 1714657791,
    RED: 4278190335,
    ROSYBROWN: 3163525119,
    ROYALBLUE: 1097458175,
    SADDLEBROWN: 2336560127,
    SALMON: 4202722047,
    SANDYBROWN: 4104413439,
    SEAGREEN: 780883967,
    SEASHELL: 4294307583,
    SIENNA: 2689740287,
    SILVER: 3233857791,
    SKYBLUE: 2278484991,
    SLATEBLUE: 1784335871,
    SLATEGRAY: 1887473919,
    SLATEGREY: 1887473919,
    SNOW: 4294638335,
    SPRINGGREEN: 16744447,
    STEELBLUE: 1182971135,
    TAN: 3535047935,
    TEAL: 8421631,
    THISTLE: 3636451583,
    TOMATO: 4284696575,
    TRANSPARENT: 0,
    TURQUOISE: 1088475391,
    VIOLET: 4001558271,
    WHEAT: 4125012991,
    WHITE: 4294967295,
    WHITESMOKE: 4126537215,
    YELLOW: 4294902015,
    YELLOWGREEN: 2597139199
  };
  var backgroundClip = {
    name: "background-clip",
    initialValue: "border-box",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return tokens.map(function(token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "padding-box":
              return 1;
            case "content-box":
              return 2;
          }
        }
        return 0;
      });
    }
  };
  var backgroundColor = {
    name: "background-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
  var parseColorStop = function(context, args) {
    var color2 = color$1.parse(context, args[0]);
    var stop = args[1];
    return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
  };
  var processColorStops = function(stops, lineLength) {
    var first = stops[0];
    var last = stops[stops.length - 1];
    if (first.stop === null) {
      first.stop = ZERO_LENGTH;
    }
    if (last.stop === null) {
      last.stop = HUNDRED_PERCENT;
    }
    var processStops = [];
    var previous = 0;
    for (var i2 = 0; i2 < stops.length; i2++) {
      var stop_1 = stops[i2].stop;
      if (stop_1 !== null) {
        var absoluteValue = getAbsoluteValue(stop_1, lineLength);
        if (absoluteValue > previous) {
          processStops.push(absoluteValue);
        } else {
          processStops.push(previous);
        }
        previous = absoluteValue;
      } else {
        processStops.push(null);
      }
    }
    var gapBegin = null;
    for (var i2 = 0; i2 < processStops.length; i2++) {
      var stop_2 = processStops[i2];
      if (stop_2 === null) {
        if (gapBegin === null) {
          gapBegin = i2;
        }
      } else if (gapBegin !== null) {
        var gapLength = i2 - gapBegin;
        var beforeGap = processStops[gapBegin - 1];
        var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
        for (var g2 = 1; g2 <= gapLength; g2++) {
          processStops[gapBegin + g2 - 1] = gapValue * g2;
        }
        gapBegin = null;
      }
    }
    return stops.map(function(_a2, i3) {
      var color2 = _a2.color;
      return { color: color2, stop: Math.max(Math.min(1, processStops[i3] / lineLength), 0) };
    });
  };
  var getAngleFromCorner = function(corner, width, height) {
    var centerX = width / 2;
    var centerY = height / 2;
    var x2 = getAbsoluteValue(corner[0], width) - centerX;
    var y2 = centerY - getAbsoluteValue(corner[1], height);
    return (Math.atan2(y2, x2) + Math.PI * 2) % (Math.PI * 2);
  };
  var calculateGradientDirection = function(angle2, width, height) {
    var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
    var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
    var halfWidth = width / 2;
    var halfHeight = height / 2;
    var halfLineLength = lineLength / 2;
    var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
    var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
    return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
  };
  var distance = function(a2, b2) {
    return Math.sqrt(a2 * a2 + b2 * b2);
  };
  var findCorner = function(width, height, x2, y2, closest) {
    var corners = [
      [0, 0],
      [0, height],
      [width, 0],
      [width, height]
    ];
    return corners.reduce(function(stat, corner) {
      var cx = corner[0], cy = corner[1];
      var d2 = distance(x2 - cx, y2 - cy);
      if (closest ? d2 < stat.optimumDistance : d2 > stat.optimumDistance) {
        return {
          optimumCorner: corner,
          optimumDistance: d2
        };
      }
      return stat;
    }, {
      optimumDistance: closest ? Infinity : -Infinity,
      optimumCorner: null
    }).optimumCorner;
  };
  var calculateRadius = function(gradient, x2, y2, width, height) {
    var rx = 0;
    var ry = 0;
    switch (gradient.size) {
      case 0:
        if (gradient.shape === 0) {
          rx = ry = Math.min(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
        } else if (gradient.shape === 1) {
          rx = Math.min(Math.abs(x2), Math.abs(x2 - width));
          ry = Math.min(Math.abs(y2), Math.abs(y2 - height));
        }
        break;
      case 2:
        if (gradient.shape === 0) {
          rx = ry = Math.min(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
        } else if (gradient.shape === 1) {
          var c2 = Math.min(Math.abs(y2), Math.abs(y2 - height)) / Math.min(Math.abs(x2), Math.abs(x2 - width));
          var _a2 = findCorner(width, height, x2, y2, true), cx = _a2[0], cy = _a2[1];
          rx = distance(cx - x2, (cy - y2) / c2);
          ry = c2 * rx;
        }
        break;
      case 1:
        if (gradient.shape === 0) {
          rx = ry = Math.max(Math.abs(x2), Math.abs(x2 - width), Math.abs(y2), Math.abs(y2 - height));
        } else if (gradient.shape === 1) {
          rx = Math.max(Math.abs(x2), Math.abs(x2 - width));
          ry = Math.max(Math.abs(y2), Math.abs(y2 - height));
        }
        break;
      case 3:
        if (gradient.shape === 0) {
          rx = ry = Math.max(distance(x2, y2), distance(x2, y2 - height), distance(x2 - width, y2), distance(x2 - width, y2 - height));
        } else if (gradient.shape === 1) {
          var c2 = Math.max(Math.abs(y2), Math.abs(y2 - height)) / Math.max(Math.abs(x2), Math.abs(x2 - width));
          var _b2 = findCorner(width, height, x2, y2, false), cx = _b2[0], cy = _b2[1];
          rx = distance(cx - x2, (cy - y2) / c2);
          ry = c2 * rx;
        }
        break;
    }
    if (Array.isArray(gradient.size)) {
      rx = getAbsoluteValue(gradient.size[0], width);
      ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
    }
    return [rx, ry];
  };
  var linearGradient = function(context, tokens) {
    var angle$1 = deg(180);
    var stops = [];
    parseFunctionArgs(tokens).forEach(function(arg, i2) {
      if (i2 === 0) {
        var firstToken = arg[0];
        if (firstToken.type === 20 && firstToken.value === "to") {
          angle$1 = parseNamedSide(arg);
          return;
        } else if (isAngle(firstToken)) {
          angle$1 = angle.parse(context, firstToken);
          return;
        }
      }
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    });
    return {
      angle: angle$1,
      stops,
      type: 1
      /* LINEAR_GRADIENT */
    };
  };
  var prefixLinearGradient = function(context, tokens) {
    var angle$1 = deg(180);
    var stops = [];
    parseFunctionArgs(tokens).forEach(function(arg, i2) {
      if (i2 === 0) {
        var firstToken = arg[0];
        if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
          angle$1 = parseNamedSide(arg);
          return;
        } else if (isAngle(firstToken)) {
          angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
          return;
        }
      }
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    });
    return {
      angle: angle$1,
      stops,
      type: 1
      /* LINEAR_GRADIENT */
    };
  };
  var webkitGradient = function(context, tokens) {
    var angle2 = deg(180);
    var stops = [];
    var type = 1;
    var shape = 0;
    var size = 3;
    var position2 = [];
    parseFunctionArgs(tokens).forEach(function(arg, i2) {
      var firstToken = arg[0];
      if (i2 === 0) {
        if (isIdentToken(firstToken) && firstToken.value === "linear") {
          type = 1;
          return;
        } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
          type = 2;
          return;
        }
      }
      if (firstToken.type === 18) {
        if (firstToken.name === "from") {
          var color2 = color$1.parse(context, firstToken.values[0]);
          stops.push({ stop: ZERO_LENGTH, color: color2 });
        } else if (firstToken.name === "to") {
          var color2 = color$1.parse(context, firstToken.values[0]);
          stops.push({ stop: HUNDRED_PERCENT, color: color2 });
        } else if (firstToken.name === "color-stop") {
          var values = firstToken.values.filter(nonFunctionArgSeparator);
          if (values.length === 2) {
            var color2 = color$1.parse(context, values[1]);
            var stop_1 = values[0];
            if (isNumberToken(stop_1)) {
              stops.push({
                stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
                color: color2
              });
            }
          }
        }
      }
    });
    return type === 1 ? {
      angle: (angle2 + deg(180)) % deg(360),
      stops,
      type
    } : { size, shape, stops, position: position2, type };
  };
  var CLOSEST_SIDE = "closest-side";
  var FARTHEST_SIDE = "farthest-side";
  var CLOSEST_CORNER = "closest-corner";
  var FARTHEST_CORNER = "farthest-corner";
  var CIRCLE = "circle";
  var ELLIPSE = "ellipse";
  var COVER = "cover";
  var CONTAIN = "contain";
  var radialGradient = function(context, tokens) {
    var shape = 0;
    var size = 3;
    var stops = [];
    var position2 = [];
    parseFunctionArgs(tokens).forEach(function(arg, i2) {
      var isColorStop = true;
      if (i2 === 0) {
        var isAtPosition_1 = false;
        isColorStop = arg.reduce(function(acc, token) {
          if (isAtPosition_1) {
            if (isIdentToken(token)) {
              switch (token.value) {
                case "center":
                  position2.push(FIFTY_PERCENT);
                  return acc;
                case "top":
                case "left":
                  position2.push(ZERO_LENGTH);
                  return acc;
                case "right":
                case "bottom":
                  position2.push(HUNDRED_PERCENT);
                  return acc;
              }
            } else if (isLengthPercentage(token) || isLength(token)) {
              position2.push(token);
            }
          } else if (isIdentToken(token)) {
            switch (token.value) {
              case CIRCLE:
                shape = 0;
                return false;
              case ELLIPSE:
                shape = 1;
                return false;
              case "at":
                isAtPosition_1 = true;
                return false;
              case CLOSEST_SIDE:
                size = 0;
                return false;
              case COVER:
              case FARTHEST_SIDE:
                size = 1;
                return false;
              case CONTAIN:
              case CLOSEST_CORNER:
                size = 2;
                return false;
              case FARTHEST_CORNER:
                size = 3;
                return false;
            }
          } else if (isLength(token) || isLengthPercentage(token)) {
            if (!Array.isArray(size)) {
              size = [];
            }
            size.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      }
      if (isColorStop) {
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      }
    });
    return {
      size,
      shape,
      stops,
      position: position2,
      type: 2
      /* RADIAL_GRADIENT */
    };
  };
  var prefixRadialGradient = function(context, tokens) {
    var shape = 0;
    var size = 3;
    var stops = [];
    var position2 = [];
    parseFunctionArgs(tokens).forEach(function(arg, i2) {
      var isColorStop = true;
      if (i2 === 0) {
        isColorStop = arg.reduce(function(acc, token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return false;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return false;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return false;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      } else if (i2 === 1) {
        isColorStop = arg.reduce(function(acc, token) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case CIRCLE:
                shape = 0;
                return false;
              case ELLIPSE:
                shape = 1;
                return false;
              case CONTAIN:
              case CLOSEST_SIDE:
                size = 0;
                return false;
              case FARTHEST_SIDE:
                size = 1;
                return false;
              case CLOSEST_CORNER:
                size = 2;
                return false;
              case COVER:
              case FARTHEST_CORNER:
                size = 3;
                return false;
            }
          } else if (isLength(token) || isLengthPercentage(token)) {
            if (!Array.isArray(size)) {
              size = [];
            }
            size.push(token);
            return false;
          }
          return acc;
        }, isColorStop);
      }
      if (isColorStop) {
        var colorStop = parseColorStop(context, arg);
        stops.push(colorStop);
      }
    });
    return {
      size,
      shape,
      stops,
      position: position2,
      type: 2
      /* RADIAL_GRADIENT */
    };
  };
  var isLinearGradient = function(background) {
    return background.type === 1;
  };
  var isRadialGradient = function(background) {
    return background.type === 2;
  };
  var image = {
    name: "image",
    parse: function(context, value) {
      if (value.type === 22) {
        var image_1 = {
          url: value.value,
          type: 0
          /* URL */
        };
        context.cache.addImage(value.value);
        return image_1;
      }
      if (value.type === 18) {
        var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
        if (typeof imageFunction === "undefined") {
          throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
        }
        return imageFunction(context, value.values);
      }
      throw new Error("Unsupported image type " + value.type);
    }
  };
  function isSupportedImage(value) {
    return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
  }
  var SUPPORTED_IMAGE_FUNCTIONS = {
    "linear-gradient": linearGradient,
    "-moz-linear-gradient": prefixLinearGradient,
    "-ms-linear-gradient": prefixLinearGradient,
    "-o-linear-gradient": prefixLinearGradient,
    "-webkit-linear-gradient": prefixLinearGradient,
    "radial-gradient": radialGradient,
    "-moz-radial-gradient": prefixRadialGradient,
    "-ms-radial-gradient": prefixRadialGradient,
    "-o-radial-gradient": prefixRadialGradient,
    "-webkit-radial-gradient": prefixRadialGradient,
    "-webkit-gradient": webkitGradient
  };
  var backgroundImage = {
    name: "background-image",
    initialValue: "none",
    type: 1,
    prefix: false,
    parse: function(context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var first = tokens[0];
      if (first.type === 20 && first.value === "none") {
        return [];
      }
      return tokens.filter(function(value) {
        return nonFunctionArgSeparator(value) && isSupportedImage(value);
      }).map(function(value) {
        return image.parse(context, value);
      });
    }
  };
  var backgroundOrigin = {
    name: "background-origin",
    initialValue: "border-box",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return tokens.map(function(token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "padding-box":
              return 1;
            case "content-box":
              return 2;
          }
        }
        return 0;
      });
    }
  };
  var backgroundPosition = {
    name: "background-position",
    initialValue: "0% 0%",
    type: 1,
    prefix: false,
    parse: function(_context, tokens) {
      return parseFunctionArgs(tokens).map(function(values) {
        return values.filter(isLengthPercentage);
      }).map(parseLengthPercentageTuple);
    }
  };
  var backgroundRepeat = {
    name: "background-repeat",
    initialValue: "repeat",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseFunctionArgs(tokens).map(function(values) {
        return values.filter(isIdentToken).map(function(token) {
          return token.value;
        }).join(" ");
      }).map(parseBackgroundRepeat);
    }
  };
  var parseBackgroundRepeat = function(value) {
    switch (value) {
      case "no-repeat":
        return 1;
      case "repeat-x":
      case "repeat no-repeat":
        return 2;
      case "repeat-y":
      case "no-repeat repeat":
        return 3;
      case "repeat":
      default:
        return 0;
    }
  };
  var BACKGROUND_SIZE;
  (function(BACKGROUND_SIZE2) {
    BACKGROUND_SIZE2["AUTO"] = "auto";
    BACKGROUND_SIZE2["CONTAIN"] = "contain";
    BACKGROUND_SIZE2["COVER"] = "cover";
  })(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
  var backgroundSize = {
    name: "background-size",
    initialValue: "0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseFunctionArgs(tokens).map(function(values) {
        return values.filter(isBackgroundSizeInfoToken);
      });
    }
  };
  var isBackgroundSizeInfoToken = function(value) {
    return isIdentToken(value) || isLengthPercentage(value);
  };
  var borderColorForSide = function(side) {
    return {
      name: "border-" + side + "-color",
      initialValue: "transparent",
      prefix: false,
      type: 3,
      format: "color"
    };
  };
  var borderTopColor = borderColorForSide("top");
  var borderRightColor = borderColorForSide("right");
  var borderBottomColor = borderColorForSide("bottom");
  var borderLeftColor = borderColorForSide("left");
  var borderRadiusForSide = function(side) {
    return {
      name: "border-radius-" + side,
      initialValue: "0 0",
      prefix: false,
      type: 1,
      parse: function(_context, tokens) {
        return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
      }
    };
  };
  var borderTopLeftRadius = borderRadiusForSide("top-left");
  var borderTopRightRadius = borderRadiusForSide("top-right");
  var borderBottomRightRadius = borderRadiusForSide("bottom-right");
  var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
  var borderStyleForSide = function(side) {
    return {
      name: "border-" + side + "-style",
      initialValue: "solid",
      prefix: false,
      type: 2,
      parse: function(_context, style) {
        switch (style) {
          case "none":
            return 0;
          case "dashed":
            return 2;
          case "dotted":
            return 3;
          case "double":
            return 4;
        }
        return 1;
      }
    };
  };
  var borderTopStyle = borderStyleForSide("top");
  var borderRightStyle = borderStyleForSide("right");
  var borderBottomStyle = borderStyleForSide("bottom");
  var borderLeftStyle = borderStyleForSide("left");
  var borderWidthForSide = function(side) {
    return {
      name: "border-" + side + "-width",
      initialValue: "0",
      type: 0,
      prefix: false,
      parse: function(_context, token) {
        if (isDimensionToken(token)) {
          return token.number;
        }
        return 0;
      }
    };
  };
  var borderTopWidth = borderWidthForSide("top");
  var borderRightWidth = borderWidthForSide("right");
  var borderBottomWidth = borderWidthForSide("bottom");
  var borderLeftWidth = borderWidthForSide("left");
  var color = {
    name: "color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
  var direction = {
    name: "direction",
    initialValue: "ltr",
    prefix: false,
    type: 2,
    parse: function(_context, direction2) {
      switch (direction2) {
        case "rtl":
          return 1;
        case "ltr":
        default:
          return 0;
      }
    }
  };
  var display = {
    name: "display",
    initialValue: "inline-block",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return tokens.filter(isIdentToken).reduce(
        function(bit, token) {
          return bit | parseDisplayValue(token.value);
        },
        0
        /* NONE */
      );
    }
  };
  var parseDisplayValue = function(display2) {
    switch (display2) {
      case "block":
      case "-webkit-box":
        return 2;
      case "inline":
        return 4;
      case "run-in":
        return 8;
      case "flow":
        return 16;
      case "flow-root":
        return 32;
      case "table":
        return 64;
      case "flex":
      case "-webkit-flex":
        return 128;
      case "grid":
      case "-ms-grid":
        return 256;
      case "ruby":
        return 512;
      case "subgrid":
        return 1024;
      case "list-item":
        return 2048;
      case "table-row-group":
        return 4096;
      case "table-header-group":
        return 8192;
      case "table-footer-group":
        return 16384;
      case "table-row":
        return 32768;
      case "table-cell":
        return 65536;
      case "table-column-group":
        return 131072;
      case "table-column":
        return 262144;
      case "table-caption":
        return 524288;
      case "ruby-base":
        return 1048576;
      case "ruby-text":
        return 2097152;
      case "ruby-base-container":
        return 4194304;
      case "ruby-text-container":
        return 8388608;
      case "contents":
        return 16777216;
      case "inline-block":
        return 33554432;
      case "inline-list-item":
        return 67108864;
      case "inline-table":
        return 134217728;
      case "inline-flex":
        return 268435456;
      case "inline-grid":
        return 536870912;
    }
    return 0;
  };
  var float = {
    name: "float",
    initialValue: "none",
    prefix: false,
    type: 2,
    parse: function(_context, float2) {
      switch (float2) {
        case "left":
          return 1;
        case "right":
          return 2;
        case "inline-start":
          return 3;
        case "inline-end":
          return 4;
      }
      return 0;
    }
  };
  var letterSpacing = {
    name: "letter-spacing",
    initialValue: "0",
    prefix: false,
    type: 0,
    parse: function(_context, token) {
      if (token.type === 20 && token.value === "normal") {
        return 0;
      }
      if (token.type === 17) {
        return token.number;
      }
      if (token.type === 15) {
        return token.number;
      }
      return 0;
    }
  };
  var LINE_BREAK;
  (function(LINE_BREAK2) {
    LINE_BREAK2["NORMAL"] = "normal";
    LINE_BREAK2["STRICT"] = "strict";
  })(LINE_BREAK || (LINE_BREAK = {}));
  var lineBreak = {
    name: "line-break",
    initialValue: "normal",
    prefix: false,
    type: 2,
    parse: function(_context, lineBreak2) {
      switch (lineBreak2) {
        case "strict":
          return LINE_BREAK.STRICT;
        case "normal":
        default:
          return LINE_BREAK.NORMAL;
      }
    }
  };
  var lineHeight = {
    name: "line-height",
    initialValue: "normal",
    prefix: false,
    type: 4
    /* TOKEN_VALUE */
  };
  var computeLineHeight = function(token, fontSize2) {
    if (isIdentToken(token) && token.value === "normal") {
      return 1.2 * fontSize2;
    } else if (token.type === 17) {
      return fontSize2 * token.number;
    } else if (isLengthPercentage(token)) {
      return getAbsoluteValue(token, fontSize2);
    }
    return fontSize2;
  };
  var listStyleImage = {
    name: "list-style-image",
    initialValue: "none",
    type: 0,
    prefix: false,
    parse: function(context, token) {
      if (token.type === 20 && token.value === "none") {
        return null;
      }
      return image.parse(context, token);
    }
  };
  var listStylePosition = {
    name: "list-style-position",
    initialValue: "outside",
    prefix: false,
    type: 2,
    parse: function(_context, position2) {
      switch (position2) {
        case "inside":
          return 0;
        case "outside":
        default:
          return 1;
      }
    }
  };
  var listStyleType = {
    name: "list-style-type",
    initialValue: "none",
    prefix: false,
    type: 2,
    parse: function(_context, type) {
      switch (type) {
        case "disc":
          return 0;
        case "circle":
          return 1;
        case "square":
          return 2;
        case "decimal":
          return 3;
        case "cjk-decimal":
          return 4;
        case "decimal-leading-zero":
          return 5;
        case "lower-roman":
          return 6;
        case "upper-roman":
          return 7;
        case "lower-greek":
          return 8;
        case "lower-alpha":
          return 9;
        case "upper-alpha":
          return 10;
        case "arabic-indic":
          return 11;
        case "armenian":
          return 12;
        case "bengali":
          return 13;
        case "cambodian":
          return 14;
        case "cjk-earthly-branch":
          return 15;
        case "cjk-heavenly-stem":
          return 16;
        case "cjk-ideographic":
          return 17;
        case "devanagari":
          return 18;
        case "ethiopic-numeric":
          return 19;
        case "georgian":
          return 20;
        case "gujarati":
          return 21;
        case "gurmukhi":
          return 22;
        case "hebrew":
          return 22;
        case "hiragana":
          return 23;
        case "hiragana-iroha":
          return 24;
        case "japanese-formal":
          return 25;
        case "japanese-informal":
          return 26;
        case "kannada":
          return 27;
        case "katakana":
          return 28;
        case "katakana-iroha":
          return 29;
        case "khmer":
          return 30;
        case "korean-hangul-formal":
          return 31;
        case "korean-hanja-formal":
          return 32;
        case "korean-hanja-informal":
          return 33;
        case "lao":
          return 34;
        case "lower-armenian":
          return 35;
        case "malayalam":
          return 36;
        case "mongolian":
          return 37;
        case "myanmar":
          return 38;
        case "oriya":
          return 39;
        case "persian":
          return 40;
        case "simp-chinese-formal":
          return 41;
        case "simp-chinese-informal":
          return 42;
        case "tamil":
          return 43;
        case "telugu":
          return 44;
        case "thai":
          return 45;
        case "tibetan":
          return 46;
        case "trad-chinese-formal":
          return 47;
        case "trad-chinese-informal":
          return 48;
        case "upper-armenian":
          return 49;
        case "disclosure-open":
          return 50;
        case "disclosure-closed":
          return 51;
        case "none":
        default:
          return -1;
      }
    }
  };
  var marginForSide = function(side) {
    return {
      name: "margin-" + side,
      initialValue: "0",
      prefix: false,
      type: 4
      /* TOKEN_VALUE */
    };
  };
  var marginTop = marginForSide("top");
  var marginRight = marginForSide("right");
  var marginBottom = marginForSide("bottom");
  var marginLeft = marginForSide("left");
  var overflow = {
    name: "overflow",
    initialValue: "visible",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return tokens.filter(isIdentToken).map(function(overflow2) {
        switch (overflow2.value) {
          case "hidden":
            return 1;
          case "scroll":
            return 2;
          case "clip":
            return 3;
          case "auto":
            return 4;
          case "visible":
          default:
            return 0;
        }
      });
    }
  };
  var overflowWrap = {
    name: "overflow-wrap",
    initialValue: "normal",
    prefix: false,
    type: 2,
    parse: function(_context, overflow2) {
      switch (overflow2) {
        case "break-word":
          return "break-word";
        case "normal":
        default:
          return "normal";
      }
    }
  };
  var paddingForSide = function(side) {
    return {
      name: "padding-" + side,
      initialValue: "0",
      prefix: false,
      type: 3,
      format: "length-percentage"
    };
  };
  var paddingTop = paddingForSide("top");
  var paddingRight = paddingForSide("right");
  var paddingBottom = paddingForSide("bottom");
  var paddingLeft = paddingForSide("left");
  var textAlign = {
    name: "text-align",
    initialValue: "left",
    prefix: false,
    type: 2,
    parse: function(_context, textAlign2) {
      switch (textAlign2) {
        case "right":
          return 2;
        case "center":
        case "justify":
          return 1;
        case "left":
        default:
          return 0;
      }
    }
  };
  var position = {
    name: "position",
    initialValue: "static",
    prefix: false,
    type: 2,
    parse: function(_context, position2) {
      switch (position2) {
        case "relative":
          return 1;
        case "absolute":
          return 2;
        case "fixed":
          return 3;
        case "sticky":
          return 4;
      }
      return 0;
    }
  };
  var textShadow = {
    name: "text-shadow",
    initialValue: "none",
    type: 1,
    prefix: false,
    parse: function(context, tokens) {
      if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
        return [];
      }
      return parseFunctionArgs(tokens).map(function(values) {
        var shadow = {
          color: COLORS.TRANSPARENT,
          offsetX: ZERO_LENGTH,
          offsetY: ZERO_LENGTH,
          blur: ZERO_LENGTH
        };
        var c2 = 0;
        for (var i2 = 0; i2 < values.length; i2++) {
          var token = values[i2];
          if (isLength(token)) {
            if (c2 === 0) {
              shadow.offsetX = token;
            } else if (c2 === 1) {
              shadow.offsetY = token;
            } else {
              shadow.blur = token;
            }
            c2++;
          } else {
            shadow.color = color$1.parse(context, token);
          }
        }
        return shadow;
      });
    }
  };
  var textTransform = {
    name: "text-transform",
    initialValue: "none",
    prefix: false,
    type: 2,
    parse: function(_context, textTransform2) {
      switch (textTransform2) {
        case "uppercase":
          return 2;
        case "lowercase":
          return 1;
        case "capitalize":
          return 3;
      }
      return 0;
    }
  };
  var transform$1 = {
    name: "transform",
    initialValue: "none",
    prefix: true,
    type: 0,
    parse: function(_context, token) {
      if (token.type === 20 && token.value === "none") {
        return null;
      }
      if (token.type === 18) {
        var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
        if (typeof transformFunction === "undefined") {
          throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
        }
        return transformFunction(token.values);
      }
      return null;
    }
  };
  var matrix = function(args) {
    var values = args.filter(function(arg) {
      return arg.type === 17;
    }).map(function(arg) {
      return arg.number;
    });
    return values.length === 6 ? values : null;
  };
  var matrix3d = function(args) {
    var values = args.filter(function(arg) {
      return arg.type === 17;
    }).map(function(arg) {
      return arg.number;
    });
    var a1 = values[0], b1 = values[1];
    values[2];
    values[3];
    var a2 = values[4], b2 = values[5];
    values[6];
    values[7];
    values[8];
    values[9];
    values[10];
    values[11];
    var a4 = values[12], b4 = values[13];
    values[14];
    values[15];
    return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
  };
  var SUPPORTED_TRANSFORM_FUNCTIONS = {
    matrix,
    matrix3d
  };
  var DEFAULT_VALUE = {
    type: 16,
    number: 50,
    flags: FLAG_INTEGER
  };
  var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
  var transformOrigin = {
    name: "transform-origin",
    initialValue: "50% 50%",
    prefix: true,
    type: 1,
    parse: function(_context, tokens) {
      var origins = tokens.filter(isLengthPercentage);
      if (origins.length !== 2) {
        return DEFAULT;
      }
      return [origins[0], origins[1]];
    }
  };
  var visibility = {
    name: "visible",
    initialValue: "none",
    prefix: false,
    type: 2,
    parse: function(_context, visibility2) {
      switch (visibility2) {
        case "hidden":
          return 1;
        case "collapse":
          return 2;
        case "visible":
        default:
          return 0;
      }
    }
  };
  var WORD_BREAK;
  (function(WORD_BREAK2) {
    WORD_BREAK2["NORMAL"] = "normal";
    WORD_BREAK2["BREAK_ALL"] = "break-all";
    WORD_BREAK2["KEEP_ALL"] = "keep-all";
  })(WORD_BREAK || (WORD_BREAK = {}));
  var wordBreak = {
    name: "word-break",
    initialValue: "normal",
    prefix: false,
    type: 2,
    parse: function(_context, wordBreak2) {
      switch (wordBreak2) {
        case "break-all":
          return WORD_BREAK.BREAK_ALL;
        case "keep-all":
          return WORD_BREAK.KEEP_ALL;
        case "normal":
        default:
          return WORD_BREAK.NORMAL;
      }
    }
  };
  var zIndex = {
    name: "z-index",
    initialValue: "auto",
    prefix: false,
    type: 0,
    parse: function(_context, token) {
      if (token.type === 20) {
        return { auto: true, order: 0 };
      }
      if (isNumberToken(token)) {
        return { auto: false, order: token.number };
      }
      throw new Error("Invalid z-index number parsed");
    }
  };
  var time = {
    name: "time",
    parse: function(_context, value) {
      if (value.type === 15) {
        switch (value.unit.toLowerCase()) {
          case "s":
            return 1e3 * value.number;
          case "ms":
            return value.number;
        }
      }
      throw new Error("Unsupported time type");
    }
  };
  var opacity = {
    name: "opacity",
    initialValue: "1",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isNumberToken(token)) {
        return token.number;
      }
      return 1;
    }
  };
  var textDecorationColor = {
    name: "text-decoration-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
  var textDecorationLine = {
    name: "text-decoration-line",
    initialValue: "none",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return tokens.filter(isIdentToken).map(function(token) {
        switch (token.value) {
          case "underline":
            return 1;
          case "overline":
            return 2;
          case "line-through":
            return 3;
          case "none":
            return 4;
        }
        return 0;
      }).filter(function(line) {
        return line !== 0;
      });
    }
  };
  var fontFamily = {
    name: "font-family",
    initialValue: "",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      var accumulator = [];
      var results = [];
      tokens.forEach(function(token) {
        switch (token.type) {
          case 20:
          case 0:
            accumulator.push(token.value);
            break;
          case 17:
            accumulator.push(token.number.toString());
            break;
          case 4:
            results.push(accumulator.join(" "));
            accumulator.length = 0;
            break;
        }
      });
      if (accumulator.length) {
        results.push(accumulator.join(" "));
      }
      return results.map(function(result) {
        return result.indexOf(" ") === -1 ? result : "'" + result + "'";
      });
    }
  };
  var fontSize = {
    name: "font-size",
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length"
  };
  var fontWeight = {
    name: "font-weight",
    initialValue: "normal",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isNumberToken(token)) {
        return token.number;
      }
      if (isIdentToken(token)) {
        switch (token.value) {
          case "bold":
            return 700;
          case "normal":
          default:
            return 400;
        }
      }
      return 400;
    }
  };
  var fontVariant = {
    name: "font-variant",
    initialValue: "none",
    type: 1,
    prefix: false,
    parse: function(_context, tokens) {
      return tokens.filter(isIdentToken).map(function(token) {
        return token.value;
      });
    }
  };
  var fontStyle = {
    name: "font-style",
    initialValue: "normal",
    prefix: false,
    type: 2,
    parse: function(_context, overflow2) {
      switch (overflow2) {
        case "oblique":
          return "oblique";
        case "italic":
          return "italic";
        case "normal":
        default:
          return "normal";
      }
    }
  };
  var contains = function(bit, value) {
    return (bit & value) !== 0;
  };
  var content = {
    name: "content",
    initialValue: "none",
    type: 1,
    prefix: false,
    parse: function(_context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var first = tokens[0];
      if (first.type === 20 && first.value === "none") {
        return [];
      }
      return tokens;
    }
  };
  var counterIncrement = {
    name: "counter-increment",
    initialValue: "none",
    prefix: true,
    type: 1,
    parse: function(_context, tokens) {
      if (tokens.length === 0) {
        return null;
      }
      var first = tokens[0];
      if (first.type === 20 && first.value === "none") {
        return null;
      }
      var increments = [];
      var filtered = tokens.filter(nonWhiteSpace);
      for (var i2 = 0; i2 < filtered.length; i2++) {
        var counter = filtered[i2];
        var next = filtered[i2 + 1];
        if (counter.type === 20) {
          var increment = next && isNumberToken(next) ? next.number : 1;
          increments.push({ counter: counter.value, increment });
        }
      }
      return increments;
    }
  };
  var counterReset = {
    name: "counter-reset",
    initialValue: "none",
    prefix: true,
    type: 1,
    parse: function(_context, tokens) {
      if (tokens.length === 0) {
        return [];
      }
      var resets = [];
      var filtered = tokens.filter(nonWhiteSpace);
      for (var i2 = 0; i2 < filtered.length; i2++) {
        var counter = filtered[i2];
        var next = filtered[i2 + 1];
        if (isIdentToken(counter) && counter.value !== "none") {
          var reset = next && isNumberToken(next) ? next.number : 0;
          resets.push({ counter: counter.value, reset });
        }
      }
      return resets;
    }
  };
  var duration = {
    name: "duration",
    initialValue: "0s",
    prefix: false,
    type: 1,
    parse: function(context, tokens) {
      return tokens.filter(isDimensionToken).map(function(token) {
        return time.parse(context, token);
      });
    }
  };
  var quotes = {
    name: "quotes",
    initialValue: "none",
    prefix: true,
    type: 1,
    parse: function(_context, tokens) {
      if (tokens.length === 0) {
        return null;
      }
      var first = tokens[0];
      if (first.type === 20 && first.value === "none") {
        return null;
      }
      var quotes2 = [];
      var filtered = tokens.filter(isStringToken);
      if (filtered.length % 2 !== 0) {
        return null;
      }
      for (var i2 = 0; i2 < filtered.length; i2 += 2) {
        var open_1 = filtered[i2].value;
        var close_1 = filtered[i2 + 1].value;
        quotes2.push({ open: open_1, close: close_1 });
      }
      return quotes2;
    }
  };
  var getQuote = function(quotes2, depth, open2) {
    if (!quotes2) {
      return "";
    }
    var quote = quotes2[Math.min(depth, quotes2.length - 1)];
    if (!quote) {
      return "";
    }
    return open2 ? quote.open : quote.close;
  };
  var boxShadow = {
    name: "box-shadow",
    initialValue: "none",
    type: 1,
    prefix: false,
    parse: function(context, tokens) {
      if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
        return [];
      }
      return parseFunctionArgs(tokens).map(function(values) {
        var shadow = {
          color: 255,
          offsetX: ZERO_LENGTH,
          offsetY: ZERO_LENGTH,
          blur: ZERO_LENGTH,
          spread: ZERO_LENGTH,
          inset: false
        };
        var c2 = 0;
        for (var i2 = 0; i2 < values.length; i2++) {
          var token = values[i2];
          if (isIdentWithValue(token, "inset")) {
            shadow.inset = true;
          } else if (isLength(token)) {
            if (c2 === 0) {
              shadow.offsetX = token;
            } else if (c2 === 1) {
              shadow.offsetY = token;
            } else if (c2 === 2) {
              shadow.blur = token;
            } else {
              shadow.spread = token;
            }
            c2++;
          } else {
            shadow.color = color$1.parse(context, token);
          }
        }
        return shadow;
      });
    }
  };
  var paintOrder = {
    name: "paint-order",
    initialValue: "normal",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      var DEFAULT_VALUE2 = [
        0,
        1,
        2
        /* MARKERS */
      ];
      var layers = [];
      tokens.filter(isIdentToken).forEach(function(token) {
        switch (token.value) {
          case "stroke":
            layers.push(
              1
              /* STROKE */
            );
            break;
          case "fill":
            layers.push(
              0
              /* FILL */
            );
            break;
          case "markers":
            layers.push(
              2
              /* MARKERS */
            );
            break;
        }
      });
      DEFAULT_VALUE2.forEach(function(value) {
        if (layers.indexOf(value) === -1) {
          layers.push(value);
        }
      });
      return layers;
    }
  };
  var webkitTextStrokeColor = {
    name: "-webkit-text-stroke-color",
    initialValue: "currentcolor",
    prefix: false,
    type: 3,
    format: "color"
  };
  var webkitTextStrokeWidth = {
    name: "-webkit-text-stroke-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
  var CSSParsedDeclaration = (
    /** @class */
    (function() {
      function CSSParsedDeclaration2(context, declaration) {
        var _a2, _b2;
        this.animationDuration = parse(context, duration, declaration.animationDuration);
        this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
        this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
        this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
        this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
        this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
        this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
        this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
        this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
        this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
        this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
        this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
        this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
        this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
        this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
        this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
        this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
        this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
        this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
        this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
        this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
        this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
        this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
        this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
        this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
        this.color = parse(context, color, declaration.color);
        this.direction = parse(context, direction, declaration.direction);
        this.display = parse(context, display, declaration.display);
        this.float = parse(context, float, declaration.cssFloat);
        this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
        this.fontSize = parse(context, fontSize, declaration.fontSize);
        this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
        this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
        this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
        this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
        this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
        this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
        this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
        this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
        this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
        this.marginTop = parse(context, marginTop, declaration.marginTop);
        this.marginRight = parse(context, marginRight, declaration.marginRight);
        this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
        this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
        this.opacity = parse(context, opacity, declaration.opacity);
        var overflowTuple = parse(context, overflow, declaration.overflow);
        this.overflowX = overflowTuple[0];
        this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
        this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
        this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
        this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
        this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
        this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
        this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
        this.position = parse(context, position, declaration.position);
        this.textAlign = parse(context, textAlign, declaration.textAlign);
        this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
        this.textDecorationLine = parse(context, textDecorationLine, (_b2 = declaration.textDecorationLine) !== null && _b2 !== void 0 ? _b2 : declaration.textDecoration);
        this.textShadow = parse(context, textShadow, declaration.textShadow);
        this.textTransform = parse(context, textTransform, declaration.textTransform);
        this.transform = parse(context, transform$1, declaration.transform);
        this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
        this.visibility = parse(context, visibility, declaration.visibility);
        this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
        this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
        this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
        this.zIndex = parse(context, zIndex, declaration.zIndex);
      }
      CSSParsedDeclaration2.prototype.isVisible = function() {
        return this.display > 0 && this.opacity > 0 && this.visibility === 0;
      };
      CSSParsedDeclaration2.prototype.isTransparent = function() {
        return isTransparent(this.backgroundColor);
      };
      CSSParsedDeclaration2.prototype.isTransformed = function() {
        return this.transform !== null;
      };
      CSSParsedDeclaration2.prototype.isPositioned = function() {
        return this.position !== 0;
      };
      CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
        return this.isPositioned() && !this.zIndex.auto;
      };
      CSSParsedDeclaration2.prototype.isFloating = function() {
        return this.float !== 0;
      };
      CSSParsedDeclaration2.prototype.isInlineLevel = function() {
        return contains(
          this.display,
          4
          /* INLINE */
        ) || contains(
          this.display,
          33554432
          /* INLINE_BLOCK */
        ) || contains(
          this.display,
          268435456
          /* INLINE_FLEX */
        ) || contains(
          this.display,
          536870912
          /* INLINE_GRID */
        ) || contains(
          this.display,
          67108864
          /* INLINE_LIST_ITEM */
        ) || contains(
          this.display,
          134217728
          /* INLINE_TABLE */
        );
      };
      return CSSParsedDeclaration2;
    })()
  );
  var CSSParsedPseudoDeclaration = (
    /** @class */
    /* @__PURE__ */ (function() {
      function CSSParsedPseudoDeclaration2(context, declaration) {
        this.content = parse(context, content, declaration.content);
        this.quotes = parse(context, quotes, declaration.quotes);
      }
      return CSSParsedPseudoDeclaration2;
    })()
  );
  var CSSParsedCounterDeclaration = (
    /** @class */
    /* @__PURE__ */ (function() {
      function CSSParsedCounterDeclaration2(context, declaration) {
        this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
        this.counterReset = parse(context, counterReset, declaration.counterReset);
      }
      return CSSParsedCounterDeclaration2;
    })()
  );
  var parse = function(context, descriptor, style) {
    var tokenizer = new Tokenizer();
    var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
    tokenizer.write(value);
    var parser = new Parser$1(tokenizer.read());
    switch (descriptor.type) {
      case 2:
        var token = parser.parseComponentValue();
        return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
      case 0:
        return descriptor.parse(context, parser.parseComponentValue());
      case 1:
        return descriptor.parse(context, parser.parseComponentValues());
      case 4:
        return parser.parseComponentValue();
      case 3:
        switch (descriptor.format) {
          case "angle":
            return angle.parse(context, parser.parseComponentValue());
          case "color":
            return color$1.parse(context, parser.parseComponentValue());
          case "image":
            return image.parse(context, parser.parseComponentValue());
          case "length":
            var length_1 = parser.parseComponentValue();
            return isLength(length_1) ? length_1 : ZERO_LENGTH;
          case "length-percentage":
            var value_1 = parser.parseComponentValue();
            return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
          case "time":
            return time.parse(context, parser.parseComponentValue());
        }
        break;
    }
  };
  var elementDebuggerAttribute = "data-html2canvas-debug";
  var getElementDebugType = function(element) {
    var attribute = element.getAttribute(elementDebuggerAttribute);
    switch (attribute) {
      case "all":
        return 1;
      case "clone":
        return 2;
      case "parse":
        return 3;
      case "render":
        return 4;
      default:
        return 0;
    }
  };
  var isDebugging = function(element, type) {
    var elementType = getElementDebugType(element);
    return elementType === 1 || type === elementType;
  };
  var ElementContainer = (
    /** @class */
    /* @__PURE__ */ (function() {
      function ElementContainer2(context, element) {
        this.context = context;
        this.textNodes = [];
        this.elements = [];
        this.flags = 0;
        if (isDebugging(
          element,
          3
          /* PARSE */
        )) {
          debugger;
        }
        this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
        if (isHTMLElementNode(element)) {
          if (this.styles.animationDuration.some(function(duration2) {
            return duration2 > 0;
          })) {
            element.style.animationDuration = "0s";
          }
          if (this.styles.transform !== null) {
            element.style.transform = "none";
          }
        }
        this.bounds = parseBounds(this.context, element);
        if (isDebugging(
          element,
          4
          /* RENDER */
        )) {
          this.flags |= 16;
        }
      }
      return ElementContainer2;
    })()
  );
  var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
  var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
    lookup$1[chars$1.charCodeAt(i$1)] = i$1;
  }
  var decode = function(base642) {
    var bufferLength = base642.length * 0.75, len = base642.length, i2, p2 = 0, encoded1, encoded2, encoded3, encoded4;
    if (base642[base642.length - 1] === "=") {
      bufferLength--;
      if (base642[base642.length - 2] === "=") {
        bufferLength--;
      }
    }
    var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
    var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
    for (i2 = 0; i2 < len; i2 += 4) {
      encoded1 = lookup$1[base642.charCodeAt(i2)];
      encoded2 = lookup$1[base642.charCodeAt(i2 + 1)];
      encoded3 = lookup$1[base642.charCodeAt(i2 + 2)];
      encoded4 = lookup$1[base642.charCodeAt(i2 + 3)];
      bytes[p2++] = encoded1 << 2 | encoded2 >> 4;
      bytes[p2++] = (encoded2 & 15) << 4 | encoded3 >> 2;
      bytes[p2++] = (encoded3 & 3) << 6 | encoded4 & 63;
    }
    return buffer;
  };
  var polyUint16Array = function(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i2 = 0; i2 < length; i2 += 2) {
      bytes.push(buffer[i2 + 1] << 8 | buffer[i2]);
    }
    return bytes;
  };
  var polyUint32Array = function(buffer) {
    var length = buffer.length;
    var bytes = [];
    for (var i2 = 0; i2 < length; i2 += 4) {
      bytes.push(buffer[i2 + 3] << 24 | buffer[i2 + 2] << 16 | buffer[i2 + 1] << 8 | buffer[i2]);
    }
    return bytes;
  };
  var UTRIE2_SHIFT_2 = 5;
  var UTRIE2_SHIFT_1 = 6 + 5;
  var UTRIE2_INDEX_SHIFT = 2;
  var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
  var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
  var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
  var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
  var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
  var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
  var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
  var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
  var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
  var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
  var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
  var slice16 = function(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint16Array(Array.prototype.slice.call(view, start, end));
  };
  var slice32 = function(view, start, end) {
    if (view.slice) {
      return view.slice(start, end);
    }
    return new Uint32Array(Array.prototype.slice.call(view, start, end));
  };
  var createTrieFromBase64 = function(base642, _byteLength) {
    var buffer = decode(base642);
    var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
    var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
    var headerLength = 24;
    var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
    var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
    return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
  };
  var Trie = (
    /** @class */
    (function() {
      function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
        this.initialValue = initialValue;
        this.errorValue = errorValue;
        this.highStart = highStart;
        this.highValueIndex = highValueIndex;
        this.index = index2;
        this.data = data;
      }
      Trie2.prototype.get = function(codePoint) {
        var ix;
        if (codePoint >= 0) {
          if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
            ix = this.index[codePoint >> UTRIE2_SHIFT_2];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 65535) {
            ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint < this.highStart) {
            ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
            ix = this.index[ix];
            ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
            ix = this.index[ix];
            ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
            return this.data[ix];
          }
          if (codePoint <= 1114111) {
            return this.data[this.highValueIndex];
          }
        }
        return this.errorValue;
      };
      return Trie2;
    })()
  );
  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
  for (var i$4 = 0; i$4 < chars.length; i$4++) {
    lookup[chars.charCodeAt(i$4)] = i$4;
  }
  var Prepend = 1;
  var CR = 2;
  var LF = 3;
  var Control = 4;
  var Extend = 5;
  var SpacingMark = 7;
  var L = 8;
  var V = 9;
  var T$1 = 10;
  var LV = 11;
  var LVT = 12;
  var ZWJ = 13;
  var Extended_Pictographic = 14;
  var RI = 15;
  var toCodePoints = function(str) {
    var codePoints = [];
    var i2 = 0;
    var length = str.length;
    while (i2 < length) {
      var value = str.charCodeAt(i2++);
      if (value >= 55296 && value <= 56319 && i2 < length) {
        var extra = str.charCodeAt(i2++);
        if ((extra & 64512) === 56320) {
          codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
        } else {
          codePoints.push(value);
          i2--;
        }
      } else {
        codePoints.push(value);
      }
    }
    return codePoints;
  };
  var fromCodePoint = function() {
    var codePoints = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      codePoints[_i] = arguments[_i];
    }
    if (String.fromCodePoint) {
      return String.fromCodePoint.apply(String, codePoints);
    }
    var length = codePoints.length;
    if (!length) {
      return "";
    }
    var codeUnits = [];
    var index2 = -1;
    var result = "";
    while (++index2 < length) {
      var codePoint = codePoints[index2];
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
      }
      if (index2 + 1 === length || codeUnits.length > 16384) {
        result += String.fromCharCode.apply(String, codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  };
  var UnicodeTrie = createTrieFromBase64(base64);
  var BREAK_NOT_ALLOWED = "";
  var BREAK_ALLOWED = "";
  var codePointToClass = function(codePoint) {
    return UnicodeTrie.get(codePoint);
  };
  var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
    var prevIndex = index2 - 2;
    var prev = classTypes[prevIndex];
    var current = classTypes[index2 - 1];
    var next = classTypes[index2];
    if (current === CR && next === LF) {
      return BREAK_NOT_ALLOWED;
    }
    if (current === CR || current === LF || current === Control) {
      return BREAK_ALLOWED;
    }
    if (next === CR || next === LF || next === Control) {
      return BREAK_ALLOWED;
    }
    if (current === L && [L, V, LV, LVT].indexOf(next) !== -1) {
      return BREAK_NOT_ALLOWED;
    }
    if ((current === LV || current === V) && (next === V || next === T$1)) {
      return BREAK_NOT_ALLOWED;
    }
    if ((current === LVT || current === T$1) && next === T$1) {
      return BREAK_NOT_ALLOWED;
    }
    if (next === ZWJ || next === Extend) {
      return BREAK_NOT_ALLOWED;
    }
    if (next === SpacingMark) {
      return BREAK_NOT_ALLOWED;
    }
    if (current === Prepend) {
      return BREAK_NOT_ALLOWED;
    }
    if (current === ZWJ && next === Extended_Pictographic) {
      while (prev === Extend) {
        prev = classTypes[--prevIndex];
      }
      if (prev === Extended_Pictographic) {
        return BREAK_NOT_ALLOWED;
      }
    }
    if (current === RI && next === RI) {
      var countRI = 0;
      while (prev === RI) {
        countRI++;
        prev = classTypes[--prevIndex];
      }
      if (countRI % 2 === 0) {
        return BREAK_NOT_ALLOWED;
      }
    }
    return BREAK_ALLOWED;
  };
  var GraphemeBreaker = function(str) {
    var codePoints = toCodePoints(str);
    var length = codePoints.length;
    var index2 = 0;
    var lastEnd = 0;
    var classTypes = codePoints.map(codePointToClass);
    return {
      next: function() {
        if (index2 >= length) {
          return { done: true, value: null };
        }
        var graphemeBreak = BREAK_NOT_ALLOWED;
        while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
        }
        if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
          var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
          lastEnd = index2;
          return { value, done: false };
        }
        return { done: true, value: null };
      }
    };
  };
  var splitGraphemes = function(str) {
    var breaker = GraphemeBreaker(str);
    var graphemes = [];
    var bk;
    while (!(bk = breaker.next()).done) {
      if (bk.value) {
        graphemes.push(bk.value.slice());
      }
    }
    return graphemes;
  };
  var testRangeBounds = function(document2) {
    var TEST_HEIGHT = 123;
    if (document2.createRange) {
      var range = document2.createRange();
      if (range.getBoundingClientRect) {
        var testElement = document2.createElement("boundtest");
        testElement.style.height = TEST_HEIGHT + "px";
        testElement.style.display = "block";
        document2.body.appendChild(testElement);
        range.selectNode(testElement);
        var rangeBounds = range.getBoundingClientRect();
        var rangeHeight = Math.round(rangeBounds.height);
        document2.body.removeChild(testElement);
        if (rangeHeight === TEST_HEIGHT) {
          return true;
        }
      }
    }
    return false;
  };
  var testIOSLineBreak = function(document2) {
    var testElement = document2.createElement("boundtest");
    testElement.style.width = "50px";
    testElement.style.display = "block";
    testElement.style.fontSize = "12px";
    testElement.style.letterSpacing = "0px";
    testElement.style.wordSpacing = "0px";
    document2.body.appendChild(testElement);
    var range = document2.createRange();
    testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
    var node2 = testElement.firstChild;
    var textList = toCodePoints$1(node2.data).map(function(i2) {
      return fromCodePoint$1(i2);
    });
    var offset = 0;
    var prev = {};
    var supports = textList.every(function(text2, i2) {
      range.setStart(node2, offset);
      range.setEnd(node2, offset + text2.length);
      var rect = range.getBoundingClientRect();
      offset += text2.length;
      var boundAhead = rect.x > prev.x || rect.y > prev.y;
      prev = rect;
      if (i2 === 0) {
        return true;
      }
      return boundAhead;
    });
    document2.body.removeChild(testElement);
    return supports;
  };
  var testCORS = function() {
    return typeof new Image().crossOrigin !== "undefined";
  };
  var testResponseType = function() {
    return typeof new XMLHttpRequest().responseType === "string";
  };
  var testSVG = function(document2) {
    var img = new Image();
    var canvas = document2.createElement("canvas");
    var ctx = canvas.getContext("2d");
    if (!ctx) {
      return false;
    }
    img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
    try {
      ctx.drawImage(img, 0, 0);
      canvas.toDataURL();
    } catch (e2) {
      return false;
    }
    return true;
  };
  var isGreenPixel = function(data) {
    return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
  };
  var testForeignObject = function(document2) {
    var canvas = document2.createElement("canvas");
    var size = 100;
    canvas.width = size;
    canvas.height = size;
    var ctx = canvas.getContext("2d");
    if (!ctx) {
      return Promise.reject(false);
    }
    ctx.fillStyle = "rgb(0, 255, 0)";
    ctx.fillRect(0, 0, size, size);
    var img = new Image();
    var greenImageSrc = canvas.toDataURL();
    img.src = greenImageSrc;
    var svg2 = createForeignObjectSVG(size, size, 0, 0, img);
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    return loadSerializedSVG$1(svg2).then(function(img2) {
      ctx.drawImage(img2, 0, 0);
      var data = ctx.getImageData(0, 0, size, size).data;
      ctx.fillStyle = "red";
      ctx.fillRect(0, 0, size, size);
      var node2 = document2.createElement("div");
      node2.style.backgroundImage = "url(" + greenImageSrc + ")";
      node2.style.height = size + "px";
      return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node2)) : Promise.reject(false);
    }).then(function(img2) {
      ctx.drawImage(img2, 0, 0);
      return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
    }).catch(function() {
      return false;
    });
  };
  var createForeignObjectSVG = function(width, height, x2, y2, node2) {
    var xmlns = "http://www.w3.org/2000/svg";
    var svg2 = document.createElementNS(xmlns, "svg");
    var foreignObject = document.createElementNS(xmlns, "foreignObject");
    svg2.setAttributeNS(null, "width", width.toString());
    svg2.setAttributeNS(null, "height", height.toString());
    foreignObject.setAttributeNS(null, "width", "100%");
    foreignObject.setAttributeNS(null, "height", "100%");
    foreignObject.setAttributeNS(null, "x", x2.toString());
    foreignObject.setAttributeNS(null, "y", y2.toString());
    foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
    svg2.appendChild(foreignObject);
    foreignObject.appendChild(node2);
    return svg2;
  };
  var loadSerializedSVG$1 = function(svg2) {
    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.onload = function() {
        return resolve(img);
      };
      img.onerror = reject;
      img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
    });
  };
  var FEATURES = {
    get SUPPORT_RANGE_BOUNDS() {
      var value = testRangeBounds(document);
      Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
      return value;
    },
    get SUPPORT_WORD_BREAKING() {
      var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
      Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
      return value;
    },
    get SUPPORT_SVG_DRAWING() {
      var value = testSVG(document);
      Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
      return value;
    },
    get SUPPORT_FOREIGNOBJECT_DRAWING() {
      var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
      Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
      return value;
    },
    get SUPPORT_CORS_IMAGES() {
      var value = testCORS();
      Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
      return value;
    },
    get SUPPORT_RESPONSE_TYPE() {
      var value = testResponseType();
      Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
      return value;
    },
    get SUPPORT_CORS_XHR() {
      var value = "withCredentials" in new XMLHttpRequest();
      Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
      return value;
    },
    get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
      var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
      Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
      return value;
    }
  };
  var TextBounds = (
    /** @class */
    /* @__PURE__ */ (function() {
      function TextBounds2(text2, bounds) {
        this.text = text2;
        this.bounds = bounds;
      }
      return TextBounds2;
    })()
  );
  var parseTextBounds = function(context, value, styles, node2) {
    var textList = breakText(value, styles);
    var textBounds = [];
    var offset = 0;
    textList.forEach(function(text2) {
      if (styles.textDecorationLine.length || text2.trim().length > 0) {
        if (FEATURES.SUPPORT_RANGE_BOUNDS) {
          var clientRects = createRange(node2, offset, text2.length).getClientRects();
          if (clientRects.length > 1) {
            var subSegments = segmentGraphemes(text2);
            var subOffset_1 = 0;
            subSegments.forEach(function(subSegment) {
              textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node2, subOffset_1 + offset, subSegment.length).getClientRects())));
              subOffset_1 += subSegment.length;
            });
          } else {
            textBounds.push(new TextBounds(text2, Bounds.fromDOMRectList(context, clientRects)));
          }
        } else {
          var replacementNode = node2.splitText(text2.length);
          textBounds.push(new TextBounds(text2, getWrapperBounds(context, node2)));
          node2 = replacementNode;
        }
      } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
        node2 = node2.splitText(text2.length);
      }
      offset += text2.length;
    });
    return textBounds;
  };
  var getWrapperBounds = function(context, node2) {
    var ownerDocument = node2.ownerDocument;
    if (ownerDocument) {
      var wrapper = ownerDocument.createElement("html2canvaswrapper");
      wrapper.appendChild(node2.cloneNode(true));
      var parentNode = node2.parentNode;
      if (parentNode) {
        parentNode.replaceChild(wrapper, node2);
        var bounds = parseBounds(context, wrapper);
        if (wrapper.firstChild) {
          parentNode.replaceChild(wrapper.firstChild, wrapper);
        }
        return bounds;
      }
    }
    return Bounds.EMPTY;
  };
  var createRange = function(node2, offset, length) {
    var ownerDocument = node2.ownerDocument;
    if (!ownerDocument) {
      throw new Error("Node has no owner document");
    }
    var range = ownerDocument.createRange();
    range.setStart(node2, offset);
    range.setEnd(node2, offset + length);
    return range;
  };
  var segmentGraphemes = function(value) {
    if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
      var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
      return Array.from(segmenter.segment(value)).map(function(segment) {
        return segment.segment;
      });
    }
    return splitGraphemes(value);
  };
  var segmentWords = function(value, styles) {
    if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
      var segmenter = new Intl.Segmenter(void 0, {
        granularity: "word"
      });
      return Array.from(segmenter.segment(value)).map(function(segment) {
        return segment.segment;
      });
    }
    return breakWords(value, styles);
  };
  var breakText = function(value, styles) {
    return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
  };
  var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
  var breakWords = function(str, styles) {
    var breaker = LineBreaker(str, {
      lineBreak: styles.lineBreak,
      wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
    });
    var words = [];
    var bk;
    var _loop_1 = function() {
      if (bk.value) {
        var value = bk.value.slice();
        var codePoints = toCodePoints$1(value);
        var word_1 = "";
        codePoints.forEach(function(codePoint) {
          if (wordSeparators.indexOf(codePoint) === -1) {
            word_1 += fromCodePoint$1(codePoint);
          } else {
            if (word_1.length) {
              words.push(word_1);
            }
            words.push(fromCodePoint$1(codePoint));
            word_1 = "";
          }
        });
        if (word_1.length) {
          words.push(word_1);
        }
      }
    };
    while (!(bk = breaker.next()).done) {
      _loop_1();
    }
    return words;
  };
  var TextContainer = (
    /** @class */
    /* @__PURE__ */ (function() {
      function TextContainer2(context, node2, styles) {
        this.text = transform(node2.data, styles.textTransform);
        this.textBounds = parseTextBounds(context, this.text, styles, node2);
      }
      return TextContainer2;
    })()
  );
  var transform = function(text2, transform2) {
    switch (transform2) {
      case 1:
        return text2.toLowerCase();
      case 3:
        return text2.replace(CAPITALIZE, capitalize);
      case 2:
        return text2.toUpperCase();
      default:
        return text2;
    }
  };
  var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
  var capitalize = function(m2, p1, p2) {
    if (m2.length > 0) {
      return p1 + p2.toUpperCase();
    }
    return m2;
  };
  var ImageElementContainer = (
    /** @class */
    (function(_super) {
      __extends(ImageElementContainer2, _super);
      function ImageElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        _this.src = img.currentSrc || img.src;
        _this.intrinsicWidth = img.naturalWidth;
        _this.intrinsicHeight = img.naturalHeight;
        _this.context.cache.addImage(_this.src);
        return _this;
      }
      return ImageElementContainer2;
    })(ElementContainer)
  );
  var CanvasElementContainer = (
    /** @class */
    (function(_super) {
      __extends(CanvasElementContainer2, _super);
      function CanvasElementContainer2(context, canvas) {
        var _this = _super.call(this, context, canvas) || this;
        _this.canvas = canvas;
        _this.intrinsicWidth = canvas.width;
        _this.intrinsicHeight = canvas.height;
        return _this;
      }
      return CanvasElementContainer2;
    })(ElementContainer)
  );
  var SVGElementContainer = (
    /** @class */
    (function(_super) {
      __extends(SVGElementContainer2, _super);
      function SVGElementContainer2(context, img) {
        var _this = _super.call(this, context, img) || this;
        var s2 = new XMLSerializer();
        var bounds = parseBounds(context, img);
        img.setAttribute("width", bounds.width + "px");
        img.setAttribute("height", bounds.height + "px");
        _this.svg = "data:image/svg+xml," + encodeURIComponent(s2.serializeToString(img));
        _this.intrinsicWidth = img.width.baseVal.value;
        _this.intrinsicHeight = img.height.baseVal.value;
        _this.context.cache.addImage(_this.svg);
        return _this;
      }
      return SVGElementContainer2;
    })(ElementContainer)
  );
  var LIElementContainer = (
    /** @class */
    (function(_super) {
      __extends(LIElementContainer2, _super);
      function LIElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return LIElementContainer2;
    })(ElementContainer)
  );
  var OLElementContainer = (
    /** @class */
    (function(_super) {
      __extends(OLElementContainer2, _super);
      function OLElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.start = element.start;
        _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
        return _this;
      }
      return OLElementContainer2;
    })(ElementContainer)
  );
  var CHECKBOX_BORDER_RADIUS = [
    {
      type: 15,
      flags: 0,
      unit: "px",
      number: 3
    }
  ];
  var RADIO_BORDER_RADIUS = [
    {
      type: 16,
      flags: 0,
      number: 50
    }
  ];
  var reformatInputBounds = function(bounds) {
    if (bounds.width > bounds.height) {
      return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
    } else if (bounds.width < bounds.height) {
      return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
    }
    return bounds;
  };
  var getInputValue = function(node2) {
    var value = node2.type === PASSWORD ? new Array(node2.value.length + 1).join("") : node2.value;
    return value.length === 0 ? node2.placeholder || "" : value;
  };
  var CHECKBOX = "checkbox";
  var RADIO = "radio";
  var PASSWORD = "password";
  var INPUT_COLOR = 707406591;
  var InputElementContainer = (
    /** @class */
    (function(_super) {
      __extends(InputElementContainer2, _super);
      function InputElementContainer2(context, input) {
        var _this = _super.call(this, context, input) || this;
        _this.type = input.type.toLowerCase();
        _this.checked = input.checked;
        _this.value = getInputValue(input);
        if (_this.type === CHECKBOX || _this.type === RADIO) {
          _this.styles.backgroundColor = 3739148031;
          _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
          _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
          _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
          _this.styles.backgroundClip = [
            0
            /* BORDER_BOX */
          ];
          _this.styles.backgroundOrigin = [
            0
            /* BORDER_BOX */
          ];
          _this.bounds = reformatInputBounds(_this.bounds);
        }
        switch (_this.type) {
          case CHECKBOX:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
            break;
          case RADIO:
            _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
            break;
        }
        return _this;
      }
      return InputElementContainer2;
    })(ElementContainer)
  );
  var SelectElementContainer = (
    /** @class */
    (function(_super) {
      __extends(SelectElementContainer2, _super);
      function SelectElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        var option = element.options[element.selectedIndex || 0];
        _this.value = option ? option.text || "" : "";
        return _this;
      }
      return SelectElementContainer2;
    })(ElementContainer)
  );
  var TextareaElementContainer = (
    /** @class */
    (function(_super) {
      __extends(TextareaElementContainer2, _super);
      function TextareaElementContainer2(context, element) {
        var _this = _super.call(this, context, element) || this;
        _this.value = element.value;
        return _this;
      }
      return TextareaElementContainer2;
    })(ElementContainer)
  );
  var IFrameElementContainer = (
    /** @class */
    (function(_super) {
      __extends(IFrameElementContainer2, _super);
      function IFrameElementContainer2(context, iframe) {
        var _this = _super.call(this, context, iframe) || this;
        _this.src = iframe.src;
        _this.width = parseInt(iframe.width, 10) || 0;
        _this.height = parseInt(iframe.height, 10) || 0;
        _this.backgroundColor = _this.styles.backgroundColor;
        try {
          if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
            _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
            var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
            var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
            _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
          }
        } catch (e2) {
        }
        return _this;
      }
      return IFrameElementContainer2;
    })(ElementContainer)
  );
  var LIST_OWNERS = ["OL", "UL", "MENU"];
  var parseNodeTree = function(context, node2, parent, root) {
    for (var childNode = node2.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
      nextNode = childNode.nextSibling;
      if (isTextNode(childNode) && childNode.data.trim().length > 0) {
        parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
      } else if (isElementNode(childNode)) {
        if (isSlotElement(childNode) && childNode.assignedNodes) {
          childNode.assignedNodes().forEach(function(childNode2) {
            return parseNodeTree(context, childNode2, parent, root);
          });
        } else {
          var container = createContainer(context, childNode);
          if (container.styles.isVisible()) {
            if (createsRealStackingContext(childNode, container, root)) {
              container.flags |= 4;
            } else if (createsStackingContext(container.styles)) {
              container.flags |= 2;
            }
            if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
              container.flags |= 8;
            }
            parent.elements.push(container);
            childNode.slot;
            if (childNode.shadowRoot) {
              parseNodeTree(context, childNode.shadowRoot, container, root);
            } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
              parseNodeTree(context, childNode, container, root);
            }
          }
        }
      }
    }
  };
  var createContainer = function(context, element) {
    if (isImageElement(element)) {
      return new ImageElementContainer(context, element);
    }
    if (isCanvasElement(element)) {
      return new CanvasElementContainer(context, element);
    }
    if (isSVGElement(element)) {
      return new SVGElementContainer(context, element);
    }
    if (isLIElement(element)) {
      return new LIElementContainer(context, element);
    }
    if (isOLElement(element)) {
      return new OLElementContainer(context, element);
    }
    if (isInputElement(element)) {
      return new InputElementContainer(context, element);
    }
    if (isSelectElement(element)) {
      return new SelectElementContainer(context, element);
    }
    if (isTextareaElement(element)) {
      return new TextareaElementContainer(context, element);
    }
    if (isIFrameElement(element)) {
      return new IFrameElementContainer(context, element);
    }
    return new ElementContainer(context, element);
  };
  var parseTree = function(context, element) {
    var container = createContainer(context, element);
    container.flags |= 4;
    parseNodeTree(context, element, container, container);
    return container;
  };
  var createsRealStackingContext = function(node2, container, root) {
    return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node2) && root.styles.isTransparent();
  };
  var createsStackingContext = function(styles) {
    return styles.isPositioned() || styles.isFloating();
  };
  var isTextNode = function(node2) {
    return node2.nodeType === Node.TEXT_NODE;
  };
  var isElementNode = function(node2) {
    return node2.nodeType === Node.ELEMENT_NODE;
  };
  var isHTMLElementNode = function(node2) {
    return isElementNode(node2) && typeof node2.style !== "undefined" && !isSVGElementNode(node2);
  };
  var isSVGElementNode = function(element) {
    return typeof element.className === "object";
  };
  var isLIElement = function(node2) {
    return node2.tagName === "LI";
  };
  var isOLElement = function(node2) {
    return node2.tagName === "OL";
  };
  var isInputElement = function(node2) {
    return node2.tagName === "INPUT";
  };
  var isHTMLElement = function(node2) {
    return node2.tagName === "HTML";
  };
  var isSVGElement = function(node2) {
    return node2.tagName === "svg";
  };
  var isBodyElement = function(node2) {
    return node2.tagName === "BODY";
  };
  var isCanvasElement = function(node2) {
    return node2.tagName === "CANVAS";
  };
  var isVideoElement = function(node2) {
    return node2.tagName === "VIDEO";
  };
  var isImageElement = function(node2) {
    return node2.tagName === "IMG";
  };
  var isIFrameElement = function(node2) {
    return node2.tagName === "IFRAME";
  };
  var isStyleElement = function(node2) {
    return node2.tagName === "STYLE";
  };
  var isScriptElement = function(node2) {
    return node2.tagName === "SCRIPT";
  };
  var isTextareaElement = function(node2) {
    return node2.tagName === "TEXTAREA";
  };
  var isSelectElement = function(node2) {
    return node2.tagName === "SELECT";
  };
  var isSlotElement = function(node2) {
    return node2.tagName === "SLOT";
  };
  var isCustomElement = function(node2) {
    return node2.tagName.indexOf("-") > 0;
  };
  var CounterState = (
    /** @class */
    (function() {
      function CounterState2() {
        this.counters = {};
      }
      CounterState2.prototype.getCounterValue = function(name) {
        var counter = this.counters[name];
        if (counter && counter.length) {
          return counter[counter.length - 1];
        }
        return 1;
      };
      CounterState2.prototype.getCounterValues = function(name) {
        var counter = this.counters[name];
        return counter ? counter : [];
      };
      CounterState2.prototype.pop = function(counters) {
        var _this = this;
        counters.forEach(function(counter) {
          return _this.counters[counter].pop();
        });
      };
      CounterState2.prototype.parse = function(style) {
        var _this = this;
        var counterIncrement2 = style.counterIncrement;
        var counterReset2 = style.counterReset;
        var canReset = true;
        if (counterIncrement2 !== null) {
          counterIncrement2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            if (counter && entry.increment !== 0) {
              canReset = false;
              if (!counter.length) {
                counter.push(1);
              }
              counter[Math.max(0, counter.length - 1)] += entry.increment;
            }
          });
        }
        var counterNames = [];
        if (canReset) {
          counterReset2.forEach(function(entry) {
            var counter = _this.counters[entry.counter];
            counterNames.push(entry.counter);
            if (!counter) {
              counter = _this.counters[entry.counter] = [];
            }
            counter.push(entry.reset);
          });
        }
        return counterNames;
      };
      return CounterState2;
    })()
  );
  var ROMAN_UPPER = {
    integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
    values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
  };
  var ARMENIAN = {
    integers: [
      9e3,
      8e3,
      7e3,
      6e3,
      5e3,
      4e3,
      3e3,
      2e3,
      1e3,
      900,
      800,
      700,
      600,
      500,
      400,
      300,
      200,
      100,
      90,
      80,
      70,
      60,
      50,
      40,
      30,
      20,
      10,
      9,
      8,
      7,
      6,
      5,
      4,
      3,
      2,
      1
    ],
    values: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  };
  var HEBREW = {
    integers: [
      1e4,
      9e3,
      8e3,
      7e3,
      6e3,
      5e3,
      4e3,
      3e3,
      2e3,
      1e3,
      400,
      300,
      200,
      100,
      90,
      80,
      70,
      60,
      50,
      40,
      30,
      20,
      19,
      18,
      17,
      16,
      15,
      10,
      9,
      8,
      7,
      6,
      5,
      4,
      3,
      2,
      1
    ],
    values: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  };
  var GEORGIAN = {
    integers: [
      1e4,
      9e3,
      8e3,
      7e3,
      6e3,
      5e3,
      4e3,
      3e3,
      2e3,
      1e3,
      900,
      800,
      700,
      600,
      500,
      400,
      300,
      200,
      100,
      90,
      80,
      70,
      60,
      50,
      40,
      30,
      20,
      10,
      9,
      8,
      7,
      6,
      5,
      4,
      3,
      2,
      1
    ],
    values: [
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      ""
    ]
  };
  var createAdditiveCounter = function(value, min, max, symbols, fallback, suffix) {
    if (value < min || value > max) {
      return createCounterText(value, fallback, suffix.length > 0);
    }
    return symbols.integers.reduce(function(string, integer, index2) {
      while (value >= integer) {
        value -= integer;
        string += symbols.values[index2];
      }
      return string;
    }, "") + suffix;
  };
  var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
    var string = "";
    do {
      if (!isNumeric) {
        value--;
      }
      string = resolver(value) + string;
      value /= codePointRangeLength;
    } while (value * codePointRangeLength >= codePointRangeLength);
    return string;
  };
  var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
    var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
    return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
      return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
    }) + suffix);
  };
  var createCounterStyleFromSymbols = function(value, symbols, suffix) {
    if (suffix === void 0) {
      suffix = ". ";
    }
    var codePointRangeLength = symbols.length;
    return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
      return symbols[Math.floor(codePoint % codePointRangeLength)];
    }) + suffix;
  };
  var CJK_ZEROS = 1 << 0;
  var CJK_TEN_COEFFICIENTS = 1 << 1;
  var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
  var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
  var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
    if (value < -9999 || value > 9999) {
      return createCounterText(value, 4, suffix.length > 0);
    }
    var tmp = Math.abs(value);
    var string = suffix;
    if (tmp === 0) {
      return numbers[0] + string;
    }
    for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
      var coefficient = tmp % 10;
      if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
        string = numbers[coefficient] + string;
      } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
        string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
      } else if (coefficient === 1 && digit > 0) {
        string = multipliers[digit - 1] + string;
      }
      tmp = Math.floor(tmp / 10);
    }
    return (value < 0 ? negativeSign : "") + string;
  };
  var CHINESE_INFORMAL_MULTIPLIERS = "";
  var CHINESE_FORMAL_MULTIPLIERS = "";
  var JAPANESE_NEGATIVE = "";
  var KOREAN_NEGATIVE = "";
  var createCounterText = function(value, type, appendSuffix) {
    var defaultSuffix = appendSuffix ? ". " : "";
    var cjkSuffix = appendSuffix ? "" : "";
    var koreanSuffix = appendSuffix ? ", " : "";
    var spaceSuffix = appendSuffix ? " " : "";
    switch (type) {
      case 0:
        return "" + spaceSuffix;
      case 1:
        return "" + spaceSuffix;
      case 2:
        return "" + spaceSuffix;
      case 5:
        var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
        return string.length < 4 ? "0" + string : string;
      case 4:
        return createCounterStyleFromSymbols(value, "", cjkSuffix);
      case 6:
        return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
      case 7:
        return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
      case 8:
        return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
      case 9:
        return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
      case 10:
        return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
      case 11:
        return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
      case 12:
      case 49:
        return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
      case 35:
        return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
      case 13:
        return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
      case 14:
      case 30:
        return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
      case 15:
        return createCounterStyleFromSymbols(value, "", cjkSuffix);
      case 16:
        return createCounterStyleFromSymbols(value, "", cjkSuffix);
      case 17:
      case 48:
        return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case 47:
        return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case 42:
        return createCJKCounter(value, "", CHINESE_INFORMAL_MULTIPLIERS, "", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case 41:
        return createCJKCounter(value, "", CHINESE_FORMAL_MULTIPLIERS, "", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
      case 26:
        return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, 0);
      case 25:
        return createCJKCounter(value, "", "", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case 31:
        return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case 33:
        return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, 0);
      case 32:
        return createCJKCounter(value, "", "", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
      case 18:
        return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
      case 20:
        return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
      case 21:
        return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
      case 22:
        return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
      case 22:
        return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
      case 23:
        return createCounterStyleFromSymbols(value, "");
      case 24:
        return createCounterStyleFromSymbols(value, "");
      case 27:
        return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
      case 28:
        return createCounterStyleFromSymbols(value, "", cjkSuffix);
      case 29:
        return createCounterStyleFromSymbols(value, "", cjkSuffix);
      case 34:
        return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
      case 37:
        return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
      case 38:
        return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
      case 39:
        return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
      case 40:
        return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
      case 43:
        return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
      case 44:
        return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
      case 45:
        return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
      case 46:
        return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
      case 3:
      default:
        return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
    }
  };
  var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
  var DocumentCloner = (
    /** @class */
    (function() {
      function DocumentCloner2(context, element, options) {
        this.context = context;
        this.options = options;
        this.scrolledElements = [];
        this.referenceElement = element;
        this.counters = new CounterState();
        this.quoteDepth = 0;
        if (!element.ownerDocument) {
          throw new Error("Cloned element does not have an owner document");
        }
        this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
      }
      DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
        var _this = this;
        var iframe = createIFrameContainer(ownerDocument, windowSize);
        if (!iframe.contentWindow) {
          return Promise.reject("Unable to find iframe window");
        }
        var scrollX = ownerDocument.defaultView.pageXOffset;
        var scrollY = ownerDocument.defaultView.pageYOffset;
        var cloneWindow = iframe.contentWindow;
        var documentClone = cloneWindow.document;
        var iframeLoad = iframeLoader(iframe).then(function() {
          return __awaiter(_this, void 0, void 0, function() {
            var onclone, referenceElement;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  this.scrolledElements.forEach(restoreNodeScroll);
                  if (cloneWindow) {
                    cloneWindow.scrollTo(windowSize.left, windowSize.top);
                    if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                      this.context.logger.warn("Unable to restore scroll position for cloned document");
                      this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                    }
                  }
                  onclone = this.options.onclone;
                  referenceElement = this.clonedReferenceElement;
                  if (typeof referenceElement === "undefined") {
                    return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
                  }
                  if (!(documentClone.fonts && documentClone.fonts.ready)) return [3, 2];
                  return [4, documentClone.fonts.ready];
                case 1:
                  _a2.sent();
                  _a2.label = 2;
                case 2:
                  if (!/(AppleWebKit)/g.test(navigator.userAgent)) return [3, 4];
                  return [4, imagesReady(documentClone)];
                case 3:
                  _a2.sent();
                  _a2.label = 4;
                case 4:
                  if (typeof onclone === "function") {
                    return [2, Promise.resolve().then(function() {
                      return onclone(documentClone, referenceElement);
                    }).then(function() {
                      return iframe;
                    })];
                  }
                  return [2, iframe];
              }
            });
          });
        });
        documentClone.open();
        documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
        restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
        documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
        documentClone.close();
        return iframeLoad;
      };
      DocumentCloner2.prototype.createElementClone = function(node2) {
        if (isDebugging(
          node2,
          2
          /* CLONE */
        )) {
          debugger;
        }
        if (isCanvasElement(node2)) {
          return this.createCanvasClone(node2);
        }
        if (isVideoElement(node2)) {
          return this.createVideoClone(node2);
        }
        if (isStyleElement(node2)) {
          return this.createStyleClone(node2);
        }
        var clone2 = node2.cloneNode(false);
        if (isImageElement(clone2)) {
          if (isImageElement(node2) && node2.currentSrc && node2.currentSrc !== node2.src) {
            clone2.src = node2.currentSrc;
            clone2.srcset = "";
          }
          if (clone2.loading === "lazy") {
            clone2.loading = "eager";
          }
        }
        if (isCustomElement(clone2)) {
          return this.createCustomElementClone(clone2);
        }
        return clone2;
      };
      DocumentCloner2.prototype.createCustomElementClone = function(node2) {
        var clone2 = document.createElement("html2canvascustomelement");
        copyCSSStyles(node2.style, clone2);
        return clone2;
      };
      DocumentCloner2.prototype.createStyleClone = function(node2) {
        try {
          var sheet = node2.sheet;
          if (sheet && sheet.cssRules) {
            var css = [].slice.call(sheet.cssRules, 0).reduce(function(css2, rule) {
              if (rule && typeof rule.cssText === "string") {
                return css2 + rule.cssText;
              }
              return css2;
            }, "");
            var style = node2.cloneNode(false);
            style.textContent = css;
            return style;
          }
        } catch (e2) {
          this.context.logger.error("Unable to access cssRules property", e2);
          if (e2.name !== "SecurityError") {
            throw e2;
          }
        }
        return node2.cloneNode(false);
      };
      DocumentCloner2.prototype.createCanvasClone = function(canvas) {
        var _a2;
        if (this.options.inlineImages && canvas.ownerDocument) {
          var img = canvas.ownerDocument.createElement("img");
          try {
            img.src = canvas.toDataURL();
            return img;
          } catch (e2) {
            this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
          }
        }
        var clonedCanvas = canvas.cloneNode(false);
        try {
          clonedCanvas.width = canvas.width;
          clonedCanvas.height = canvas.height;
          var ctx = canvas.getContext("2d");
          var clonedCtx = clonedCanvas.getContext("2d");
          if (clonedCtx) {
            if (!this.options.allowTaint && ctx) {
              clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
            } else {
              var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
              if (gl) {
                var attribs = gl.getContextAttributes();
                if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
                  this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
                }
              }
              clonedCtx.drawImage(canvas, 0, 0);
            }
          }
          return clonedCanvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
        }
        return clonedCanvas;
      };
      DocumentCloner2.prototype.createVideoClone = function(video) {
        var canvas = video.ownerDocument.createElement("canvas");
        canvas.width = video.offsetWidth;
        canvas.height = video.offsetHeight;
        var ctx = canvas.getContext("2d");
        try {
          if (ctx) {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            if (!this.options.allowTaint) {
              ctx.getImageData(0, 0, canvas.width, canvas.height);
            }
          }
          return canvas;
        } catch (e2) {
          this.context.logger.info("Unable to clone video as it is tainted", video);
        }
        var blankCanvas = video.ownerDocument.createElement("canvas");
        blankCanvas.width = video.offsetWidth;
        blankCanvas.height = video.offsetHeight;
        return blankCanvas;
      };
      DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
        if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
          if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
            clone2.appendChild(this.cloneNode(child, copyStyles));
          }
        }
      };
      DocumentCloner2.prototype.cloneChildNodes = function(node2, clone2, copyStyles) {
        var _this = this;
        for (var child = node2.shadowRoot ? node2.shadowRoot.firstChild : node2.firstChild; child; child = child.nextSibling) {
          if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
            var assignedNodes = child.assignedNodes();
            if (assignedNodes.length) {
              assignedNodes.forEach(function(assignedNode) {
                return _this.appendChildNode(clone2, assignedNode, copyStyles);
              });
            }
          } else {
            this.appendChildNode(clone2, child, copyStyles);
          }
        }
      };
      DocumentCloner2.prototype.cloneNode = function(node2, copyStyles) {
        if (isTextNode(node2)) {
          return document.createTextNode(node2.data);
        }
        if (!node2.ownerDocument) {
          return node2.cloneNode(false);
        }
        var window2 = node2.ownerDocument.defaultView;
        if (window2 && isElementNode(node2) && (isHTMLElementNode(node2) || isSVGElementNode(node2))) {
          var clone2 = this.createElementClone(node2);
          clone2.style.transitionProperty = "none";
          var style = window2.getComputedStyle(node2);
          var styleBefore = window2.getComputedStyle(node2, ":before");
          var styleAfter = window2.getComputedStyle(node2, ":after");
          if (this.referenceElement === node2 && isHTMLElementNode(clone2)) {
            this.clonedReferenceElement = clone2;
          }
          if (isBodyElement(clone2)) {
            createPseudoHideStyles(clone2);
          }
          var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
          var before = this.resolvePseudoContent(node2, clone2, styleBefore, PseudoElementType.BEFORE);
          if (isCustomElement(node2)) {
            copyStyles = true;
          }
          if (!isVideoElement(node2)) {
            this.cloneChildNodes(node2, clone2, copyStyles);
          }
          if (before) {
            clone2.insertBefore(before, clone2.firstChild);
          }
          var after = this.resolvePseudoContent(node2, clone2, styleAfter, PseudoElementType.AFTER);
          if (after) {
            clone2.appendChild(after);
          }
          this.counters.pop(counters);
          if (style && (this.options.copyStyles || isSVGElementNode(node2)) && !isIFrameElement(node2) || copyStyles) {
            copyCSSStyles(style, clone2);
          }
          if (node2.scrollTop !== 0 || node2.scrollLeft !== 0) {
            this.scrolledElements.push([clone2, node2.scrollLeft, node2.scrollTop]);
          }
          if ((isTextareaElement(node2) || isSelectElement(node2)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
            clone2.value = node2.value;
          }
          return clone2;
        }
        return node2.cloneNode(false);
      };
      DocumentCloner2.prototype.resolvePseudoContent = function(node2, clone2, style, pseudoElt) {
        var _this = this;
        if (!style) {
          return;
        }
        var value = style.content;
        var document2 = clone2.ownerDocument;
        if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
          return;
        }
        this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
        var declaration = new CSSParsedPseudoDeclaration(this.context, style);
        var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
        copyCSSStyles(style, anonymousReplacedElement);
        declaration.content.forEach(function(token) {
          if (token.type === 0) {
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
          } else if (token.type === 22) {
            var img = document2.createElement("img");
            img.src = token.value;
            img.style.opacity = "1";
            anonymousReplacedElement.appendChild(img);
          } else if (token.type === 18) {
            if (token.name === "attr") {
              var attr = token.values.filter(isIdentToken);
              if (attr.length) {
                anonymousReplacedElement.appendChild(document2.createTextNode(node2.getAttribute(attr[0].value) || ""));
              }
            } else if (token.name === "counter") {
              var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
              if (counter && isIdentToken(counter)) {
                var counterState = _this.counters.getCounterValue(counter.value);
                var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
              }
            } else if (token.name === "counters") {
              var _b2 = token.values.filter(nonFunctionArgSeparator), counter = _b2[0], delim = _b2[1], counterStyle = _b2[2];
              if (counter && isIdentToken(counter)) {
                var counterStates = _this.counters.getCounterValues(counter.value);
                var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
                var separator = delim && delim.type === 0 ? delim.value : "";
                var text2 = counterStates.map(function(value2) {
                  return createCounterText(value2, counterType_1, false);
                }).join(separator);
                anonymousReplacedElement.appendChild(document2.createTextNode(text2));
              }
            } else ;
          } else if (token.type === 20) {
            switch (token.value) {
              case "open-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
                break;
              case "close-quote":
                anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
                break;
              default:
                anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
            }
          }
        });
        anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
        if (isSVGElementNode(clone2)) {
          clone2.className.baseValue += newClassName;
        } else {
          clone2.className += newClassName;
        }
        return anonymousReplacedElement;
      };
      DocumentCloner2.destroy = function(container) {
        if (container.parentNode) {
          container.parentNode.removeChild(container);
          return true;
        }
        return false;
      };
      return DocumentCloner2;
    })()
  );
  var PseudoElementType;
  (function(PseudoElementType2) {
    PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
    PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
  })(PseudoElementType || (PseudoElementType = {}));
  var createIFrameContainer = function(ownerDocument, bounds) {
    var cloneIframeContainer = ownerDocument.createElement("iframe");
    cloneIframeContainer.className = "html2canvas-container";
    cloneIframeContainer.style.visibility = "hidden";
    cloneIframeContainer.style.position = "fixed";
    cloneIframeContainer.style.left = "-10000px";
    cloneIframeContainer.style.top = "0px";
    cloneIframeContainer.style.border = "0";
    cloneIframeContainer.width = bounds.width.toString();
    cloneIframeContainer.height = bounds.height.toString();
    cloneIframeContainer.scrolling = "no";
    cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
    ownerDocument.body.appendChild(cloneIframeContainer);
    return cloneIframeContainer;
  };
  var imageReady = function(img) {
    return new Promise(function(resolve) {
      if (img.complete) {
        resolve();
        return;
      }
      if (!img.src) {
        resolve();
        return;
      }
      img.onload = resolve;
      img.onerror = resolve;
    });
  };
  var imagesReady = function(document2) {
    return Promise.all([].slice.call(document2.images, 0).map(imageReady));
  };
  var iframeLoader = function(iframe) {
    return new Promise(function(resolve, reject) {
      var cloneWindow = iframe.contentWindow;
      if (!cloneWindow) {
        return reject("No window assigned for iframe");
      }
      var documentClone = cloneWindow.document;
      cloneWindow.onload = iframe.onload = function() {
        cloneWindow.onload = iframe.onload = null;
        var interval = setInterval(function() {
          if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
            clearInterval(interval);
            resolve(iframe);
          }
        }, 50);
      };
    });
  };
  var ignoredStyleProperties = [
    "all",
    "d",
    "content"
    // Safari shows pseudoelements if content is set
  ];
  var copyCSSStyles = function(style, target) {
    for (var i2 = style.length - 1; i2 >= 0; i2--) {
      var property = style.item(i2);
      if (ignoredStyleProperties.indexOf(property) === -1) {
        target.style.setProperty(property, style.getPropertyValue(property));
      }
    }
    return target;
  };
  var serializeDoctype = function(doctype) {
    var str = "";
    if (doctype) {
      str += "<!DOCTYPE ";
      if (doctype.name) {
        str += doctype.name;
      }
      if (doctype.internalSubset) {
        str += doctype.internalSubset;
      }
      if (doctype.publicId) {
        str += '"' + doctype.publicId + '"';
      }
      if (doctype.systemId) {
        str += '"' + doctype.systemId + '"';
      }
      str += ">";
    }
    return str;
  };
  var restoreOwnerScroll = function(ownerDocument, x2, y2) {
    if (ownerDocument && ownerDocument.defaultView && (x2 !== ownerDocument.defaultView.pageXOffset || y2 !== ownerDocument.defaultView.pageYOffset)) {
      ownerDocument.defaultView.scrollTo(x2, y2);
    }
  };
  var restoreNodeScroll = function(_a2) {
    var element = _a2[0], x2 = _a2[1], y2 = _a2[2];
    element.scrollLeft = x2;
    element.scrollTop = y2;
  };
  var PSEUDO_BEFORE = ":before";
  var PSEUDO_AFTER = ":after";
  var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
  var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
  var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
  var createPseudoHideStyles = function(body) {
    createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
  };
  var createStyles = function(body, styles) {
    var document2 = body.ownerDocument;
    if (document2) {
      var style = document2.createElement("style");
      style.textContent = styles;
      body.appendChild(style);
    }
  };
  var CacheStorage = (
    /** @class */
    (function() {
      function CacheStorage2() {
      }
      CacheStorage2.getOrigin = function(url) {
        var link = CacheStorage2._link;
        if (!link) {
          return "about:blank";
        }
        link.href = url;
        link.href = link.href;
        return link.protocol + link.hostname + link.port;
      };
      CacheStorage2.isSameOrigin = function(src) {
        return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
      };
      CacheStorage2.setContext = function(window2) {
        CacheStorage2._link = window2.document.createElement("a");
        CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
      };
      CacheStorage2._origin = "about:blank";
      return CacheStorage2;
    })()
  );
  var Cache = (
    /** @class */
    (function() {
      function Cache2(context, _options) {
        this.context = context;
        this._options = _options;
        this._cache = {};
      }
      Cache2.prototype.addImage = function(src) {
        var result = Promise.resolve();
        if (this.has(src)) {
          return result;
        }
        if (isBlobImage(src) || isRenderable(src)) {
          (this._cache[src] = this.loadImage(src)).catch(function() {
          });
          return result;
        }
        return result;
      };
      Cache2.prototype.match = function(src) {
        return this._cache[src];
      };
      Cache2.prototype.loadImage = function(key) {
        return __awaiter(this, void 0, void 0, function() {
          var isSameOrigin, useCORS, useProxy, src;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                isSameOrigin = CacheStorage.isSameOrigin(key);
                useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
                useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
                if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
                  return [
                    2
                    /*return*/
                  ];
                }
                src = key;
                if (!useProxy) return [3, 2];
                return [4, this.proxy(src)];
              case 1:
                src = _a2.sent();
                _a2.label = 2;
              case 2:
                this.context.logger.debug("Added image " + key.substring(0, 256));
                return [4, new Promise(function(resolve, reject) {
                  var img = new Image();
                  img.onload = function() {
                    return resolve(img);
                  };
                  img.onerror = reject;
                  if (isInlineBase64Image(src) || useCORS) {
                    img.crossOrigin = "anonymous";
                  }
                  img.src = src;
                  if (img.complete === true) {
                    setTimeout(function() {
                      return resolve(img);
                    }, 500);
                  }
                  if (_this._options.imageTimeout > 0) {
                    setTimeout(function() {
                      return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                    }, _this._options.imageTimeout);
                  }
                })];
              case 3:
                return [2, _a2.sent()];
            }
          });
        });
      };
      Cache2.prototype.has = function(key) {
        return typeof this._cache[key] !== "undefined";
      };
      Cache2.prototype.keys = function() {
        return Promise.resolve(Object.keys(this._cache));
      };
      Cache2.prototype.proxy = function(src) {
        var _this = this;
        var proxy = this._options.proxy;
        if (!proxy) {
          throw new Error("No proxy defined");
        }
        var key = src.substring(0, 256);
        return new Promise(function(resolve, reject) {
          var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
          var xhr = new XMLHttpRequest();
          xhr.onload = function() {
            if (xhr.status === 200) {
              if (responseType === "text") {
                resolve(xhr.response);
              } else {
                var reader_1 = new FileReader();
                reader_1.addEventListener("load", function() {
                  return resolve(reader_1.result);
                }, false);
                reader_1.addEventListener("error", function(e2) {
                  return reject(e2);
                }, false);
                reader_1.readAsDataURL(xhr.response);
              }
            } else {
              reject("Failed to proxy resource " + key + " with status code " + xhr.status);
            }
          };
          xhr.onerror = reject;
          var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
          xhr.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
          if (responseType !== "text" && xhr instanceof XMLHttpRequest) {
            xhr.responseType = responseType;
          }
          if (_this._options.imageTimeout) {
            var timeout_1 = _this._options.imageTimeout;
            xhr.timeout = timeout_1;
            xhr.ontimeout = function() {
              return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
            };
          }
          xhr.send();
        });
      };
      return Cache2;
    })()
  );
  var INLINE_SVG = /^data:image\/svg\+xml/i;
  var INLINE_BASE64 = /^data:image\/.*;base64,/i;
  var INLINE_IMG = /^data:image\/.*/i;
  var isRenderable = function(src) {
    return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
  };
  var isInlineImage = function(src) {
    return INLINE_IMG.test(src);
  };
  var isInlineBase64Image = function(src) {
    return INLINE_BASE64.test(src);
  };
  var isBlobImage = function(src) {
    return src.substr(0, 4) === "blob";
  };
  var isSVG = function(src) {
    return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
  };
  var Vector = (
    /** @class */
    (function() {
      function Vector2(x2, y2) {
        this.type = 0;
        this.x = x2;
        this.y = y2;
      }
      Vector2.prototype.add = function(deltaX, deltaY) {
        return new Vector2(this.x + deltaX, this.y + deltaY);
      };
      return Vector2;
    })()
  );
  var lerp = function(a2, b2, t2) {
    return new Vector(a2.x + (b2.x - a2.x) * t2, a2.y + (b2.y - a2.y) * t2);
  };
  var BezierCurve = (
    /** @class */
    (function() {
      function BezierCurve2(start, startControl, endControl, end) {
        this.type = 1;
        this.start = start;
        this.startControl = startControl;
        this.endControl = endControl;
        this.end = end;
      }
      BezierCurve2.prototype.subdivide = function(t2, firstHalf) {
        var ab = lerp(this.start, this.startControl, t2);
        var bc = lerp(this.startControl, this.endControl, t2);
        var cd = lerp(this.endControl, this.end, t2);
        var abbc = lerp(ab, bc, t2);
        var bccd = lerp(bc, cd, t2);
        var dest = lerp(abbc, bccd, t2);
        return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
      };
      BezierCurve2.prototype.add = function(deltaX, deltaY) {
        return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
      };
      BezierCurve2.prototype.reverse = function() {
        return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
      };
      return BezierCurve2;
    })()
  );
  var isBezierCurve = function(path) {
    return path.type === 1;
  };
  var BoundCurves = (
    /** @class */
    /* @__PURE__ */ (function() {
      function BoundCurves2(element) {
        var styles = element.styles;
        var bounds = element.bounds;
        var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
        var _b2 = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b2[0], trv = _b2[1];
        var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
        var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
        var factors = [];
        factors.push((tlh + trh) / bounds.width);
        factors.push((blh + brh) / bounds.width);
        factors.push((tlv + blv) / bounds.height);
        factors.push((trv + brv) / bounds.height);
        var maxFactor = Math.max.apply(Math, factors);
        if (maxFactor > 1) {
          tlh /= maxFactor;
          tlv /= maxFactor;
          trh /= maxFactor;
          trv /= maxFactor;
          brh /= maxFactor;
          brv /= maxFactor;
          blh /= maxFactor;
          blv /= maxFactor;
        }
        var topWidth = bounds.width - trh;
        var rightHeight = bounds.height - brv;
        var bottomWidth = bounds.width - brh;
        var leftHeight = bounds.height - blv;
        var borderTopWidth2 = styles.borderTopWidth;
        var borderRightWidth2 = styles.borderRightWidth;
        var borderBottomWidth2 = styles.borderBottomWidth;
        var borderLeftWidth2 = styles.borderLeftWidth;
        var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
        var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
        var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
        var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
        this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
        this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
        this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
        this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
        this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
        this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
        this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
        this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
        this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
        this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
        this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
        this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
        this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
        this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
        this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
        this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
        this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
      }
      return BoundCurves2;
    })()
  );
  var CORNER;
  (function(CORNER2) {
    CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
    CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
    CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
    CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
  })(CORNER || (CORNER = {}));
  var getCurvePoints = function(x2, y2, r1, r2, position2) {
    var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
    var ox = r1 * kappa;
    var oy = r2 * kappa;
    var xm = x2 + r1;
    var ym = y2 + r2;
    switch (position2) {
      case CORNER.TOP_LEFT:
        return new BezierCurve(new Vector(x2, ym), new Vector(x2, ym - oy), new Vector(xm - ox, y2), new Vector(xm, y2));
      case CORNER.TOP_RIGHT:
        return new BezierCurve(new Vector(x2, y2), new Vector(x2 + ox, y2), new Vector(xm, ym - oy), new Vector(xm, ym));
      case CORNER.BOTTOM_RIGHT:
        return new BezierCurve(new Vector(xm, y2), new Vector(xm, y2 + oy), new Vector(x2 + ox, ym), new Vector(x2, ym));
      case CORNER.BOTTOM_LEFT:
      default:
        return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x2, y2 + oy), new Vector(x2, y2));
    }
  };
  var calculateBorderBoxPath = function(curves) {
    return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
  };
  var calculateContentBoxPath = function(curves) {
    return [
      curves.topLeftContentBox,
      curves.topRightContentBox,
      curves.bottomRightContentBox,
      curves.bottomLeftContentBox
    ];
  };
  var calculatePaddingBoxPath = function(curves) {
    return [
      curves.topLeftPaddingBox,
      curves.topRightPaddingBox,
      curves.bottomRightPaddingBox,
      curves.bottomLeftPaddingBox
    ];
  };
  var TransformEffect = (
    /** @class */
    /* @__PURE__ */ (function() {
      function TransformEffect2(offsetX, offsetY, matrix2) {
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        this.matrix = matrix2;
        this.type = 0;
        this.target = 2 | 4;
      }
      return TransformEffect2;
    })()
  );
  var ClipEffect = (
    /** @class */
    /* @__PURE__ */ (function() {
      function ClipEffect2(path, target) {
        this.path = path;
        this.target = target;
        this.type = 1;
      }
      return ClipEffect2;
    })()
  );
  var OpacityEffect = (
    /** @class */
    /* @__PURE__ */ (function() {
      function OpacityEffect2(opacity2) {
        this.opacity = opacity2;
        this.type = 2;
        this.target = 2 | 4;
      }
      return OpacityEffect2;
    })()
  );
  var isTransformEffect = function(effect) {
    return effect.type === 0;
  };
  var isClipEffect = function(effect) {
    return effect.type === 1;
  };
  var isOpacityEffect = function(effect) {
    return effect.type === 2;
  };
  var equalPath = function(a2, b2) {
    if (a2.length === b2.length) {
      return a2.some(function(v2, i2) {
        return v2 === b2[i2];
      });
    }
    return false;
  };
  var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
    return path.map(function(point, index2) {
      switch (index2) {
        case 0:
          return point.add(deltaX, deltaY);
        case 1:
          return point.add(deltaX + deltaW, deltaY);
        case 2:
          return point.add(deltaX + deltaW, deltaY + deltaH);
        case 3:
          return point.add(deltaX, deltaY + deltaH);
      }
      return point;
    });
  };
  var StackingContext = (
    /** @class */
    /* @__PURE__ */ (function() {
      function StackingContext2(container) {
        this.element = container;
        this.inlineLevel = [];
        this.nonInlineLevel = [];
        this.negativeZIndex = [];
        this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
        this.positiveZIndex = [];
        this.nonPositionedFloats = [];
        this.nonPositionedInlineLevel = [];
      }
      return StackingContext2;
    })()
  );
  var ElementPaint = (
    /** @class */
    (function() {
      function ElementPaint2(container, parent) {
        this.container = container;
        this.parent = parent;
        this.effects = [];
        this.curves = new BoundCurves(this.container);
        if (this.container.styles.opacity < 1) {
          this.effects.push(new OpacityEffect(this.container.styles.opacity));
        }
        if (this.container.styles.transform !== null) {
          var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
          var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
          var matrix2 = this.container.styles.transform;
          this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
        }
        if (this.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(this.curves);
          var paddingBox2 = calculatePaddingBoxPath(this.curves);
          if (equalPath(borderBox, paddingBox2)) {
            this.effects.push(new ClipEffect(
              borderBox,
              2 | 4
              /* CONTENT */
            ));
          } else {
            this.effects.push(new ClipEffect(
              borderBox,
              2
              /* BACKGROUND_BORDERS */
            ));
            this.effects.push(new ClipEffect(
              paddingBox2,
              4
              /* CONTENT */
            ));
          }
        }
      }
      ElementPaint2.prototype.getEffects = function(target) {
        var inFlow = [
          2,
          3
          /* FIXED */
        ].indexOf(this.container.styles.position) === -1;
        var parent = this.parent;
        var effects = this.effects.slice(0);
        while (parent) {
          var croplessEffects = parent.effects.filter(function(effect) {
            return !isClipEffect(effect);
          });
          if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
            effects.unshift.apply(effects, croplessEffects);
            inFlow = [
              2,
              3
              /* FIXED */
            ].indexOf(parent.container.styles.position) === -1;
            if (parent.container.styles.overflowX !== 0) {
              var borderBox = calculateBorderBoxPath(parent.curves);
              var paddingBox2 = calculatePaddingBoxPath(parent.curves);
              if (!equalPath(borderBox, paddingBox2)) {
                effects.unshift(new ClipEffect(
                  paddingBox2,
                  2 | 4
                  /* CONTENT */
                ));
              }
            }
          } else {
            effects.unshift.apply(effects, croplessEffects);
          }
          parent = parent.parent;
        }
        return effects.filter(function(effect) {
          return contains(effect.target, target);
        });
      };
      return ElementPaint2;
    })()
  );
  var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
    parent.container.elements.forEach(function(child) {
      var treatAsRealStackingContext = contains(
        child.flags,
        4
        /* CREATES_REAL_STACKING_CONTEXT */
      );
      var createsStackingContext2 = contains(
        child.flags,
        2
        /* CREATES_STACKING_CONTEXT */
      );
      var paintContainer = new ElementPaint(child, parent);
      if (contains(
        child.styles.display,
        2048
        /* LIST_ITEM */
      )) {
        listItems.push(paintContainer);
      }
      var listOwnerItems = contains(
        child.flags,
        8
        /* IS_LIST_OWNER */
      ) ? [] : listItems;
      if (treatAsRealStackingContext || createsStackingContext2) {
        var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
        var stack = new StackingContext(paintContainer);
        if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
          var order_1 = child.styles.zIndex.order;
          if (order_1 < 0) {
            var index_1 = 0;
            parentStack.negativeZIndex.some(function(current, i2) {
              if (order_1 > current.element.container.styles.zIndex.order) {
                index_1 = i2;
                return false;
              } else if (index_1 > 0) {
                return true;
              }
              return false;
            });
            parentStack.negativeZIndex.splice(index_1, 0, stack);
          } else if (order_1 > 0) {
            var index_2 = 0;
            parentStack.positiveZIndex.some(function(current, i2) {
              if (order_1 >= current.element.container.styles.zIndex.order) {
                index_2 = i2 + 1;
                return false;
              } else if (index_2 > 0) {
                return true;
              }
              return false;
            });
            parentStack.positiveZIndex.splice(index_2, 0, stack);
          } else {
            parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
          }
        } else {
          if (child.styles.isFloating()) {
            parentStack.nonPositionedFloats.push(stack);
          } else {
            parentStack.nonPositionedInlineLevel.push(stack);
          }
        }
        parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
      } else {
        if (child.styles.isInlineLevel()) {
          stackingContext.inlineLevel.push(paintContainer);
        } else {
          stackingContext.nonInlineLevel.push(paintContainer);
        }
        parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
      }
      if (contains(
        child.flags,
        8
        /* IS_LIST_OWNER */
      )) {
        processListItems(child, listOwnerItems);
      }
    });
  };
  var processListItems = function(owner, elements2) {
    var numbering = owner instanceof OLElementContainer ? owner.start : 1;
    var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
    for (var i2 = 0; i2 < elements2.length; i2++) {
      var item = elements2[i2];
      if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
        numbering = item.container.value;
      }
      item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
      numbering += reversed ? -1 : 1;
    }
  };
  var parseStackingContexts = function(container) {
    var paintContainer = new ElementPaint(container, null);
    var root = new StackingContext(paintContainer);
    var listItems = [];
    parseStackTree(paintContainer, root, root, listItems);
    processListItems(paintContainer.container, listItems);
    return root;
  };
  var parsePathForBorder = function(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
    }
  };
  var parsePathForBorderDoubleOuter = function(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
    }
  };
  var parsePathForBorderDoubleInner = function(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
      case 1:
        return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
      case 2:
        return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
      case 3:
      default:
        return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
    }
  };
  var parsePathForBorderStroke = function(curves, borderSide) {
    switch (borderSide) {
      case 0:
        return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
      case 1:
        return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
      case 2:
        return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
      case 3:
      default:
        return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
    }
  };
  var createStrokePathFromCurves = function(outer1, outer2) {
    var path = [];
    if (isBezierCurve(outer1)) {
      path.push(outer1.subdivide(0.5, false));
    } else {
      path.push(outer1);
    }
    if (isBezierCurve(outer2)) {
      path.push(outer2.subdivide(0.5, true));
    } else {
      path.push(outer2);
    }
    return path;
  };
  var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
    var path = [];
    if (isBezierCurve(outer1)) {
      path.push(outer1.subdivide(0.5, false));
    } else {
      path.push(outer1);
    }
    if (isBezierCurve(outer2)) {
      path.push(outer2.subdivide(0.5, true));
    } else {
      path.push(outer2);
    }
    if (isBezierCurve(inner2)) {
      path.push(inner2.subdivide(0.5, true).reverse());
    } else {
      path.push(inner2);
    }
    if (isBezierCurve(inner1)) {
      path.push(inner1.subdivide(0.5, false).reverse());
    } else {
      path.push(inner1);
    }
    return path;
  };
  var paddingBox = function(element) {
    var bounds = element.bounds;
    var styles = element.styles;
    return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
  };
  var contentBox = function(element) {
    var styles = element.styles;
    var bounds = element.bounds;
    var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
    var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
    var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
    var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
    return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
  };
  var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
    if (backgroundOrigin2 === 0) {
      return element.bounds;
    }
    if (backgroundOrigin2 === 2) {
      return contentBox(element);
    }
    return paddingBox(element);
  };
  var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
    if (backgroundClip2 === 0) {
      return element.bounds;
    }
    if (backgroundClip2 === 2) {
      return contentBox(element);
    }
    return paddingBox(element);
  };
  var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
    var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
    var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
    var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
    var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
    var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
    var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
    var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
    var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
    return [path, offsetX, offsetY, sizeWidth, sizeHeight];
  };
  var isAuto = function(token) {
    return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
  };
  var hasIntrinsicValue = function(value) {
    return typeof value === "number";
  };
  var calculateBackgroundSize = function(size, _a2, bounds) {
    var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
    var first = size[0], second = size[1];
    if (!first) {
      return [0, 0];
    }
    if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
      return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
    }
    var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
    if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
      if (hasIntrinsicValue(intrinsicProportion)) {
        var targetRatio = bounds.width / bounds.height;
        return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
      }
      return [bounds.width, bounds.height];
    }
    var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
    var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
    var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
    if (isAuto(first) && (!second || isAuto(second))) {
      if (hasIntrinsicWidth && hasIntrinsicHeight) {
        return [intrinsicWidth, intrinsicHeight];
      }
      if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
        return [bounds.width, bounds.height];
      }
      if (hasIntrinsicDimensions && hasIntrinsicProportion) {
        var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
        var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
        return [width_1, height_1];
      }
      var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
      var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
      return [width_2, height_2];
    }
    if (hasIntrinsicProportion) {
      var width_3 = 0;
      var height_3 = 0;
      if (isLengthPercentage(first)) {
        width_3 = getAbsoluteValue(first, bounds.width);
      } else if (isLengthPercentage(second)) {
        height_3 = getAbsoluteValue(second, bounds.height);
      }
      if (isAuto(first)) {
        width_3 = height_3 * intrinsicProportion;
      } else if (!second || isAuto(second)) {
        height_3 = width_3 / intrinsicProportion;
      }
      return [width_3, height_3];
    }
    var width = null;
    var height = null;
    if (isLengthPercentage(first)) {
      width = getAbsoluteValue(first, bounds.width);
    } else if (second && isLengthPercentage(second)) {
      height = getAbsoluteValue(second, bounds.height);
    }
    if (width !== null && (!second || isAuto(second))) {
      height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
    }
    if (height !== null && isAuto(first)) {
      width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
    }
    if (width !== null && height !== null) {
      return [width, height];
    }
    throw new Error("Unable to calculate background-size for element");
  };
  var getBackgroundValueForIndex = function(values, index2) {
    var value = values[index2];
    if (typeof value === "undefined") {
      return values[0];
    }
    return value;
  };
  var calculateBackgroundRepeatPath = function(repeat, _a2, _b2, backgroundPositioningArea, backgroundPaintingArea) {
    var x2 = _a2[0], y2 = _a2[1];
    var width = _b2[0], height = _b2[1];
    switch (repeat) {
      case 2:
        return [
          new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y2)),
          new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y2)),
          new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y2)),
          new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y2))
        ];
      case 3:
        return [
          new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top)),
          new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top)),
          new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
          new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
        ];
      case 1:
        return [
          new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2)),
          new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2)),
          new Vector(Math.round(backgroundPositioningArea.left + x2 + width), Math.round(backgroundPositioningArea.top + y2 + height)),
          new Vector(Math.round(backgroundPositioningArea.left + x2), Math.round(backgroundPositioningArea.top + y2 + height))
        ];
      default:
        return [
          new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
          new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
          new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
          new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
        ];
    }
  };
  var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  var SAMPLE_TEXT = "Hidden Text";
  var FontMetrics = (
    /** @class */
    (function() {
      function FontMetrics2(document2) {
        this._data = {};
        this._document = document2;
      }
      FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
        var container = this._document.createElement("div");
        var img = this._document.createElement("img");
        var span = this._document.createElement("span");
        var body = this._document.body;
        container.style.visibility = "hidden";
        container.style.fontFamily = fontFamily2;
        container.style.fontSize = fontSize2;
        container.style.margin = "0";
        container.style.padding = "0";
        container.style.whiteSpace = "nowrap";
        body.appendChild(container);
        img.src = SMALL_IMAGE;
        img.width = 1;
        img.height = 1;
        img.style.margin = "0";
        img.style.padding = "0";
        img.style.verticalAlign = "baseline";
        span.style.fontFamily = fontFamily2;
        span.style.fontSize = fontSize2;
        span.style.margin = "0";
        span.style.padding = "0";
        span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.appendChild(span);
        container.appendChild(img);
        var baseline = img.offsetTop - span.offsetTop + 2;
        container.removeChild(span);
        container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
        container.style.lineHeight = "normal";
        img.style.verticalAlign = "super";
        var middle = img.offsetTop - container.offsetTop + 2;
        body.removeChild(container);
        return { baseline, middle };
      };
      FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
        var key = fontFamily2 + " " + fontSize2;
        if (typeof this._data[key] === "undefined") {
          this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
        }
        return this._data[key];
      };
      return FontMetrics2;
    })()
  );
  var Renderer = (
    /** @class */
    /* @__PURE__ */ (function() {
      function Renderer2(context, options) {
        this.context = context;
        this.options = options;
      }
      return Renderer2;
    })()
  );
  var MASK_OFFSET = 1e4;
  var CanvasRenderer = (
    /** @class */
    (function(_super) {
      __extends(CanvasRenderer2, _super);
      function CanvasRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this._activeEffects = [];
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        if (!options.canvas) {
          _this.canvas.width = Math.floor(options.width * options.scale);
          _this.canvas.height = Math.floor(options.height * options.scale);
          _this.canvas.style.width = options.width + "px";
          _this.canvas.style.height = options.height + "px";
        }
        _this.fontMetrics = new FontMetrics(document);
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.ctx.textBaseline = "bottom";
        _this._activeEffects = [];
        _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
        return _this;
      }
      CanvasRenderer2.prototype.applyEffects = function(effects) {
        var _this = this;
        while (this._activeEffects.length) {
          this.popEffect();
        }
        effects.forEach(function(effect) {
          return _this.applyEffect(effect);
        });
      };
      CanvasRenderer2.prototype.applyEffect = function(effect) {
        this.ctx.save();
        if (isOpacityEffect(effect)) {
          this.ctx.globalAlpha = effect.opacity;
        }
        if (isTransformEffect(effect)) {
          this.ctx.translate(effect.offsetX, effect.offsetY);
          this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
          this.ctx.translate(-effect.offsetX, -effect.offsetY);
        }
        if (isClipEffect(effect)) {
          this.path(effect.path);
          this.ctx.clip();
        }
        this._activeEffects.push(effect);
      };
      CanvasRenderer2.prototype.popEffect = function() {
        this._activeEffects.pop();
        this.ctx.restore();
      };
      CanvasRenderer2.prototype.renderStack = function(stack) {
        return __awaiter(this, void 0, void 0, function() {
          var styles;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                styles = stack.element.container.styles;
                if (!styles.isVisible()) return [3, 2];
                return [4, this.renderStackContent(stack)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNode = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (contains(
                  paint.container.flags,
                  16
                  /* DEBUG_RENDER */
                )) {
                  debugger;
                }
                if (!paint.container.styles.isVisible()) return [3, 3];
                return [4, this.renderNodeBackgroundAndBorders(paint)];
              case 1:
                _a2.sent();
                return [4, this.renderNodeContent(paint)];
              case 2:
                _a2.sent();
                _a2.label = 3;
              case 3:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text2, letterSpacing2, baseline) {
        var _this = this;
        if (letterSpacing2 === 0) {
          this.ctx.fillText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
        } else {
          var letters = segmentGraphemes(text2.text);
          letters.reduce(function(left, letter) {
            _this.ctx.fillText(letter, left, text2.bounds.top + baseline);
            return left + _this.ctx.measureText(letter).width;
          }, text2.bounds.left);
        }
      };
      CanvasRenderer2.prototype.createFontStyle = function(styles) {
        var fontVariant2 = styles.fontVariant.filter(function(variant) {
          return variant === "normal" || variant === "small-caps";
        }).join("");
        var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
        var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
        return [
          [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
          fontFamily2,
          fontSize2
        ];
      };
      CanvasRenderer2.prototype.renderTextNode = function(text2, styles) {
        return __awaiter(this, void 0, void 0, function() {
          var _a2, font, fontFamily2, fontSize2, _b2, baseline, middle, paintOrder2;
          var _this = this;
          return __generator(this, function(_c) {
            _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
            this.ctx.font = font;
            this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
            this.ctx.textAlign = "left";
            this.ctx.textBaseline = "alphabetic";
            _b2 = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b2.baseline, middle = _b2.middle;
            paintOrder2 = styles.paintOrder;
            text2.textBounds.forEach(function(text3) {
              paintOrder2.forEach(function(paintOrderLayer) {
                switch (paintOrderLayer) {
                  case 0:
                    _this.ctx.fillStyle = asString(styles.color);
                    _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                    var textShadows = styles.textShadow;
                    if (textShadows.length && text3.text.trim().length) {
                      textShadows.slice(0).reverse().forEach(function(textShadow2) {
                        _this.ctx.shadowColor = asString(textShadow2.color);
                        _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                        _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                        _this.ctx.shadowBlur = textShadow2.blur.number;
                        _this.renderTextWithLetterSpacing(text3, styles.letterSpacing, baseline);
                      });
                      _this.ctx.shadowColor = "";
                      _this.ctx.shadowOffsetX = 0;
                      _this.ctx.shadowOffsetY = 0;
                      _this.ctx.shadowBlur = 0;
                    }
                    if (styles.textDecorationLine.length) {
                      _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                      styles.textDecorationLine.forEach(function(textDecorationLine2) {
                        switch (textDecorationLine2) {
                          case 1:
                            _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top + baseline), text3.bounds.width, 1);
                            break;
                          case 2:
                            _this.ctx.fillRect(text3.bounds.left, Math.round(text3.bounds.top), text3.bounds.width, 1);
                            break;
                          case 3:
                            _this.ctx.fillRect(text3.bounds.left, Math.ceil(text3.bounds.top + middle), text3.bounds.width, 1);
                            break;
                        }
                      });
                    }
                    break;
                  case 1:
                    if (styles.webkitTextStrokeWidth && text3.text.trim().length) {
                      _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                      _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                      _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                      _this.ctx.strokeText(text3.text, text3.bounds.left, text3.bounds.top + baseline);
                    }
                    _this.ctx.strokeStyle = "";
                    _this.ctx.lineWidth = 0;
                    _this.ctx.lineJoin = "miter";
                    break;
                }
              });
            });
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
        if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
          var box = contentBox(container);
          var path = calculatePaddingBoxPath(curves);
          this.path(path);
          this.ctx.save();
          this.ctx.clip();
          this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
          this.ctx.restore();
        }
      };
      CanvasRenderer2.prototype.renderNodeContent = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b2, fontFamily2, fontSize2, baseline, bounds, x2, textBounds, img, image2, url, fontFamily2, bounds;
          return __generator(this, function(_c) {
            switch (_c.label) {
              case 0:
                this.applyEffects(paint.getEffects(
                  4
                  /* CONTENT */
                ));
                container = paint.container;
                curves = paint.curves;
                styles = container.styles;
                _i = 0, _a2 = container.textNodes;
                _c.label = 1;
              case 1:
                if (!(_i < _a2.length)) return [3, 4];
                child = _a2[_i];
                return [4, this.renderTextNode(child, styles)];
              case 2:
                _c.sent();
                _c.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                if (!(container instanceof ImageElementContainer)) return [3, 8];
                _c.label = 5;
              case 5:
                _c.trys.push([5, 7, , 8]);
                return [4, this.context.cache.match(container.src)];
              case 6:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 8];
              case 7:
                _c.sent();
                this.context.logger.error("Error loading image " + container.src);
                return [3, 8];
              case 8:
                if (container instanceof CanvasElementContainer) {
                  this.renderReplacedElement(container, curves, container.canvas);
                }
                if (!(container instanceof SVGElementContainer)) return [3, 12];
                _c.label = 9;
              case 9:
                _c.trys.push([9, 11, , 12]);
                return [4, this.context.cache.match(container.svg)];
              case 10:
                image2 = _c.sent();
                this.renderReplacedElement(container, curves, image2);
                return [3, 12];
              case 11:
                _c.sent();
                this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
                return [3, 12];
              case 12:
                if (!(container instanceof IFrameElementContainer && container.tree)) return [3, 14];
                iframeRenderer = new CanvasRenderer2(this.context, {
                  scale: this.options.scale,
                  backgroundColor: container.backgroundColor,
                  x: 0,
                  y: 0,
                  width: container.width,
                  height: container.height
                });
                return [4, iframeRenderer.render(container.tree)];
              case 13:
                canvas = _c.sent();
                if (container.width && container.height) {
                  this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
                }
                _c.label = 14;
              case 14:
                if (container instanceof InputElementContainer) {
                  size = Math.min(container.bounds.width, container.bounds.height);
                  if (container.type === CHECKBOX) {
                    if (container.checked) {
                      this.ctx.save();
                      this.path([
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                        new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                        new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                        new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                        new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                        new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                        new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                      ]);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  } else if (container.type === RADIO) {
                    if (container.checked) {
                      this.ctx.save();
                      this.ctx.beginPath();
                      this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                      this.ctx.fillStyle = asString(INPUT_COLOR);
                      this.ctx.fill();
                      this.ctx.restore();
                    }
                  }
                }
                if (isTextInputElement(container) && container.value.length) {
                  _b2 = this.createFontStyle(styles), fontFamily2 = _b2[0], fontSize2 = _b2[1];
                  baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
                  bounds = contentBox(container);
                  x2 = 0;
                  switch (container.styles.textAlign) {
                    case 1:
                      x2 += bounds.width / 2;
                      break;
                    case 2:
                      x2 += bounds.width;
                      break;
                  }
                  textBounds = bounds.add(x2, 0, 0, -bounds.height / 2 + 1);
                  this.ctx.save();
                  this.path([
                    new Vector(bounds.left, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top),
                    new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                    new Vector(bounds.left, bounds.top + bounds.height)
                  ]);
                  this.ctx.clip();
                  this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
                  this.ctx.restore();
                  this.ctx.textBaseline = "alphabetic";
                  this.ctx.textAlign = "left";
                }
                if (!contains(
                  container.styles.display,
                  2048
                  /* LIST_ITEM */
                )) return [3, 20];
                if (!(container.styles.listStyleImage !== null)) return [3, 19];
                img = container.styles.listStyleImage;
                if (!(img.type === 0)) return [3, 18];
                image2 = void 0;
                url = img.url;
                _c.label = 15;
              case 15:
                _c.trys.push([15, 17, , 18]);
                return [4, this.context.cache.match(url)];
              case 16:
                image2 = _c.sent();
                this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
                return [3, 18];
              case 17:
                _c.sent();
                this.context.logger.error("Error loading list-style-image " + url);
                return [3, 18];
              case 18:
                return [3, 20];
              case 19:
                if (paint.listValue && container.styles.listStyleType !== -1) {
                  fontFamily2 = this.createFontStyle(styles)[0];
                  this.ctx.font = fontFamily2;
                  this.ctx.fillStyle = asString(styles.color);
                  this.ctx.textBaseline = "middle";
                  this.ctx.textAlign = "right";
                  bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
                  this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
                  this.ctx.textBaseline = "bottom";
                  this.ctx.textAlign = "left";
                }
                _c.label = 20;
              case 20:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderStackContent = function(stack) {
        return __awaiter(this, void 0, void 0, function() {
          var _i, _a2, child, _b2, _c, child, _d, _e2, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
          return __generator(this, function(_p) {
            switch (_p.label) {
              case 0:
                if (contains(
                  stack.element.container.flags,
                  16
                  /* DEBUG_RENDER */
                )) {
                  debugger;
                }
                return [4, this.renderNodeBackgroundAndBorders(stack.element)];
              case 1:
                _p.sent();
                _i = 0, _a2 = stack.negativeZIndex;
                _p.label = 2;
              case 2:
                if (!(_i < _a2.length)) return [3, 5];
                child = _a2[_i];
                return [4, this.renderStack(child)];
              case 3:
                _p.sent();
                _p.label = 4;
              case 4:
                _i++;
                return [3, 2];
              case 5:
                return [4, this.renderNodeContent(stack.element)];
              case 6:
                _p.sent();
                _b2 = 0, _c = stack.nonInlineLevel;
                _p.label = 7;
              case 7:
                if (!(_b2 < _c.length)) return [3, 10];
                child = _c[_b2];
                return [4, this.renderNode(child)];
              case 8:
                _p.sent();
                _p.label = 9;
              case 9:
                _b2++;
                return [3, 7];
              case 10:
                _d = 0, _e2 = stack.nonPositionedFloats;
                _p.label = 11;
              case 11:
                if (!(_d < _e2.length)) return [3, 14];
                child = _e2[_d];
                return [4, this.renderStack(child)];
              case 12:
                _p.sent();
                _p.label = 13;
              case 13:
                _d++;
                return [3, 11];
              case 14:
                _f = 0, _g = stack.nonPositionedInlineLevel;
                _p.label = 15;
              case 15:
                if (!(_f < _g.length)) return [3, 18];
                child = _g[_f];
                return [4, this.renderStack(child)];
              case 16:
                _p.sent();
                _p.label = 17;
              case 17:
                _f++;
                return [3, 15];
              case 18:
                _h = 0, _j = stack.inlineLevel;
                _p.label = 19;
              case 19:
                if (!(_h < _j.length)) return [3, 22];
                child = _j[_h];
                return [4, this.renderNode(child)];
              case 20:
                _p.sent();
                _p.label = 21;
              case 21:
                _h++;
                return [3, 19];
              case 22:
                _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
                _p.label = 23;
              case 23:
                if (!(_k < _l.length)) return [3, 26];
                child = _l[_k];
                return [4, this.renderStack(child)];
              case 24:
                _p.sent();
                _p.label = 25;
              case 25:
                _k++;
                return [3, 23];
              case 26:
                _m = 0, _o = stack.positiveZIndex;
                _p.label = 27;
              case 27:
                if (!(_m < _o.length)) return [3, 30];
                child = _o[_m];
                return [4, this.renderStack(child)];
              case 28:
                _p.sent();
                _p.label = 29;
              case 29:
                _m++;
                return [3, 27];
              case 30:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.mask = function(paths) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, 0);
        this.ctx.lineTo(this.canvas.width, 0);
        this.ctx.lineTo(this.canvas.width, this.canvas.height);
        this.ctx.lineTo(0, this.canvas.height);
        this.ctx.lineTo(0, 0);
        this.formatPath(paths.slice(0).reverse());
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.path = function(paths) {
        this.ctx.beginPath();
        this.formatPath(paths);
        this.ctx.closePath();
      };
      CanvasRenderer2.prototype.formatPath = function(paths) {
        var _this = this;
        paths.forEach(function(point, index2) {
          var start = isBezierCurve(point) ? point.start : point;
          if (index2 === 0) {
            _this.ctx.moveTo(start.x, start.y);
          } else {
            _this.ctx.lineTo(start.x, start.y);
          }
          if (isBezierCurve(point)) {
            _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
          }
        });
      };
      CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
        this.path(path);
        this.ctx.fillStyle = pattern;
        this.ctx.translate(offsetX, offsetY);
        this.ctx.fill();
        this.ctx.translate(-offsetX, -offsetY);
      };
      CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
        var _a2;
        if (image2.width === width && image2.height === height) {
          return image2;
        }
        var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
        var canvas = ownerDocument.createElement("canvas");
        canvas.width = Math.max(1, width);
        canvas.height = Math.max(1, height);
        var ctx = canvas.getContext("2d");
        ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
        return canvas;
      };
      CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
        return __awaiter(this, void 0, void 0, function() {
          var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
          return __generator(this, function(_b2) {
            switch (_b2.label) {
              case 0:
                index2 = container.styles.backgroundImage.length - 1;
                _loop_1 = function(backgroundImage3) {
                  var image2, url, _c, path, x2, y2, width, height, pattern, _d, path, x2, y2, width, height, _e2, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x2, y2, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
                  return __generator(this, function(_h) {
                    switch (_h.label) {
                      case 0:
                        if (!(backgroundImage3.type === 0)) return [3, 5];
                        image2 = void 0;
                        url = backgroundImage3.url;
                        _h.label = 1;
                      case 1:
                        _h.trys.push([1, 3, , 4]);
                        return [4, this_1.context.cache.match(url)];
                      case 2:
                        image2 = _h.sent();
                        return [3, 4];
                      case 3:
                        _h.sent();
                        this_1.context.logger.error("Error loading background-image " + url);
                        return [3, 4];
                      case 4:
                        if (image2) {
                          _c = calculateBackgroundRendering(container, index2, [
                            image2.width,
                            image2.height,
                            image2.width / image2.height
                          ]), path = _c[0], x2 = _c[1], y2 = _c[2], width = _c[3], height = _c[4];
                          pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                          this_1.renderRepeat(path, pattern, x2, y2);
                        }
                        return [3, 6];
                      case 5:
                        if (isLinearGradient(backgroundImage3)) {
                          _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x2 = _d[1], y2 = _d[2], width = _d[3], height = _d[4];
                          _e2 = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e2[0], x0 = _e2[1], x1 = _e2[2], y0 = _e2[3], y1 = _e2[4];
                          canvas = document.createElement("canvas");
                          canvas.width = width;
                          canvas.height = height;
                          ctx = canvas.getContext("2d");
                          gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                          processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                            return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                          });
                          ctx.fillStyle = gradient_1;
                          ctx.fillRect(0, 0, width, height);
                          if (width > 0 && height > 0) {
                            pattern = this_1.ctx.createPattern(canvas, "repeat");
                            this_1.renderRepeat(path, pattern, x2, y2);
                          }
                        } else if (isRadialGradient(backgroundImage3)) {
                          _f = calculateBackgroundRendering(container, index2, [
                            null,
                            null,
                            null
                          ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                          position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                          x2 = getAbsoluteValue(position2[0], width);
                          y2 = getAbsoluteValue(position2[position2.length - 1], height);
                          _g = calculateRadius(backgroundImage3, x2, y2, width, height), rx = _g[0], ry = _g[1];
                          if (rx > 0 && ry > 0) {
                            radialGradient_1 = this_1.ctx.createRadialGradient(left + x2, top_1 + y2, 0, left + x2, top_1 + y2, rx);
                            processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                              return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                            });
                            this_1.path(path);
                            this_1.ctx.fillStyle = radialGradient_1;
                            if (rx !== ry) {
                              midX = container.bounds.left + 0.5 * container.bounds.width;
                              midY = container.bounds.top + 0.5 * container.bounds.height;
                              f2 = ry / rx;
                              invF = 1 / f2;
                              this_1.ctx.save();
                              this_1.ctx.translate(midX, midY);
                              this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                              this_1.ctx.translate(-midX, -midY);
                              this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                              this_1.ctx.restore();
                            } else {
                              this_1.ctx.fill();
                            }
                          }
                        }
                        _h.label = 6;
                      case 6:
                        index2--;
                        return [
                          2
                          /*return*/
                        ];
                    }
                  });
                };
                this_1 = this;
                _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
                _b2.label = 1;
              case 1:
                if (!(_i < _a2.length)) return [3, 4];
                backgroundImage2 = _a2[_i];
                return [5, _loop_1(backgroundImage2)];
              case 2:
                _b2.sent();
                _b2.label = 3;
              case 3:
                _i++;
                return [3, 1];
              case 4:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a2) {
            this.path(parsePathForBorder(curvePoints, side));
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
        return __awaiter(this, void 0, void 0, function() {
          var outerPaths, innerPaths;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!(width < 3)) return [3, 2];
                return [4, this.renderSolidBorder(color2, side, curvePoints)];
              case 1:
                _a2.sent();
                return [
                  2
                  /*return*/
                ];
              case 2:
                outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
                this.path(outerPaths);
                this.ctx.fillStyle = asString(color2);
                this.ctx.fill();
                innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
                this.path(innerPaths);
                this.ctx.fill();
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
        return __awaiter(this, void 0, void 0, function() {
          var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
          var _this = this;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                this.applyEffects(paint.getEffects(
                  2
                  /* BACKGROUND_BORDERS */
                ));
                styles = paint.container.styles;
                hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
                borders = [
                  { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
                  { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
                  { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
                  { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
                ];
                backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
                if (!(hasBackground || styles.boxShadow.length)) return [3, 2];
                this.ctx.save();
                this.path(backgroundPaintingArea);
                this.ctx.clip();
                if (!isTransparent(styles.backgroundColor)) {
                  this.ctx.fillStyle = asString(styles.backgroundColor);
                  this.ctx.fill();
                }
                return [4, this.renderBackgroundImage(paint.container)];
              case 1:
                _a2.sent();
                this.ctx.restore();
                styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
                  _this.ctx.save();
                  var borderBoxArea = calculateBorderBoxPath(paint.curves);
                  var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
                  var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
                  if (shadow.inset) {
                    _this.path(borderBoxArea);
                    _this.ctx.clip();
                    _this.mask(shadowPaintingArea);
                  } else {
                    _this.mask(borderBoxArea);
                    _this.ctx.clip();
                    _this.path(shadowPaintingArea);
                  }
                  _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
                  _this.ctx.shadowOffsetY = shadow.offsetY.number;
                  _this.ctx.shadowColor = asString(shadow.color);
                  _this.ctx.shadowBlur = shadow.blur.number;
                  _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
                  _this.ctx.fill();
                  _this.ctx.restore();
                });
                _a2.label = 2;
              case 2:
                side = 0;
                _i = 0, borders_1 = borders;
                _a2.label = 3;
              case 3:
                if (!(_i < borders_1.length)) return [3, 13];
                border = borders_1[_i];
                if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0)) return [3, 11];
                if (!(border.style === 2)) return [3, 5];
                return [4, this.renderDashedDottedBorder(
                  border.color,
                  border.width,
                  side,
                  paint.curves,
                  2
                  /* DASHED */
                )];
              case 4:
                _a2.sent();
                return [3, 11];
              case 5:
                if (!(border.style === 3)) return [3, 7];
                return [4, this.renderDashedDottedBorder(
                  border.color,
                  border.width,
                  side,
                  paint.curves,
                  3
                  /* DOTTED */
                )];
              case 6:
                _a2.sent();
                return [3, 11];
              case 7:
                if (!(border.style === 4)) return [3, 9];
                return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
              case 8:
                _a2.sent();
                return [3, 11];
              case 9:
                return [4, this.renderSolidBorder(border.color, side, paint.curves)];
              case 10:
                _a2.sent();
                _a2.label = 11;
              case 11:
                side++;
                _a2.label = 12;
              case 12:
                _i++;
                return [3, 3];
              case 13:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      };
      CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
        return __awaiter(this, void 0, void 0, function() {
          var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
          return __generator(this, function(_a2) {
            this.ctx.save();
            strokePaths = parsePathForBorderStroke(curvePoints, side);
            boxPaths = parsePathForBorder(curvePoints, side);
            if (style === 2) {
              this.path(boxPaths);
              this.ctx.clip();
            }
            if (isBezierCurve(boxPaths[0])) {
              startX = boxPaths[0].start.x;
              startY = boxPaths[0].start.y;
            } else {
              startX = boxPaths[0].x;
              startY = boxPaths[0].y;
            }
            if (isBezierCurve(boxPaths[1])) {
              endX = boxPaths[1].end.x;
              endY = boxPaths[1].end.y;
            } else {
              endX = boxPaths[1].x;
              endY = boxPaths[1].y;
            }
            if (side === 0 || side === 2) {
              length = Math.abs(startX - endX);
            } else {
              length = Math.abs(startY - endY);
            }
            this.ctx.beginPath();
            if (style === 3) {
              this.formatPath(strokePaths);
            } else {
              this.formatPath(boxPaths.slice(0, 2));
            }
            dashLength = width < 3 ? width * 3 : width * 2;
            spaceLength = width < 3 ? width * 2 : width;
            if (style === 3) {
              dashLength = width;
              spaceLength = width;
            }
            useLineDash = true;
            if (length <= dashLength * 2) {
              useLineDash = false;
            } else if (length <= dashLength * 2 + spaceLength) {
              multiplier = length / (2 * dashLength + spaceLength);
              dashLength *= multiplier;
              spaceLength *= multiplier;
            } else {
              numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
              minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
              maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
              spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
            }
            if (useLineDash) {
              if (style === 3) {
                this.ctx.setLineDash([0, dashLength + spaceLength]);
              } else {
                this.ctx.setLineDash([dashLength, spaceLength]);
              }
            }
            if (style === 3) {
              this.ctx.lineCap = "round";
              this.ctx.lineWidth = width;
            } else {
              this.ctx.lineWidth = width * 2 + 1.1;
            }
            this.ctx.strokeStyle = asString(color2);
            this.ctx.stroke();
            this.ctx.setLineDash([]);
            if (style === 2) {
              if (isBezierCurve(boxPaths[0])) {
                path1 = boxPaths[3];
                path2 = boxPaths[0];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
              if (isBezierCurve(boxPaths[1])) {
                path1 = boxPaths[1];
                path2 = boxPaths[2];
                this.ctx.beginPath();
                this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
                this.ctx.stroke();
              }
            }
            this.ctx.restore();
            return [
              2
              /*return*/
            ];
          });
        });
      };
      CanvasRenderer2.prototype.render = function(element) {
        return __awaiter(this, void 0, void 0, function() {
          var stack;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
                }
                stack = parseStackingContexts(element);
                return [4, this.renderStack(stack)];
              case 1:
                _a2.sent();
                this.applyEffects([]);
                return [2, this.canvas];
            }
          });
        });
      };
      return CanvasRenderer2;
    })(Renderer)
  );
  var isTextInputElement = function(container) {
    if (container instanceof TextareaElementContainer) {
      return true;
    } else if (container instanceof SelectElementContainer) {
      return true;
    } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
      return true;
    }
    return false;
  };
  var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
    switch (clip) {
      case 0:
        return calculateBorderBoxPath(curves);
      case 2:
        return calculateContentBoxPath(curves);
      case 1:
      default:
        return calculatePaddingBoxPath(curves);
    }
  };
  var canvasTextAlign = function(textAlign2) {
    switch (textAlign2) {
      case 1:
        return "center";
      case 2:
        return "right";
      case 0:
      default:
        return "left";
    }
  };
  var iOSBrokenFonts = ["-apple-system", "system-ui"];
  var fixIOSSystemFonts = function(fontFamilies) {
    return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
      return iOSBrokenFonts.indexOf(fontFamily2) === -1;
    }) : fontFamilies;
  };
  var ForeignObjectRenderer = (
    /** @class */
    (function(_super) {
      __extends(ForeignObjectRenderer2, _super);
      function ForeignObjectRenderer2(context, options) {
        var _this = _super.call(this, context, options) || this;
        _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
        _this.ctx = _this.canvas.getContext("2d");
        _this.options = options;
        _this.canvas.width = Math.floor(options.width * options.scale);
        _this.canvas.height = Math.floor(options.height * options.scale);
        _this.canvas.style.width = options.width + "px";
        _this.canvas.style.height = options.height + "px";
        _this.ctx.scale(_this.options.scale, _this.options.scale);
        _this.ctx.translate(-options.x, -options.y);
        _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
        return _this;
      }
      ForeignObjectRenderer2.prototype.render = function(element) {
        return __awaiter(this, void 0, void 0, function() {
          var svg2, img;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                svg2 = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
                return [4, loadSerializedSVG(svg2)];
              case 1:
                img = _a2.sent();
                if (this.options.backgroundColor) {
                  this.ctx.fillStyle = asString(this.options.backgroundColor);
                  this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
                }
                this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
                return [2, this.canvas];
            }
          });
        });
      };
      return ForeignObjectRenderer2;
    })(Renderer)
  );
  var loadSerializedSVG = function(svg2) {
    return new Promise(function(resolve, reject) {
      var img = new Image();
      img.onload = function() {
        resolve(img);
      };
      img.onerror = reject;
      img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg2));
    });
  };
  var Logger = (
    /** @class */
    (function() {
      function Logger2(_a2) {
        var id = _a2.id, enabled = _a2.enabled;
        this.id = id;
        this.enabled = enabled;
        this.start = Date.now();
      }
      Logger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
            console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.getTime = function() {
        return Date.now() - this.start;
      };
      Logger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
            console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          }
        }
      };
      Logger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
            console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (this.enabled) {
          if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
            console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
          } else {
            this.info.apply(this, args);
          }
        }
      };
      Logger2.instances = {};
      return Logger2;
    })()
  );
  var Context = (
    /** @class */
    (function() {
      function Context2(options, windowBounds) {
        var _a2;
        this.windowBounds = windowBounds;
        this.instanceName = "#" + Context2.instanceCount++;
        this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
        this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
      }
      Context2.instanceCount = 1;
      return Context2;
    })()
  );
  var html2canvas = function(element, options) {
    if (options === void 0) {
      options = {};
    }
    return renderElement(element, options);
  };
  if (typeof window !== "undefined") {
    CacheStorage.setContext(window);
  }
  var renderElement = function(element, opts) {
    return __awaiter(void 0, void 0, void 0, function() {
      var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
      var _b2, _c, _d, _e2, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t2;
      return __generator(this, function(_u) {
        switch (_u.label) {
          case 0:
            if (!element || typeof element !== "object") {
              return [2, Promise.reject("Invalid element provided as first argument")];
            }
            ownerDocument = element.ownerDocument;
            if (!ownerDocument) {
              throw new Error("Element is not attached to a Document");
            }
            defaultView = ownerDocument.defaultView;
            if (!defaultView) {
              throw new Error("Document is not attached to a Window");
            }
            resourceOptions = {
              allowTaint: (_b2 = opts.allowTaint) !== null && _b2 !== void 0 ? _b2 : false,
              imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
              proxy: opts.proxy,
              useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
            };
            contextOptions = __assign({ logging: (_e2 = opts.logging) !== null && _e2 !== void 0 ? _e2 : true, cache: opts.cache }, resourceOptions);
            windowOptions = {
              windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
              windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
              scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
              scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
            };
            windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
            context = new Context(contextOptions, windowBounds);
            foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
            cloneOptions = {
              allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
              onclone: opts.onclone,
              ignoreElements: opts.ignoreElements,
              inlineImages: foreignObjectRendering,
              copyStyles: foreignObjectRendering
            };
            context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
            documentCloner = new DocumentCloner(context, element, cloneOptions);
            clonedElement = documentCloner.clonedReferenceElement;
            if (!clonedElement) {
              return [2, Promise.reject("Unable to find element in cloned iframe")];
            }
            return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
          case 1:
            container = _u.sent();
            _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
            backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
            renderOptions = {
              canvas: opts.canvas,
              backgroundColor: backgroundColor2,
              scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
              x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
              y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
              width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
              height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
            };
            if (!foreignObjectRendering) return [3, 3];
            context.logger.debug("Document cloned, using foreign object rendering");
            renderer = new ForeignObjectRenderer(context, renderOptions);
            return [4, renderer.render(clonedElement)];
          case 2:
            canvas = _u.sent();
            return [3, 5];
          case 3:
            context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
            context.logger.debug("Starting DOM parsing");
            root = parseTree(context, clonedElement);
            if (backgroundColor2 === root.styles.backgroundColor) {
              root.styles.backgroundColor = COLORS.TRANSPARENT;
            }
            context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
            renderer = new CanvasRenderer(context, renderOptions);
            return [4, renderer.render(root)];
          case 4:
            canvas = _u.sent();
            _u.label = 5;
          case 5:
            if ((_t2 = opts.removeContainer) !== null && _t2 !== void 0 ? _t2 : true) {
              if (!DocumentCloner.destroy(container)) {
                context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
              }
            }
            context.logger.debug("Finished rendering");
            return [2, canvas];
        }
      });
    });
  };
  var parseBackgroundColor = function(context, element, backgroundColorOverride) {
    var ownerDocument = element.ownerDocument;
    var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
    var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
    var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
    return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
  };
  const html2canvas_esm = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: html2canvas
  }, Symbol.toStringTag, { value: "Module" }));
  /*! @license DOMPurify 3.3.1 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.3.1/LICENSE */
  const {
    entries,
    setPrototypeOf,
    isFrozen,
    getPrototypeOf,
    getOwnPropertyDescriptor
  } = Object;
  let {
    freeze,
    seal,
    create
  } = Object;
  let {
    apply,
    construct
  } = typeof Reflect !== "undefined" && Reflect;
  if (!freeze) {
    freeze = function freeze2(x2) {
      return x2;
    };
  }
  if (!seal) {
    seal = function seal2(x2) {
      return x2;
    };
  }
  if (!apply) {
    apply = function apply2(func, thisArg) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }
      return func.apply(thisArg, args);
    };
  }
  if (!construct) {
    construct = function construct2(Func) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }
      return new Func(...args);
    };
  }
  const arrayForEach = unapply(Array.prototype.forEach);
  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
  const arrayPop = unapply(Array.prototype.pop);
  const arrayPush = unapply(Array.prototype.push);
  const arraySplice = unapply(Array.prototype.splice);
  const stringToLowerCase = unapply(String.prototype.toLowerCase);
  const stringToString = unapply(String.prototype.toString);
  const stringMatch = unapply(String.prototype.match);
  const stringReplace = unapply(String.prototype.replace);
  const stringIndexOf = unapply(String.prototype.indexOf);
  const stringTrim = unapply(String.prototype.trim);
  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
  const regExpTest = unapply(RegExp.prototype.test);
  const typeErrorCreate = unconstruct(TypeError);
  function unapply(func) {
    return function(thisArg) {
      if (thisArg instanceof RegExp) {
        thisArg.lastIndex = 0;
      }
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      return apply(func, thisArg, args);
    };
  }
  function unconstruct(Func) {
    return function() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return construct(Func, args);
    };
  }
  function addToSet(set, array) {
    let transformCaseFunc = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : stringToLowerCase;
    if (setPrototypeOf) {
      setPrototypeOf(set, null);
    }
    let l2 = array.length;
    while (l2--) {
      let element = array[l2];
      if (typeof element === "string") {
        const lcElement = transformCaseFunc(element);
        if (lcElement !== element) {
          if (!isFrozen(array)) {
            array[l2] = lcElement;
          }
          element = lcElement;
        }
      }
      set[element] = true;
    }
    return set;
  }
  function cleanArray(array) {
    for (let index2 = 0; index2 < array.length; index2++) {
      const isPropertyExist = objectHasOwnProperty(array, index2);
      if (!isPropertyExist) {
        array[index2] = null;
      }
    }
    return array;
  }
  function clone(object) {
    const newObject = create(null);
    for (const [property, value] of entries(object)) {
      const isPropertyExist = objectHasOwnProperty(object, property);
      if (isPropertyExist) {
        if (Array.isArray(value)) {
          newObject[property] = cleanArray(value);
        } else if (value && typeof value === "object" && value.constructor === Object) {
          newObject[property] = clone(value);
        } else {
          newObject[property] = value;
        }
      }
    }
    return newObject;
  }
  function lookupGetter(object, prop) {
    while (object !== null) {
      const desc = getOwnPropertyDescriptor(object, prop);
      if (desc) {
        if (desc.get) {
          return unapply(desc.get);
        }
        if (typeof desc.value === "function") {
          return unapply(desc.value);
        }
      }
      object = getPrototypeOf(object);
    }
    function fallbackValue() {
      return null;
    }
    return fallbackValue;
  }
  const html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "search", "section", "select", "shadow", "slot", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
  const svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "enterkeyhint", "exportparts", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "inputmode", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "part", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
  const svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
  const svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
  const mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]);
  const mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
  const text = freeze(["#text"]);
  const html = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "exportparts", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inert", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "part", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "slot", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]);
  const svg = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "mask-type", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
  const mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
  const xml = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
  const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
  const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
  const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm);
  const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/);
  const ARIA_ATTR = seal(/^aria-[\-\w]+$/);
  const IS_ALLOWED_URI = seal(
    /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
    // eslint-disable-line no-useless-escape
  );
  const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
  const ATTR_WHITESPACE = seal(
    /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
    // eslint-disable-line no-control-regex
  );
  const DOCTYPE_NAME = seal(/^html$/i);
  const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);
  var EXPRESSIONS = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    ARIA_ATTR,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT,
    DATA_ATTR,
    DOCTYPE_NAME,
    ERB_EXPR,
    IS_ALLOWED_URI,
    IS_SCRIPT_OR_DATA,
    MUSTACHE_EXPR,
    TMPLIT_EXPR
  });
  const NODE_TYPE = {
    element: 1,
    text: 3,
    // Deprecated
    progressingInstruction: 7,
    comment: 8,
    document: 9
  };
  const getGlobal = function getGlobal2() {
    return typeof window === "undefined" ? null : window;
  };
  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, purifyHostElement) {
    if (typeof trustedTypes !== "object" || typeof trustedTypes.createPolicy !== "function") {
      return null;
    }
    let suffix = null;
    const ATTR_NAME = "data-tt-policy-suffix";
    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
      suffix = purifyHostElement.getAttribute(ATTR_NAME);
    }
    const policyName = "dompurify" + (suffix ? "#" + suffix : "");
    try {
      return trustedTypes.createPolicy(policyName, {
        createHTML(html2) {
          return html2;
        },
        createScriptURL(scriptUrl) {
          return scriptUrl;
        }
      });
    } catch (_2) {
      console.warn("TrustedTypes policy " + policyName + " could not be created.");
      return null;
    }
  };
  const _createHooksMap = function _createHooksMap2() {
    return {
      afterSanitizeAttributes: [],
      afterSanitizeElements: [],
      afterSanitizeShadowDOM: [],
      beforeSanitizeAttributes: [],
      beforeSanitizeElements: [],
      beforeSanitizeShadowDOM: [],
      uponSanitizeAttribute: [],
      uponSanitizeElement: [],
      uponSanitizeShadowNode: []
    };
  };
  function createDOMPurify() {
    let window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
    const DOMPurify = (root) => createDOMPurify(root);
    DOMPurify.version = "3.3.1";
    DOMPurify.removed = [];
    if (!window2 || !window2.document || window2.document.nodeType !== NODE_TYPE.document || !window2.Element) {
      DOMPurify.isSupported = false;
      return DOMPurify;
    }
    let {
      document: document2
    } = window2;
    const originalDocument = document2;
    const currentScript = originalDocument.currentScript;
    const {
      DocumentFragment,
      HTMLTemplateElement,
      Node: Node2,
      Element: Element2,
      NodeFilter: NodeFilter2,
      NamedNodeMap = window2.NamedNodeMap || window2.MozNamedAttrMap,
      HTMLFormElement,
      DOMParser: DOMParser2,
      trustedTypes
    } = window2;
    const ElementPrototype = Element2.prototype;
    const cloneNode = lookupGetter(ElementPrototype, "cloneNode");
    const remove = lookupGetter(ElementPrototype, "remove");
    const getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
    const getChildNodes = lookupGetter(ElementPrototype, "childNodes");
    const getParentNode = lookupGetter(ElementPrototype, "parentNode");
    if (typeof HTMLTemplateElement === "function") {
      const template = document2.createElement("template");
      if (template.content && template.content.ownerDocument) {
        document2 = template.content.ownerDocument;
      }
    }
    let trustedTypesPolicy;
    let emptyHTML = "";
    const {
      implementation,
      createNodeIterator,
      createDocumentFragment,
      getElementsByTagName
    } = document2;
    const {
      importNode
    } = originalDocument;
    let hooks = _createHooksMap();
    DOMPurify.isSupported = typeof entries === "function" && typeof getParentNode === "function" && implementation && implementation.createHTMLDocument !== void 0;
    const {
      MUSTACHE_EXPR: MUSTACHE_EXPR2,
      ERB_EXPR: ERB_EXPR2,
      TMPLIT_EXPR: TMPLIT_EXPR2,
      DATA_ATTR: DATA_ATTR2,
      ARIA_ATTR: ARIA_ATTR2,
      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA2,
      ATTR_WHITESPACE: ATTR_WHITESPACE2,
      CUSTOM_ELEMENT: CUSTOM_ELEMENT2
    } = EXPRESSIONS;
    let {
      IS_ALLOWED_URI: IS_ALLOWED_URI$1
    } = EXPRESSIONS;
    let ALLOWED_TAGS = null;
    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);
    let ALLOWED_ATTR = null;
    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {
      tagNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeNameCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      allowCustomizedBuiltInElements: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: false
      }
    }));
    let FORBID_TAGS = null;
    let FORBID_ATTR = null;
    const EXTRA_ELEMENT_HANDLING = Object.seal(create(null, {
      tagCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      },
      attributeCheck: {
        writable: true,
        configurable: false,
        enumerable: true,
        value: null
      }
    }));
    let ALLOW_ARIA_ATTR = true;
    let ALLOW_DATA_ATTR = true;
    let ALLOW_UNKNOWN_PROTOCOLS = false;
    let ALLOW_SELF_CLOSE_IN_ATTR = true;
    let SAFE_FOR_TEMPLATES = false;
    let SAFE_FOR_XML = true;
    let WHOLE_DOCUMENT = false;
    let SET_CONFIG = false;
    let FORCE_BODY = false;
    let RETURN_DOM = false;
    let RETURN_DOM_FRAGMENT = false;
    let RETURN_TRUSTED_TYPE = false;
    let SANITIZE_DOM = true;
    let SANITIZE_NAMED_PROPS = false;
    const SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
    let KEEP_CONTENT = true;
    let IN_PLACE = false;
    let USE_PROFILES = {};
    let FORBID_CONTENTS = null;
    const DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
    let DATA_URI_TAGS = null;
    const DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
    let URI_SAFE_ATTRIBUTES = null;
    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
    const MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
    const SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    const HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
    let NAMESPACE = HTML_NAMESPACE;
    let IS_EMPTY_INPUT = false;
    let ALLOWED_NAMESPACES = null;
    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
    let HTML_INTEGRATION_POINTS = addToSet({}, ["annotation-xml"]);
    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
    let PARSER_MEDIA_TYPE = null;
    const SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
    const DEFAULT_PARSER_MEDIA_TYPE = "text/html";
    let transformCaseFunc = null;
    let CONFIG = null;
    const formElement = document2.createElement("form");
    const isRegexOrFunction = function isRegexOrFunction2(testValue) {
      return testValue instanceof RegExp || testValue instanceof Function;
    };
    const _parseConfig = function _parseConfig2() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (CONFIG && CONFIG === cfg) {
        return;
      }
      if (!cfg || typeof cfg !== "object") {
        cfg = {};
      }
      cfg = clone(cfg);
      PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes
      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
      transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? stringToString : stringToLowerCase;
      ALLOWED_TAGS = objectHasOwnProperty(cfg, "ALLOWED_TAGS") ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
      ALLOWED_ATTR = objectHasOwnProperty(cfg, "ALLOWED_ATTR") ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, "ALLOWED_NAMESPACES") ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, "ADD_URI_SAFE_ATTR") ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
      DATA_URI_TAGS = objectHasOwnProperty(cfg, "ADD_DATA_URI_TAGS") ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
      FORBID_CONTENTS = objectHasOwnProperty(cfg, "FORBID_CONTENTS") ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
      FORBID_TAGS = objectHasOwnProperty(cfg, "FORBID_TAGS") ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
      FORBID_ATTR = objectHasOwnProperty(cfg, "FORBID_ATTR") ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
      USE_PROFILES = objectHasOwnProperty(cfg, "USE_PROFILES") ? cfg.USE_PROFILES : false;
      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;
      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false;
      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
      RETURN_DOM = cfg.RETURN_DOM || false;
      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
      FORCE_BODY = cfg.FORCE_BODY || false;
      SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
      KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
      IN_PLACE = cfg.IN_PLACE || false;
      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
      }
      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
      }
      if (SAFE_FOR_TEMPLATES) {
        ALLOW_DATA_ATTR = false;
      }
      if (RETURN_DOM_FRAGMENT) {
        RETURN_DOM = true;
      }
      if (USE_PROFILES) {
        ALLOWED_TAGS = addToSet({}, text);
        ALLOWED_ATTR = [];
        if (USE_PROFILES.html === true) {
          addToSet(ALLOWED_TAGS, html$1);
          addToSet(ALLOWED_ATTR, html);
        }
        if (USE_PROFILES.svg === true) {
          addToSet(ALLOWED_TAGS, svg$1);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.svgFilters === true) {
          addToSet(ALLOWED_TAGS, svgFilters);
          addToSet(ALLOWED_ATTR, svg);
          addToSet(ALLOWED_ATTR, xml);
        }
        if (USE_PROFILES.mathMl === true) {
          addToSet(ALLOWED_TAGS, mathMl$1);
          addToSet(ALLOWED_ATTR, mathMl);
          addToSet(ALLOWED_ATTR, xml);
        }
      }
      if (cfg.ADD_TAGS) {
        if (typeof cfg.ADD_TAGS === "function") {
          EXTRA_ELEMENT_HANDLING.tagCheck = cfg.ADD_TAGS;
        } else {
          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
            ALLOWED_TAGS = clone(ALLOWED_TAGS);
          }
          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
        }
      }
      if (cfg.ADD_ATTR) {
        if (typeof cfg.ADD_ATTR === "function") {
          EXTRA_ELEMENT_HANDLING.attributeCheck = cfg.ADD_ATTR;
        } else {
          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
            ALLOWED_ATTR = clone(ALLOWED_ATTR);
          }
          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
        }
      }
      if (cfg.ADD_URI_SAFE_ATTR) {
        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
      }
      if (cfg.FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
      }
      if (cfg.ADD_FORBID_CONTENTS) {
        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
          FORBID_CONTENTS = clone(FORBID_CONTENTS);
        }
        addToSet(FORBID_CONTENTS, cfg.ADD_FORBID_CONTENTS, transformCaseFunc);
      }
      if (KEEP_CONTENT) {
        ALLOWED_TAGS["#text"] = true;
      }
      if (WHOLE_DOCUMENT) {
        addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
      }
      if (ALLOWED_TAGS.table) {
        addToSet(ALLOWED_TAGS, ["tbody"]);
        delete FORBID_TAGS.tbody;
      }
      if (cfg.TRUSTED_TYPES_POLICY) {
        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
        }
        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== "function") {
          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
        }
        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
        emptyHTML = trustedTypesPolicy.createHTML("");
      } else {
        if (trustedTypesPolicy === void 0) {
          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
        }
        if (trustedTypesPolicy !== null && typeof emptyHTML === "string") {
          emptyHTML = trustedTypesPolicy.createHTML("");
        }
      }
      if (freeze) {
        freeze(cfg);
      }
      CONFIG = cfg;
    };
    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
    const _checkValidNamespace = function _checkValidNamespace2(element) {
      let parent = getParentNode(element);
      if (!parent || !parent.tagName) {
        parent = {
          namespaceURI: NAMESPACE,
          tagName: "template"
        };
      }
      const tagName = stringToLowerCase(element.tagName);
      const parentTagName = stringToLowerCase(parent.tagName);
      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
        return false;
      }
      if (element.namespaceURI === SVG_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "svg";
        }
        if (parent.namespaceURI === MATHML_NAMESPACE) {
          return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
        }
        return Boolean(ALL_SVG_TAGS[tagName]);
      }
      if (element.namespaceURI === MATHML_NAMESPACE) {
        if (parent.namespaceURI === HTML_NAMESPACE) {
          return tagName === "math";
        }
        if (parent.namespaceURI === SVG_NAMESPACE) {
          return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
        }
        return Boolean(ALL_MATHML_TAGS[tagName]);
      }
      if (element.namespaceURI === HTML_NAMESPACE) {
        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
          return false;
        }
        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && ALLOWED_NAMESPACES[element.namespaceURI]) {
        return true;
      }
      return false;
    };
    const _forceRemove = function _forceRemove2(node2) {
      arrayPush(DOMPurify.removed, {
        element: node2
      });
      try {
        getParentNode(node2).removeChild(node2);
      } catch (_2) {
        remove(node2);
      }
    };
    const _removeAttribute = function _removeAttribute2(name, element) {
      try {
        arrayPush(DOMPurify.removed, {
          attribute: element.getAttributeNode(name),
          from: element
        });
      } catch (_2) {
        arrayPush(DOMPurify.removed, {
          attribute: null,
          from: element
        });
      }
      element.removeAttribute(name);
      if (name === "is") {
        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
          try {
            _forceRemove(element);
          } catch (_2) {
          }
        } else {
          try {
            element.setAttribute(name, "");
          } catch (_2) {
          }
        }
      }
    };
    const _initDocument = function _initDocument2(dirty) {
      let doc = null;
      let leadingWhitespace = null;
      if (FORCE_BODY) {
        dirty = "<remove></remove>" + dirty;
      } else {
        const matches = stringMatch(dirty, /^[\r\n\t ]+/);
        leadingWhitespace = matches && matches[0];
      }
      if (PARSER_MEDIA_TYPE === "application/xhtml+xml" && NAMESPACE === HTML_NAMESPACE) {
        dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
      }
      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
      if (NAMESPACE === HTML_NAMESPACE) {
        try {
          doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
        } catch (_2) {
        }
      }
      if (!doc || !doc.documentElement) {
        doc = implementation.createDocument(NAMESPACE, "template", null);
        try {
          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
        } catch (_2) {
        }
      }
      const body = doc.body || doc.documentElement;
      if (dirty && leadingWhitespace) {
        body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
      }
      if (NAMESPACE === HTML_NAMESPACE) {
        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
      }
      return WHOLE_DOCUMENT ? doc.documentElement : body;
    };
    const _createNodeIterator = function _createNodeIterator2(root) {
      return createNodeIterator.call(
        root.ownerDocument || root,
        root,
        // eslint-disable-next-line no-bitwise
        NodeFilter2.SHOW_ELEMENT | NodeFilter2.SHOW_COMMENT | NodeFilter2.SHOW_TEXT | NodeFilter2.SHOW_PROCESSING_INSTRUCTION | NodeFilter2.SHOW_CDATA_SECTION,
        null
      );
    };
    const _isClobbered = function _isClobbered2(element) {
      return element instanceof HTMLFormElement && (typeof element.nodeName !== "string" || typeof element.textContent !== "string" || typeof element.removeChild !== "function" || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== "function" || typeof element.setAttribute !== "function" || typeof element.namespaceURI !== "string" || typeof element.insertBefore !== "function" || typeof element.hasChildNodes !== "function");
    };
    const _isNode = function _isNode2(value) {
      return typeof Node2 === "function" && value instanceof Node2;
    };
    function _executeHooks(hooks2, currentNode, data) {
      arrayForEach(hooks2, (hook) => {
        hook.call(DOMPurify, currentNode, data, CONFIG);
      });
    }
    const _sanitizeElements = function _sanitizeElements2(currentNode) {
      let content2 = null;
      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
      if (_isClobbered(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      const tagName = transformCaseFunc(currentNode.nodeName);
      _executeHooks(hooks.uponSanitizeElement, currentNode, {
        tagName,
        allowedTags: ALLOWED_TAGS
      });
      if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
        _forceRemove(currentNode);
        return true;
      }
      if (!(EXTRA_ELEMENT_HANDLING.tagCheck instanceof Function && EXTRA_ELEMENT_HANDLING.tagCheck(tagName)) && (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName])) {
        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
            return false;
          }
          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
            return false;
          }
        }
        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
          const parentNode = getParentNode(currentNode) || currentNode.parentNode;
          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
          if (childNodes && parentNode) {
            const childCount = childNodes.length;
            for (let i2 = childCount - 1; i2 >= 0; --i2) {
              const childClone = cloneNode(childNodes[i2], true);
              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
              parentNode.insertBefore(childClone, getNextSibling(currentNode));
            }
          }
        }
        _forceRemove(currentNode);
        return true;
      }
      if (currentNode instanceof Element2 && !_checkValidNamespace(currentNode)) {
        _forceRemove(currentNode);
        return true;
      }
      if ((tagName === "noscript" || tagName === "noembed" || tagName === "noframes") && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
        _forceRemove(currentNode);
        return true;
      }
      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
        content2 = currentNode.textContent;
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          content2 = stringReplace(content2, expr, " ");
        });
        if (currentNode.textContent !== content2) {
          arrayPush(DOMPurify.removed, {
            element: currentNode.cloneNode()
          });
          currentNode.textContent = content2;
        }
      }
      _executeHooks(hooks.afterSanitizeElements, currentNode, null);
      return false;
    };
    const _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
      if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
        return false;
      }
      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR2, lcName)) ;
      else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR2, lcName)) ;
      else if (EXTRA_ELEMENT_HANDLING.attributeCheck instanceof Function && EXTRA_ELEMENT_HANDLING.attributeCheck(lcName, lcTag)) ;
      else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
        if (
          // First condition does a very basic check if a) it's basically a valid custom element tagname AND
          // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
          _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName, lcTag)) || // Alternative, second condition checks if it's an `is`-attribute, AND
          // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
          lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))
        ) ;
        else {
          return false;
        }
      } else if (URI_SAFE_ATTRIBUTES[lcName]) ;
      else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag]) ;
      else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA2, stringReplace(value, ATTR_WHITESPACE2, ""))) ;
      else if (value) {
        return false;
      } else ;
      return true;
    };
    const _isBasicCustomElement = function _isBasicCustomElement2(tagName) {
      return tagName !== "annotation-xml" && stringMatch(tagName, CUSTOM_ELEMENT2);
    };
    const _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
      const {
        attributes
      } = currentNode;
      if (!attributes || _isClobbered(currentNode)) {
        return;
      }
      const hookEvent = {
        attrName: "",
        attrValue: "",
        keepAttr: true,
        allowedAttributes: ALLOWED_ATTR,
        forceKeepAttr: void 0
      };
      let l2 = attributes.length;
      while (l2--) {
        const attr = attributes[l2];
        const {
          name,
          namespaceURI,
          value: attrValue
        } = attr;
        const lcName = transformCaseFunc(name);
        const initValue = attrValue;
        let value = name === "value" ? initValue : stringTrim(initValue);
        hookEvent.attrName = lcName;
        hookEvent.attrValue = value;
        hookEvent.keepAttr = true;
        hookEvent.forceKeepAttr = void 0;
        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
        value = hookEvent.attrValue;
        if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
          _removeAttribute(name, currentNode);
          value = SANITIZE_NAMED_PROPS_PREFIX + value;
        }
        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title|textarea)/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (lcName === "attributename" && stringMatch(value, "href")) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (hookEvent.forceKeepAttr) {
          continue;
        }
        if (!hookEvent.keepAttr) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (SAFE_FOR_TEMPLATES) {
          arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
            value = stringReplace(value, expr, " ");
          });
        }
        const lcTag = transformCaseFunc(currentNode.nodeName);
        if (!_isValidAttribute(lcTag, lcName, value)) {
          _removeAttribute(name, currentNode);
          continue;
        }
        if (trustedTypesPolicy && typeof trustedTypes === "object" && typeof trustedTypes.getAttributeType === "function") {
          if (namespaceURI) ;
          else {
            switch (trustedTypes.getAttributeType(lcTag, lcName)) {
              case "TrustedHTML": {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
              case "TrustedScriptURL": {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
            }
          }
        }
        if (value !== initValue) {
          try {
            if (namespaceURI) {
              currentNode.setAttributeNS(namespaceURI, name, value);
            } else {
              currentNode.setAttribute(name, value);
            }
            if (_isClobbered(currentNode)) {
              _forceRemove(currentNode);
            } else {
              arrayPop(DOMPurify.removed);
            }
          } catch (_2) {
            _removeAttribute(name, currentNode);
          }
        }
      }
      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
    };
    const _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
      let shadowNode = null;
      const shadowIterator = _createNodeIterator(fragment);
      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
      while (shadowNode = shadowIterator.nextNode()) {
        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
        _sanitizeElements(shadowNode);
        _sanitizeAttributes(shadowNode);
        if (shadowNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM2(shadowNode.content);
        }
      }
      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
    };
    DOMPurify.sanitize = function(dirty) {
      let cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let body = null;
      let importedNode = null;
      let currentNode = null;
      let returnNode = null;
      IS_EMPTY_INPUT = !dirty;
      if (IS_EMPTY_INPUT) {
        dirty = "<!-->";
      }
      if (typeof dirty !== "string" && !_isNode(dirty)) {
        if (typeof dirty.toString === "function") {
          dirty = dirty.toString();
          if (typeof dirty !== "string") {
            throw typeErrorCreate("dirty is not a string, aborting");
          }
        } else {
          throw typeErrorCreate("toString is not a function");
        }
      }
      if (!DOMPurify.isSupported) {
        return dirty;
      }
      if (!SET_CONFIG) {
        _parseConfig(cfg);
      }
      DOMPurify.removed = [];
      if (typeof dirty === "string") {
        IN_PLACE = false;
      }
      if (IN_PLACE) {
        if (dirty.nodeName) {
          const tagName = transformCaseFunc(dirty.nodeName);
          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
            throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
          }
        }
      } else if (dirty instanceof Node2) {
        body = _initDocument("<!---->");
        importedNode = body.ownerDocument.importNode(dirty, true);
        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === "BODY") {
          body = importedNode;
        } else if (importedNode.nodeName === "HTML") {
          body = importedNode;
        } else {
          body.appendChild(importedNode);
        }
      } else {
        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes
        dirty.indexOf("<") === -1) {
          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
        }
        body = _initDocument(dirty);
        if (!body) {
          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
        }
      }
      if (body && FORCE_BODY) {
        _forceRemove(body.firstChild);
      }
      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
      while (currentNode = nodeIterator.nextNode()) {
        _sanitizeElements(currentNode);
        _sanitizeAttributes(currentNode);
        if (currentNode.content instanceof DocumentFragment) {
          _sanitizeShadowDOM(currentNode.content);
        }
      }
      if (IN_PLACE) {
        return dirty;
      }
      if (RETURN_DOM) {
        if (RETURN_DOM_FRAGMENT) {
          returnNode = createDocumentFragment.call(body.ownerDocument);
          while (body.firstChild) {
            returnNode.appendChild(body.firstChild);
          }
        } else {
          returnNode = body;
        }
        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
          returnNode = importNode.call(originalDocument, returnNode, true);
        }
        return returnNode;
      }
      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
      if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
        serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
      }
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR2, ERB_EXPR2, TMPLIT_EXPR2], (expr) => {
          serializedHTML = stringReplace(serializedHTML, expr, " ");
        });
      }
      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
    };
    DOMPurify.setConfig = function() {
      let cfg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      _parseConfig(cfg);
      SET_CONFIG = true;
    };
    DOMPurify.clearConfig = function() {
      CONFIG = null;
      SET_CONFIG = false;
    };
    DOMPurify.isValidAttribute = function(tag, attr, value) {
      if (!CONFIG) {
        _parseConfig({});
      }
      const lcTag = transformCaseFunc(tag);
      const lcName = transformCaseFunc(attr);
      return _isValidAttribute(lcTag, lcName, value);
    };
    DOMPurify.addHook = function(entryPoint, hookFunction) {
      if (typeof hookFunction !== "function") {
        return;
      }
      arrayPush(hooks[entryPoint], hookFunction);
    };
    DOMPurify.removeHook = function(entryPoint, hookFunction) {
      if (hookFunction !== void 0) {
        const index2 = arrayLastIndexOf(hooks[entryPoint], hookFunction);
        return index2 === -1 ? void 0 : arraySplice(hooks[entryPoint], index2, 1)[0];
      }
      return arrayPop(hooks[entryPoint]);
    };
    DOMPurify.removeHooks = function(entryPoint) {
      hooks[entryPoint] = [];
    };
    DOMPurify.removeAllHooks = function() {
      hooks = _createHooksMap();
    };
    return DOMPurify;
  }
  var purify = createDOMPurify();
  const purify_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: purify
  }, Symbol.toStringTag, { value: "Module" }));
  function asyncGeneratorStep(n2, t2, e2, r2, o2, a2, c2) {
    try {
      var i2 = n2[a2](c2), u2 = i2.value;
    } catch (n3) {
      return void e2(n3);
    }
    i2.done ? t2(u2) : Promise.resolve(u2).then(r2, o2);
  }
  function _asyncToGenerator(n2) {
    return function() {
      var t2 = this, e2 = arguments;
      return new Promise(function(r2, o2) {
        var a2 = n2.apply(t2, e2);
        function _next(n3) {
          asyncGeneratorStep(a2, r2, o2, _next, _throw, "next", n3);
        }
        function _throw(n3) {
          asyncGeneratorStep(a2, r2, o2, _next, _throw, "throw", n3);
        }
        _next(void 0);
      });
    };
  }
  function toPrimitive(t2, r2) {
    if ("object" != _typeof$1(t2) || !t2) return t2;
    var e2 = t2[Symbol.toPrimitive];
    if (void 0 !== e2) {
      var i2 = e2.call(t2, r2);
      if ("object" != _typeof$1(i2)) return i2;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r2 ? String : Number)(t2);
  }
  function toPropertyKey(t2) {
    var i2 = toPrimitive(t2, "string");
    return "symbol" == _typeof$1(i2) ? i2 : i2 + "";
  }
  function _defineProperty(e2, r2, t2) {
    return (r2 = toPropertyKey(r2)) in e2 ? Object.defineProperty(e2, r2, {
      value: t2,
      enumerable: true,
      configurable: true,
      writable: true
    }) : e2[r2] = t2, e2;
  }
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var raf = { exports: {} };
  var performanceNow$1 = { exports: {} };
  var performanceNow = performanceNow$1.exports;
  var hasRequiredPerformanceNow;
  function requirePerformanceNow() {
    if (hasRequiredPerformanceNow) return performanceNow$1.exports;
    hasRequiredPerformanceNow = 1;
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;
      if (typeof performance !== "undefined" && performance !== null && performance.now) {
        performanceNow$1.exports = function() {
          return performance.now();
        };
      } else if (typeof process !== "undefined" && process !== null && process.hrtime) {
        performanceNow$1.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        performanceNow$1.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        performanceNow$1.exports = function() {
          return (/* @__PURE__ */ new Date()).getTime() - loadTime;
        };
        loadTime = (/* @__PURE__ */ new Date()).getTime();
      }
    }).call(performanceNow);
    return performanceNow$1.exports;
  }
  var hasRequiredRaf;
  function requireRaf() {
    if (hasRequiredRaf) return raf.exports;
    hasRequiredRaf = 1;
    var now = requirePerformanceNow(), root = typeof window === "undefined" ? commonjsGlobal : window, vendors = ["moz", "webkit"], suffix = "AnimationFrame", raf$1 = root["request" + suffix], caf = root["cancel" + suffix] || root["cancelRequest" + suffix];
    for (var i2 = 0; !raf$1 && i2 < vendors.length; i2++) {
      raf$1 = root[vendors[i2] + "Request" + suffix];
      caf = root[vendors[i2] + "Cancel" + suffix] || root[vendors[i2] + "CancelRequest" + suffix];
    }
    if (!raf$1 || !caf) {
      var last = 0, id = 0, queue = [], frameDuration = 1e3 / 60;
      raf$1 = function(callback) {
        if (queue.length === 0) {
          var _now = now(), next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            queue.length = 0;
            for (var i3 = 0; i3 < cp.length; i3++) {
              if (!cp[i3].cancelled) {
                try {
                  cp[i3].callback(last);
                } catch (e2) {
                  setTimeout(function() {
                    throw e2;
                  }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback,
          cancelled: false
        });
        return id;
      };
      caf = function(handle) {
        for (var i3 = 0; i3 < queue.length; i3++) {
          if (queue[i3].handle === handle) {
            queue[i3].cancelled = true;
          }
        }
      };
    }
    raf.exports = function(fn) {
      return raf$1.call(root, fn);
    };
    raf.exports.cancel = function() {
      caf.apply(root, arguments);
    };
    raf.exports.polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf$1;
      object.cancelAnimationFrame = caf;
    };
    return raf.exports;
  }
  var rafExports = requireRaf();
  const requestAnimationFrame$1 = /* @__PURE__ */ getDefaultExportFromCjs(rafExports);
  var rgbcolor;
  var hasRequiredRgbcolor;
  function requireRgbcolor() {
    if (hasRequiredRgbcolor) return rgbcolor;
    hasRequiredRgbcolor = 1;
    rgbcolor = function(color_string) {
      this.ok = false;
      this.alpha = 1;
      if (color_string.charAt(0) == "#") {
        color_string = color_string.substr(1, 6);
      }
      color_string = color_string.replace(/ /g, "");
      color_string = color_string.toLowerCase();
      var simple_colors = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "00ffff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000000",
        blanchedalmond: "ffebcd",
        blue: "0000ff",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "00ffff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dodgerblue: "1e90ff",
        feldspar: "d19275",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "ff00ff",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgrey: "d3d3d3",
        lightgreen: "90ee90",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslateblue: "8470ff",
        lightslategray: "778899",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "00ff00",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "ff00ff",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370d8",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "d87093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "ff0000",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        violetred: "d02090",
        wheat: "f5deb3",
        white: "ffffff",
        whitesmoke: "f5f5f5",
        yellow: "ffff00",
        yellowgreen: "9acd32"
      };
      color_string = simple_colors[color_string] || color_string;
      var color_defs = [
        {
          re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
          example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
          process: function(bits2) {
            return [
              parseInt(bits2[1]),
              parseInt(bits2[2]),
              parseInt(bits2[3]),
              parseFloat(bits2[4])
            ];
          }
        },
        {
          re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
          example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
          process: function(bits2) {
            return [
              parseInt(bits2[1]),
              parseInt(bits2[2]),
              parseInt(bits2[3])
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
          example: ["#00ff00", "336699"],
          process: function(bits2) {
            return [
              parseInt(bits2[1], 16),
              parseInt(bits2[2], 16),
              parseInt(bits2[3], 16)
            ];
          }
        },
        {
          re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
          example: ["#fb0", "f0f"],
          process: function(bits2) {
            return [
              parseInt(bits2[1] + bits2[1], 16),
              parseInt(bits2[2] + bits2[2], 16),
              parseInt(bits2[3] + bits2[3], 16)
            ];
          }
        }
      ];
      for (var i2 = 0; i2 < color_defs.length; i2++) {
        var re2 = color_defs[i2].re;
        var processor = color_defs[i2].process;
        var bits = re2.exec(color_string);
        if (bits) {
          var channels = processor(bits);
          this.r = channels[0];
          this.g = channels[1];
          this.b = channels[2];
          if (channels.length > 3) {
            this.alpha = channels[3];
          }
          this.ok = true;
        }
      }
      this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r;
      this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g;
      this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b;
      this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha;
      this.toRGB = function() {
        return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
      };
      this.toRGBA = function() {
        return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
      };
      this.toHex = function() {
        var r2 = this.r.toString(16);
        var g2 = this.g.toString(16);
        var b2 = this.b.toString(16);
        if (r2.length == 1) r2 = "0" + r2;
        if (g2.length == 1) g2 = "0" + g2;
        if (b2.length == 1) b2 = "0" + b2;
        return "#" + r2 + g2 + b2;
      };
      this.getHelpXML = function() {
        var examples = new Array();
        for (var i3 = 0; i3 < color_defs.length; i3++) {
          var example = color_defs[i3].example;
          for (var j2 = 0; j2 < example.length; j2++) {
            examples[examples.length] = example[j2];
          }
        }
        for (var sc in simple_colors) {
          examples[examples.length] = sc;
        }
        var xml2 = document.createElement("ul");
        xml2.setAttribute("id", "rgbcolor-examples");
        for (var i3 = 0; i3 < examples.length; i3++) {
          try {
            var list_item = document.createElement("li");
            var list_color = new RGBColor(examples[i3]);
            var example_div = document.createElement("div");
            example_div.style.cssText = "margin: 3px; border: 1px solid black; background:" + list_color.toHex() + "; color:" + list_color.toHex();
            example_div.appendChild(document.createTextNode("test"));
            var list_item_value = document.createTextNode(
              " " + examples[i3] + " -> " + list_color.toRGB() + " -> " + list_color.toHex()
            );
            list_item.appendChild(example_div);
            list_item.appendChild(list_item_value);
            xml2.appendChild(list_item);
          } catch (e2) {
          }
        }
        return xml2;
      };
    };
    return rgbcolor;
  }
  var rgbcolorExports = requireRgbcolor();
  const RGBColor$1 = /* @__PURE__ */ getDefaultExportFromCjs(rgbcolorExports);
  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.
  
    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.
  
    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  var t = function(r2, e2) {
    return (t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t2, r3) {
      t2.__proto__ = r3;
    } || function(t2, r3) {
      for (var e3 in r3) Object.prototype.hasOwnProperty.call(r3, e3) && (t2[e3] = r3[e3]);
    })(r2, e2);
  };
  function r(r2, e2) {
    if ("function" != typeof e2 && null !== e2) throw new TypeError("Class extends value " + String(e2) + " is not a constructor or null");
    function i2() {
      this.constructor = r2;
    }
    t(r2, e2), r2.prototype = null === e2 ? Object.create(e2) : (i2.prototype = e2.prototype, new i2());
  }
  function e(t2) {
    var r2 = "";
    Array.isArray(t2) || (t2 = [t2]);
    for (var e2 = 0; e2 < t2.length; e2++) {
      var i2 = t2[e2];
      if (i2.type === _.CLOSE_PATH) r2 += "z";
      else if (i2.type === _.HORIZ_LINE_TO) r2 += (i2.relative ? "h" : "H") + i2.x;
      else if (i2.type === _.VERT_LINE_TO) r2 += (i2.relative ? "v" : "V") + i2.y;
      else if (i2.type === _.MOVE_TO) r2 += (i2.relative ? "m" : "M") + i2.x + " " + i2.y;
      else if (i2.type === _.LINE_TO) r2 += (i2.relative ? "l" : "L") + i2.x + " " + i2.y;
      else if (i2.type === _.CURVE_TO) r2 += (i2.relative ? "c" : "C") + i2.x1 + " " + i2.y1 + " " + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.SMOOTH_CURVE_TO) r2 += (i2.relative ? "s" : "S") + i2.x2 + " " + i2.y2 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.QUAD_TO) r2 += (i2.relative ? "q" : "Q") + i2.x1 + " " + i2.y1 + " " + i2.x + " " + i2.y;
      else if (i2.type === _.SMOOTH_QUAD_TO) r2 += (i2.relative ? "t" : "T") + i2.x + " " + i2.y;
      else {
        if (i2.type !== _.ARC) throw new Error('Unexpected command type "' + i2.type + '" at index ' + e2 + ".");
        r2 += (i2.relative ? "a" : "A") + i2.rX + " " + i2.rY + " " + i2.xRot + " " + +i2.lArcFlag + " " + +i2.sweepFlag + " " + i2.x + " " + i2.y;
      }
    }
    return r2;
  }
  function i(t2, r2) {
    var e2 = t2[0], i2 = t2[1];
    return [e2 * Math.cos(r2) - i2 * Math.sin(r2), e2 * Math.sin(r2) + i2 * Math.cos(r2)];
  }
  function a() {
    for (var t2 = [], r2 = 0; r2 < arguments.length; r2++) t2[r2] = arguments[r2];
    for (var e2 = 0; e2 < t2.length; e2++) if ("number" != typeof t2[e2]) throw new Error("assertNumbers arguments[" + e2 + "] is not a number. " + typeof t2[e2] + " == typeof " + t2[e2]);
    return true;
  }
  var n = Math.PI;
  function o(t2, r2, e2) {
    t2.lArcFlag = 0 === t2.lArcFlag ? 0 : 1, t2.sweepFlag = 0 === t2.sweepFlag ? 0 : 1;
    var a2 = t2.rX, o2 = t2.rY, s2 = t2.x, u2 = t2.y;
    a2 = Math.abs(t2.rX), o2 = Math.abs(t2.rY);
    var h2 = i([(r2 - s2) / 2, (e2 - u2) / 2], -t2.xRot / 180 * n), c2 = h2[0], y2 = h2[1], p2 = Math.pow(c2, 2) / Math.pow(a2, 2) + Math.pow(y2, 2) / Math.pow(o2, 2);
    1 < p2 && (a2 *= Math.sqrt(p2), o2 *= Math.sqrt(p2)), t2.rX = a2, t2.rY = o2;
    var m2 = Math.pow(a2, 2) * Math.pow(y2, 2) + Math.pow(o2, 2) * Math.pow(c2, 2), O2 = (t2.lArcFlag !== t2.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(a2, 2) * Math.pow(o2, 2) - m2) / m2)), l2 = a2 * y2 / o2 * O2, T2 = -o2 * c2 / a2 * O2, v2 = i([l2, T2], t2.xRot / 180 * n);
    t2.cX = v2[0] + (r2 + s2) / 2, t2.cY = v2[1] + (e2 + u2) / 2, t2.phi1 = Math.atan2((y2 - T2) / o2, (c2 - l2) / a2), t2.phi2 = Math.atan2((-y2 - T2) / o2, (-c2 - l2) / a2), 0 === t2.sweepFlag && t2.phi2 > t2.phi1 && (t2.phi2 -= 2 * n), 1 === t2.sweepFlag && t2.phi2 < t2.phi1 && (t2.phi2 += 2 * n), t2.phi1 *= 180 / n, t2.phi2 *= 180 / n;
  }
  function s(t2, r2, e2) {
    a(t2, r2, e2);
    var i2 = t2 * t2 + r2 * r2 - e2 * e2;
    if (0 > i2) return [];
    if (0 === i2) return [[t2 * e2 / (t2 * t2 + r2 * r2), r2 * e2 / (t2 * t2 + r2 * r2)]];
    var n2 = Math.sqrt(i2);
    return [[(t2 * e2 + r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 - t2 * n2) / (t2 * t2 + r2 * r2)], [(t2 * e2 - r2 * n2) / (t2 * t2 + r2 * r2), (r2 * e2 + t2 * n2) / (t2 * t2 + r2 * r2)]];
  }
  var u, h = Math.PI / 180;
  function c$1(t2, r2, e2) {
    return (1 - e2) * t2 + e2 * r2;
  }
  function y(t2, r2, e2, i2) {
    return t2 + Math.cos(i2 / 180 * n) * r2 + Math.sin(i2 / 180 * n) * e2;
  }
  function p(t2, r2, e2, i2) {
    var a2 = 1e-6, n2 = r2 - t2, o2 = e2 - r2, s2 = 3 * n2 + 3 * (i2 - e2) - 6 * o2, u2 = 6 * (o2 - n2), h2 = 3 * n2;
    return Math.abs(s2) < a2 ? [-h2 / u2] : (function(t3, r3, e3) {
      var i3 = t3 * t3 / 4 - r3;
      if (i3 < -e3) return [];
      if (i3 <= e3) return [-t3 / 2];
      var a3 = Math.sqrt(i3);
      return [-t3 / 2 - a3, -t3 / 2 + a3];
    })(u2 / s2, h2 / s2, a2);
  }
  function m$1(t2, r2, e2, i2, a2) {
    var n2 = 1 - a2;
    return t2 * (n2 * n2 * n2) + r2 * (3 * n2 * n2 * a2) + e2 * (3 * n2 * a2 * a2) + i2 * (a2 * a2 * a2);
  }
  !(function(t2) {
    function r2() {
      return u2((function(t3, r3, e3) {
        return t3.relative && (void 0 !== t3.x1 && (t3.x1 += r3), void 0 !== t3.y1 && (t3.y1 += e3), void 0 !== t3.x2 && (t3.x2 += r3), void 0 !== t3.y2 && (t3.y2 += e3), void 0 !== t3.x && (t3.x += r3), void 0 !== t3.y && (t3.y += e3), t3.relative = false), t3;
      }));
    }
    function e2() {
      var t3 = NaN, r3 = NaN, e3 = NaN, i2 = NaN;
      return u2((function(a2, n3, o2) {
        return a2.type & _.SMOOTH_CURVE_TO && (a2.type = _.CURVE_TO, t3 = isNaN(t3) ? n3 : t3, r3 = isNaN(r3) ? o2 : r3, a2.x1 = a2.relative ? n3 - t3 : 2 * n3 - t3, a2.y1 = a2.relative ? o2 - r3 : 2 * o2 - r3), a2.type & _.CURVE_TO ? (t3 = a2.relative ? n3 + a2.x2 : a2.x2, r3 = a2.relative ? o2 + a2.y2 : a2.y2) : (t3 = NaN, r3 = NaN), a2.type & _.SMOOTH_QUAD_TO && (a2.type = _.QUAD_TO, e3 = isNaN(e3) ? n3 : e3, i2 = isNaN(i2) ? o2 : i2, a2.x1 = a2.relative ? n3 - e3 : 2 * n3 - e3, a2.y1 = a2.relative ? o2 - i2 : 2 * o2 - i2), a2.type & _.QUAD_TO ? (e3 = a2.relative ? n3 + a2.x1 : a2.x1, i2 = a2.relative ? o2 + a2.y1 : a2.y1) : (e3 = NaN, i2 = NaN), a2;
      }));
    }
    function n2() {
      var t3 = NaN, r3 = NaN;
      return u2((function(e3, i2, a2) {
        if (e3.type & _.SMOOTH_QUAD_TO && (e3.type = _.QUAD_TO, t3 = isNaN(t3) ? i2 : t3, r3 = isNaN(r3) ? a2 : r3, e3.x1 = e3.relative ? i2 - t3 : 2 * i2 - t3, e3.y1 = e3.relative ? a2 - r3 : 2 * a2 - r3), e3.type & _.QUAD_TO) {
          t3 = e3.relative ? i2 + e3.x1 : e3.x1, r3 = e3.relative ? a2 + e3.y1 : e3.y1;
          var n3 = e3.x1, o2 = e3.y1;
          e3.type = _.CURVE_TO, e3.x1 = ((e3.relative ? 0 : i2) + 2 * n3) / 3, e3.y1 = ((e3.relative ? 0 : a2) + 2 * o2) / 3, e3.x2 = (e3.x + 2 * n3) / 3, e3.y2 = (e3.y + 2 * o2) / 3;
        } else t3 = NaN, r3 = NaN;
        return e3;
      }));
    }
    function u2(t3) {
      var r3 = 0, e3 = 0, i2 = NaN, a2 = NaN;
      return function(n3) {
        if (isNaN(i2) && !(n3.type & _.MOVE_TO)) throw new Error("path must start with moveto");
        var o2 = t3(n3, r3, e3, i2, a2);
        return n3.type & _.CLOSE_PATH && (r3 = i2, e3 = a2), void 0 !== n3.x && (r3 = n3.relative ? r3 + n3.x : n3.x), void 0 !== n3.y && (e3 = n3.relative ? e3 + n3.y : n3.y), n3.type & _.MOVE_TO && (i2 = r3, a2 = e3), o2;
      };
    }
    function O2(t3, r3, e3, i2, n3, o2) {
      return a(t3, r3, e3, i2, n3, o2), u2((function(a2, s2, u3, h2) {
        var c2 = a2.x1, y2 = a2.x2, p2 = a2.relative && !isNaN(h2), m2 = void 0 !== a2.x ? a2.x : p2 ? 0 : s2, O3 = void 0 !== a2.y ? a2.y : p2 ? 0 : u3;
        function l3(t4) {
          return t4 * t4;
        }
        a2.type & _.HORIZ_LINE_TO && 0 !== r3 && (a2.type = _.LINE_TO, a2.y = a2.relative ? 0 : u3), a2.type & _.VERT_LINE_TO && 0 !== e3 && (a2.type = _.LINE_TO, a2.x = a2.relative ? 0 : s2), void 0 !== a2.x && (a2.x = a2.x * t3 + O3 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y && (a2.y = m2 * r3 + a2.y * i2 + (p2 ? 0 : o2)), void 0 !== a2.x1 && (a2.x1 = a2.x1 * t3 + a2.y1 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y1 && (a2.y1 = c2 * r3 + a2.y1 * i2 + (p2 ? 0 : o2)), void 0 !== a2.x2 && (a2.x2 = a2.x2 * t3 + a2.y2 * e3 + (p2 ? 0 : n3)), void 0 !== a2.y2 && (a2.y2 = y2 * r3 + a2.y2 * i2 + (p2 ? 0 : o2));
        var T2 = t3 * i2 - r3 * e3;
        if (void 0 !== a2.xRot && (1 !== t3 || 0 !== r3 || 0 !== e3 || 1 !== i2)) if (0 === T2) delete a2.rX, delete a2.rY, delete a2.xRot, delete a2.lArcFlag, delete a2.sweepFlag, a2.type = _.LINE_TO;
        else {
          var v2 = a2.xRot * Math.PI / 180, f2 = Math.sin(v2), N2 = Math.cos(v2), x2 = 1 / l3(a2.rX), d2 = 1 / l3(a2.rY), E2 = l3(N2) * x2 + l3(f2) * d2, A2 = 2 * f2 * N2 * (x2 - d2), C2 = l3(f2) * x2 + l3(N2) * d2, M2 = E2 * i2 * i2 - A2 * r3 * i2 + C2 * r3 * r3, R2 = A2 * (t3 * i2 + r3 * e3) - 2 * (E2 * e3 * i2 + C2 * t3 * r3), g2 = E2 * e3 * e3 - A2 * t3 * e3 + C2 * t3 * t3, I2 = (Math.atan2(R2, M2 - g2) + Math.PI) % Math.PI / 2, S2 = Math.sin(I2), L2 = Math.cos(I2);
          a2.rX = Math.abs(T2) / Math.sqrt(M2 * l3(L2) + R2 * S2 * L2 + g2 * l3(S2)), a2.rY = Math.abs(T2) / Math.sqrt(M2 * l3(S2) - R2 * S2 * L2 + g2 * l3(L2)), a2.xRot = 180 * I2 / Math.PI;
        }
        return void 0 !== a2.sweepFlag && 0 > T2 && (a2.sweepFlag = +!a2.sweepFlag), a2;
      }));
    }
    function l2() {
      return function(t3) {
        var r3 = {};
        for (var e3 in t3) r3[e3] = t3[e3];
        return r3;
      };
    }
    t2.ROUND = function(t3) {
      function r3(r4) {
        return Math.round(r4 * t3) / t3;
      }
      return void 0 === t3 && (t3 = 1e13), a(t3), function(t4) {
        return void 0 !== t4.x1 && (t4.x1 = r3(t4.x1)), void 0 !== t4.y1 && (t4.y1 = r3(t4.y1)), void 0 !== t4.x2 && (t4.x2 = r3(t4.x2)), void 0 !== t4.y2 && (t4.y2 = r3(t4.y2)), void 0 !== t4.x && (t4.x = r3(t4.x)), void 0 !== t4.y && (t4.y = r3(t4.y)), void 0 !== t4.rX && (t4.rX = r3(t4.rX)), void 0 !== t4.rY && (t4.rY = r3(t4.rY)), t4;
      };
    }, t2.TO_ABS = r2, t2.TO_REL = function() {
      return u2((function(t3, r3, e3) {
        return t3.relative || (void 0 !== t3.x1 && (t3.x1 -= r3), void 0 !== t3.y1 && (t3.y1 -= e3), void 0 !== t3.x2 && (t3.x2 -= r3), void 0 !== t3.y2 && (t3.y2 -= e3), void 0 !== t3.x && (t3.x -= r3), void 0 !== t3.y && (t3.y -= e3), t3.relative = true), t3;
      }));
    }, t2.NORMALIZE_HVZ = function(t3, r3, e3) {
      return void 0 === t3 && (t3 = true), void 0 === r3 && (r3 = true), void 0 === e3 && (e3 = true), u2((function(i2, a2, n3, o2, s2) {
        if (isNaN(o2) && !(i2.type & _.MOVE_TO)) throw new Error("path must start with moveto");
        return r3 && i2.type & _.HORIZ_LINE_TO && (i2.type = _.LINE_TO, i2.y = i2.relative ? 0 : n3), e3 && i2.type & _.VERT_LINE_TO && (i2.type = _.LINE_TO, i2.x = i2.relative ? 0 : a2), t3 && i2.type & _.CLOSE_PATH && (i2.type = _.LINE_TO, i2.x = i2.relative ? o2 - a2 : o2, i2.y = i2.relative ? s2 - n3 : s2), i2.type & _.ARC && (0 === i2.rX || 0 === i2.rY) && (i2.type = _.LINE_TO, delete i2.rX, delete i2.rY, delete i2.xRot, delete i2.lArcFlag, delete i2.sweepFlag), i2;
      }));
    }, t2.NORMALIZE_ST = e2, t2.QT_TO_C = n2, t2.INFO = u2, t2.SANITIZE = function(t3) {
      void 0 === t3 && (t3 = 0), a(t3);
      var r3 = NaN, e3 = NaN, i2 = NaN, n3 = NaN;
      return u2((function(a2, o2, s2, u3, h2) {
        var c2 = Math.abs, y2 = false, p2 = 0, m2 = 0;
        if (a2.type & _.SMOOTH_CURVE_TO && (p2 = isNaN(r3) ? 0 : o2 - r3, m2 = isNaN(e3) ? 0 : s2 - e3), a2.type & (_.CURVE_TO | _.SMOOTH_CURVE_TO) ? (r3 = a2.relative ? o2 + a2.x2 : a2.x2, e3 = a2.relative ? s2 + a2.y2 : a2.y2) : (r3 = NaN, e3 = NaN), a2.type & _.SMOOTH_QUAD_TO ? (i2 = isNaN(i2) ? o2 : 2 * o2 - i2, n3 = isNaN(n3) ? s2 : 2 * s2 - n3) : a2.type & _.QUAD_TO ? (i2 = a2.relative ? o2 + a2.x1 : a2.x1, n3 = a2.relative ? s2 + a2.y1 : a2.y2) : (i2 = NaN, n3 = NaN), a2.type & _.LINE_COMMANDS || a2.type & _.ARC && (0 === a2.rX || 0 === a2.rY || !a2.lArcFlag) || a2.type & _.CURVE_TO || a2.type & _.SMOOTH_CURVE_TO || a2.type & _.QUAD_TO || a2.type & _.SMOOTH_QUAD_TO) {
          var O3 = void 0 === a2.x ? 0 : a2.relative ? a2.x : a2.x - o2, l3 = void 0 === a2.y ? 0 : a2.relative ? a2.y : a2.y - s2;
          p2 = isNaN(i2) ? void 0 === a2.x1 ? p2 : a2.relative ? a2.x : a2.x1 - o2 : i2 - o2, m2 = isNaN(n3) ? void 0 === a2.y1 ? m2 : a2.relative ? a2.y : a2.y1 - s2 : n3 - s2;
          var T2 = void 0 === a2.x2 ? 0 : a2.relative ? a2.x : a2.x2 - o2, v2 = void 0 === a2.y2 ? 0 : a2.relative ? a2.y : a2.y2 - s2;
          c2(O3) <= t3 && c2(l3) <= t3 && c2(p2) <= t3 && c2(m2) <= t3 && c2(T2) <= t3 && c2(v2) <= t3 && (y2 = true);
        }
        return a2.type & _.CLOSE_PATH && c2(o2 - u3) <= t3 && c2(s2 - h2) <= t3 && (y2 = true), y2 ? [] : a2;
      }));
    }, t2.MATRIX = O2, t2.ROTATE = function(t3, r3, e3) {
      void 0 === r3 && (r3 = 0), void 0 === e3 && (e3 = 0), a(t3, r3, e3);
      var i2 = Math.sin(t3), n3 = Math.cos(t3);
      return O2(n3, i2, -i2, n3, r3 - r3 * n3 + e3 * i2, e3 - r3 * i2 - e3 * n3);
    }, t2.TRANSLATE = function(t3, r3) {
      return void 0 === r3 && (r3 = 0), a(t3, r3), O2(1, 0, 0, 1, t3, r3);
    }, t2.SCALE = function(t3, r3) {
      return void 0 === r3 && (r3 = t3), a(t3, r3), O2(t3, 0, 0, r3, 0, 0);
    }, t2.SKEW_X = function(t3) {
      return a(t3), O2(1, 0, Math.atan(t3), 1, 0, 0);
    }, t2.SKEW_Y = function(t3) {
      return a(t3), O2(1, Math.atan(t3), 0, 1, 0, 0);
    }, t2.X_AXIS_SYMMETRY = function(t3) {
      return void 0 === t3 && (t3 = 0), a(t3), O2(-1, 0, 0, 1, t3, 0);
    }, t2.Y_AXIS_SYMMETRY = function(t3) {
      return void 0 === t3 && (t3 = 0), a(t3), O2(1, 0, 0, -1, 0, t3);
    }, t2.A_TO_C = function() {
      return u2((function(t3, r3, e3) {
        return _.ARC === t3.type ? (function(t4, r4, e4) {
          var a2, n3, s2, u3;
          t4.cX || o(t4, r4, e4);
          for (var y2 = Math.min(t4.phi1, t4.phi2), p2 = Math.max(t4.phi1, t4.phi2) - y2, m2 = Math.ceil(p2 / 90), O3 = new Array(m2), l3 = r4, T2 = e4, v2 = 0; v2 < m2; v2++) {
            var f2 = c$1(t4.phi1, t4.phi2, v2 / m2), N2 = c$1(t4.phi1, t4.phi2, (v2 + 1) / m2), x2 = N2 - f2, d2 = 4 / 3 * Math.tan(x2 * h / 4), E2 = [Math.cos(f2 * h) - d2 * Math.sin(f2 * h), Math.sin(f2 * h) + d2 * Math.cos(f2 * h)], A2 = E2[0], C2 = E2[1], M2 = [Math.cos(N2 * h), Math.sin(N2 * h)], R2 = M2[0], g2 = M2[1], I2 = [R2 + d2 * Math.sin(N2 * h), g2 - d2 * Math.cos(N2 * h)], S2 = I2[0], L2 = I2[1];
            O3[v2] = { relative: t4.relative, type: _.CURVE_TO };
            var H4 = function(r5, e5) {
              var a3 = i([r5 * t4.rX, e5 * t4.rY], t4.xRot), n4 = a3[0], o2 = a3[1];
              return [t4.cX + n4, t4.cY + o2];
            };
            a2 = H4(A2, C2), O3[v2].x1 = a2[0], O3[v2].y1 = a2[1], n3 = H4(S2, L2), O3[v2].x2 = n3[0], O3[v2].y2 = n3[1], s2 = H4(R2, g2), O3[v2].x = s2[0], O3[v2].y = s2[1], t4.relative && (O3[v2].x1 -= l3, O3[v2].y1 -= T2, O3[v2].x2 -= l3, O3[v2].y2 -= T2, O3[v2].x -= l3, O3[v2].y -= T2), l3 = (u3 = [O3[v2].x, O3[v2].y])[0], T2 = u3[1];
          }
          return O3;
        })(t3, t3.relative ? 0 : r3, t3.relative ? 0 : e3) : t3;
      }));
    }, t2.ANNOTATE_ARCS = function() {
      return u2((function(t3, r3, e3) {
        return t3.relative && (r3 = 0, e3 = 0), _.ARC === t3.type && o(t3, r3, e3), t3;
      }));
    }, t2.CLONE = l2, t2.CALCULATE_BOUNDS = function() {
      var t3 = function(t4) {
        var r3 = {};
        for (var e3 in t4) r3[e3] = t4[e3];
        return r3;
      }, i2 = r2(), a2 = n2(), h2 = e2(), c2 = u2((function(r3, e3, n3) {
        var u3 = h2(a2(i2(t3(r3))));
        function O3(t4) {
          t4 > c2.maxX && (c2.maxX = t4), t4 < c2.minX && (c2.minX = t4);
        }
        function l3(t4) {
          t4 > c2.maxY && (c2.maxY = t4), t4 < c2.minY && (c2.minY = t4);
        }
        if (u3.type & _.DRAWING_COMMANDS && (O3(e3), l3(n3)), u3.type & _.HORIZ_LINE_TO && O3(u3.x), u3.type & _.VERT_LINE_TO && l3(u3.y), u3.type & _.LINE_TO && (O3(u3.x), l3(u3.y)), u3.type & _.CURVE_TO) {
          O3(u3.x), l3(u3.y);
          for (var T2 = 0, v2 = p(e3, u3.x1, u3.x2, u3.x); T2 < v2.length; T2++) {
            0 < (w2 = v2[T2]) && 1 > w2 && O3(m$1(e3, u3.x1, u3.x2, u3.x, w2));
          }
          for (var f2 = 0, N2 = p(n3, u3.y1, u3.y2, u3.y); f2 < N2.length; f2++) {
            0 < (w2 = N2[f2]) && 1 > w2 && l3(m$1(n3, u3.y1, u3.y2, u3.y, w2));
          }
        }
        if (u3.type & _.ARC) {
          O3(u3.x), l3(u3.y), o(u3, e3, n3);
          for (var x2 = u3.xRot / 180 * Math.PI, d2 = Math.cos(x2) * u3.rX, E2 = Math.sin(x2) * u3.rX, A2 = -Math.sin(x2) * u3.rY, C2 = Math.cos(x2) * u3.rY, M2 = u3.phi1 < u3.phi2 ? [u3.phi1, u3.phi2] : -180 > u3.phi2 ? [u3.phi2 + 360, u3.phi1 + 360] : [u3.phi2, u3.phi1], R2 = M2[0], g2 = M2[1], I2 = function(t4) {
            var r4 = t4[0], e4 = t4[1], i3 = 180 * Math.atan2(e4, r4) / Math.PI;
            return i3 < R2 ? i3 + 360 : i3;
          }, S2 = 0, L2 = s(A2, -d2, 0).map(I2); S2 < L2.length; S2++) {
            (w2 = L2[S2]) > R2 && w2 < g2 && O3(y(u3.cX, d2, A2, w2));
          }
          for (var H4 = 0, U2 = s(C2, -E2, 0).map(I2); H4 < U2.length; H4++) {
            var w2;
            (w2 = U2[H4]) > R2 && w2 < g2 && l3(y(u3.cY, E2, C2, w2));
          }
        }
        return r3;
      }));
      return c2.minX = 1 / 0, c2.maxX = -1 / 0, c2.minY = 1 / 0, c2.maxY = -1 / 0, c2;
    };
  })(u || (u = {}));
  var O, l = (function() {
    function t2() {
    }
    return t2.prototype.round = function(t3) {
      return this.transform(u.ROUND(t3));
    }, t2.prototype.toAbs = function() {
      return this.transform(u.TO_ABS());
    }, t2.prototype.toRel = function() {
      return this.transform(u.TO_REL());
    }, t2.prototype.normalizeHVZ = function(t3, r2, e2) {
      return this.transform(u.NORMALIZE_HVZ(t3, r2, e2));
    }, t2.prototype.normalizeST = function() {
      return this.transform(u.NORMALIZE_ST());
    }, t2.prototype.qtToC = function() {
      return this.transform(u.QT_TO_C());
    }, t2.prototype.aToC = function() {
      return this.transform(u.A_TO_C());
    }, t2.prototype.sanitize = function(t3) {
      return this.transform(u.SANITIZE(t3));
    }, t2.prototype.translate = function(t3, r2) {
      return this.transform(u.TRANSLATE(t3, r2));
    }, t2.prototype.scale = function(t3, r2) {
      return this.transform(u.SCALE(t3, r2));
    }, t2.prototype.rotate = function(t3, r2, e2) {
      return this.transform(u.ROTATE(t3, r2, e2));
    }, t2.prototype.matrix = function(t3, r2, e2, i2, a2, n2) {
      return this.transform(u.MATRIX(t3, r2, e2, i2, a2, n2));
    }, t2.prototype.skewX = function(t3) {
      return this.transform(u.SKEW_X(t3));
    }, t2.prototype.skewY = function(t3) {
      return this.transform(u.SKEW_Y(t3));
    }, t2.prototype.xSymmetry = function(t3) {
      return this.transform(u.X_AXIS_SYMMETRY(t3));
    }, t2.prototype.ySymmetry = function(t3) {
      return this.transform(u.Y_AXIS_SYMMETRY(t3));
    }, t2.prototype.annotateArcs = function() {
      return this.transform(u.ANNOTATE_ARCS());
    }, t2;
  })(), T = function(t2) {
    return " " === t2 || "	" === t2 || "\r" === t2 || "\n" === t2;
  }, v = function(t2) {
    return "0".charCodeAt(0) <= t2.charCodeAt(0) && t2.charCodeAt(0) <= "9".charCodeAt(0);
  }, f = (function(t2) {
    function e2() {
      var r2 = t2.call(this) || this;
      return r2.curNumber = "", r2.curCommandType = -1, r2.curCommandRelative = false, r2.canParseCommandOrComma = true, r2.curNumberHasExp = false, r2.curNumberHasExpDigits = false, r2.curNumberHasDecimal = false, r2.curArgs = [], r2;
    }
    return r(e2, t2), e2.prototype.finish = function(t3) {
      if (void 0 === t3 && (t3 = []), this.parse(" ", t3), 0 !== this.curArgs.length || !this.canParseCommandOrComma) throw new SyntaxError("Unterminated command at the path end.");
      return t3;
    }, e2.prototype.parse = function(t3, r2) {
      var e3 = this;
      void 0 === r2 && (r2 = []);
      for (var i2 = function(t4) {
        r2.push(t4), e3.curArgs.length = 0, e3.canParseCommandOrComma = true;
      }, a2 = 0; a2 < t3.length; a2++) {
        var n2 = t3[a2], o2 = !(this.curCommandType !== _.ARC || 3 !== this.curArgs.length && 4 !== this.curArgs.length || 1 !== this.curNumber.length || "0" !== this.curNumber && "1" !== this.curNumber), s2 = v(n2) && ("0" === this.curNumber && "0" === n2 || o2);
        if (!v(n2) || s2) if ("e" !== n2 && "E" !== n2) if ("-" !== n2 && "+" !== n2 || !this.curNumberHasExp || this.curNumberHasExpDigits) if ("." !== n2 || this.curNumberHasExp || this.curNumberHasDecimal || o2) {
          if (this.curNumber && -1 !== this.curCommandType) {
            var u2 = Number(this.curNumber);
            if (isNaN(u2)) throw new SyntaxError("Invalid number ending at " + a2);
            if (this.curCommandType === _.ARC) {
              if (0 === this.curArgs.length || 1 === this.curArgs.length) {
                if (0 > u2) throw new SyntaxError('Expected positive number, got "' + u2 + '" at index "' + a2 + '"');
              } else if ((3 === this.curArgs.length || 4 === this.curArgs.length) && "0" !== this.curNumber && "1" !== this.curNumber) throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + a2 + '"');
            }
            this.curArgs.push(u2), this.curArgs.length === N[this.curCommandType] && (_.HORIZ_LINE_TO === this.curCommandType ? i2({ type: _.HORIZ_LINE_TO, relative: this.curCommandRelative, x: u2 }) : _.VERT_LINE_TO === this.curCommandType ? i2({ type: _.VERT_LINE_TO, relative: this.curCommandRelative, y: u2 }) : this.curCommandType === _.MOVE_TO || this.curCommandType === _.LINE_TO || this.curCommandType === _.SMOOTH_QUAD_TO ? (i2({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), _.MOVE_TO === this.curCommandType && (this.curCommandType = _.LINE_TO)) : this.curCommandType === _.CURVE_TO ? i2({ type: _.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === _.SMOOTH_CURVE_TO ? i2({ type: _.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.QUAD_TO ? i2({ type: _.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === _.ARC && i2({ type: _.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = false, this.curNumberHasExp = false, this.curNumberHasDecimal = false, this.canParseCommandOrComma = true;
          }
          if (!T(n2)) if ("," === n2 && this.canParseCommandOrComma) this.canParseCommandOrComma = false;
          else if ("+" !== n2 && "-" !== n2 && "." !== n2) if (s2) this.curNumber = n2, this.curNumberHasDecimal = false;
          else {
            if (0 !== this.curArgs.length) throw new SyntaxError("Unterminated command at index " + a2 + ".");
            if (!this.canParseCommandOrComma) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ". Command cannot follow comma");
            if (this.canParseCommandOrComma = false, "z" !== n2 && "Z" !== n2) if ("h" === n2 || "H" === n2) this.curCommandType = _.HORIZ_LINE_TO, this.curCommandRelative = "h" === n2;
            else if ("v" === n2 || "V" === n2) this.curCommandType = _.VERT_LINE_TO, this.curCommandRelative = "v" === n2;
            else if ("m" === n2 || "M" === n2) this.curCommandType = _.MOVE_TO, this.curCommandRelative = "m" === n2;
            else if ("l" === n2 || "L" === n2) this.curCommandType = _.LINE_TO, this.curCommandRelative = "l" === n2;
            else if ("c" === n2 || "C" === n2) this.curCommandType = _.CURVE_TO, this.curCommandRelative = "c" === n2;
            else if ("s" === n2 || "S" === n2) this.curCommandType = _.SMOOTH_CURVE_TO, this.curCommandRelative = "s" === n2;
            else if ("q" === n2 || "Q" === n2) this.curCommandType = _.QUAD_TO, this.curCommandRelative = "q" === n2;
            else if ("t" === n2 || "T" === n2) this.curCommandType = _.SMOOTH_QUAD_TO, this.curCommandRelative = "t" === n2;
            else {
              if ("a" !== n2 && "A" !== n2) throw new SyntaxError('Unexpected character "' + n2 + '" at index ' + a2 + ".");
              this.curCommandType = _.ARC, this.curCommandRelative = "a" === n2;
            }
            else r2.push({ type: _.CLOSE_PATH }), this.canParseCommandOrComma = true, this.curCommandType = -1;
          }
          else this.curNumber = n2, this.curNumberHasDecimal = "." === n2;
        } else this.curNumber += n2, this.curNumberHasDecimal = true;
        else this.curNumber += n2;
        else this.curNumber += n2, this.curNumberHasExp = true;
        else this.curNumber += n2, this.curNumberHasExpDigits = this.curNumberHasExp;
      }
      return r2;
    }, e2.prototype.transform = function(t3) {
      return Object.create(this, { parse: { value: function(r2, e3) {
        void 0 === e3 && (e3 = []);
        for (var i2 = 0, a2 = Object.getPrototypeOf(this).parse.call(this, r2); i2 < a2.length; i2++) {
          var n2 = a2[i2], o2 = t3(n2);
          Array.isArray(o2) ? e3.push.apply(e3, o2) : e3.push(o2);
        }
        return e3;
      } } });
    }, e2;
  })(l), _ = (function(t2) {
    function i2(r2) {
      var e2 = t2.call(this) || this;
      return e2.commands = "string" == typeof r2 ? i2.parse(r2) : r2, e2;
    }
    return r(i2, t2), i2.prototype.encode = function() {
      return i2.encode(this.commands);
    }, i2.prototype.getBounds = function() {
      var t3 = u.CALCULATE_BOUNDS();
      return this.transform(t3), t3;
    }, i2.prototype.transform = function(t3) {
      for (var r2 = [], e2 = 0, i3 = this.commands; e2 < i3.length; e2++) {
        var a2 = t3(i3[e2]);
        Array.isArray(a2) ? r2.push.apply(r2, a2) : r2.push(a2);
      }
      return this.commands = r2, this;
    }, i2.encode = function(t3) {
      return e(t3);
    }, i2.parse = function(t3) {
      var r2 = new f(), e2 = [];
      return r2.parse(t3, e2), r2.finish(e2), e2;
    }, i2.CLOSE_PATH = 1, i2.MOVE_TO = 2, i2.HORIZ_LINE_TO = 4, i2.VERT_LINE_TO = 8, i2.LINE_TO = 16, i2.CURVE_TO = 32, i2.SMOOTH_CURVE_TO = 64, i2.QUAD_TO = 128, i2.SMOOTH_QUAD_TO = 256, i2.ARC = 512, i2.LINE_COMMANDS = i2.LINE_TO | i2.HORIZ_LINE_TO | i2.VERT_LINE_TO, i2.DRAWING_COMMANDS = i2.HORIZ_LINE_TO | i2.VERT_LINE_TO | i2.LINE_TO | i2.CURVE_TO | i2.SMOOTH_CURVE_TO | i2.QUAD_TO | i2.SMOOTH_QUAD_TO | i2.ARC, i2;
  })(l), N = ((O = {})[_.MOVE_TO] = 2, O[_.LINE_TO] = 2, O[_.HORIZ_LINE_TO] = 1, O[_.VERT_LINE_TO] = 1, O[_.CLOSE_PATH] = 0, O[_.QUAD_TO] = 4, O[_.SMOOTH_QUAD_TO] = 2, O[_.CURVE_TO] = 6, O[_.SMOOTH_CURVE_TO] = 4, O[_.ARC] = 7, O);
  function _typeof(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var mulTable = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
  var shgTable = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
  function getImageDataFromCanvas(canvas, topX, topY, width, height) {
    if (typeof canvas === "string") {
      canvas = document.getElementById(canvas);
    }
    if (!canvas || _typeof(canvas) !== "object" || !("getContext" in canvas)) {
      throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
    }
    var context = canvas.getContext("2d");
    try {
      return context.getImageData(topX, topY, width, height);
    } catch (e2) {
      throw new Error("unable to access image data: " + e2);
    }
  }
  function processCanvasRGBA(canvas, topX, topY, width, height, radius) {
    if (isNaN(radius) || radius < 1) {
      return;
    }
    radius |= 0;
    var imageData = getImageDataFromCanvas(canvas, topX, topY, width, height);
    imageData = processImageDataRGBA(imageData, topX, topY, width, height, radius);
    canvas.getContext("2d").putImageData(imageData, topX, topY);
  }
  function processImageDataRGBA(imageData, topX, topY, width, height, radius) {
    var pixels = imageData.data;
    var div = 2 * radius + 1;
    var widthMinus1 = width - 1;
    var heightMinus1 = height - 1;
    var radiusPlus1 = radius + 1;
    var sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
    var stackStart = new BlurStack();
    var stack = stackStart;
    var stackEnd;
    for (var i2 = 1; i2 < div; i2++) {
      stack = stack.next = new BlurStack();
      if (i2 === radiusPlus1) {
        stackEnd = stack;
      }
    }
    stack.next = stackStart;
    var stackIn = null, stackOut = null, yw = 0, yi = 0;
    var mulSum = mulTable[radius];
    var shgSum = shgTable[radius];
    for (var y2 = 0; y2 < height; y2++) {
      stack = stackStart;
      var pr = pixels[yi], pg = pixels[yi + 1], pb = pixels[yi + 2], pa = pixels[yi + 3];
      for (var _i = 0; _i < radiusPlus1; _i++) {
        stack.r = pr;
        stack.g = pg;
        stack.b = pb;
        stack.a = pa;
        stack = stack.next;
      }
      var rInSum = 0, gInSum = 0, bInSum = 0, aInSum = 0, rOutSum = radiusPlus1 * pr, gOutSum = radiusPlus1 * pg, bOutSum = radiusPlus1 * pb, aOutSum = radiusPlus1 * pa, rSum = sumFactor * pr, gSum = sumFactor * pg, bSum = sumFactor * pb, aSum = sumFactor * pa;
      for (var _i2 = 1; _i2 < radiusPlus1; _i2++) {
        var p2 = yi + ((widthMinus1 < _i2 ? widthMinus1 : _i2) << 2);
        var r2 = pixels[p2], g2 = pixels[p2 + 1], b2 = pixels[p2 + 2], a2 = pixels[p2 + 3];
        var rbs = radiusPlus1 - _i2;
        rSum += (stack.r = r2) * rbs;
        gSum += (stack.g = g2) * rbs;
        bSum += (stack.b = b2) * rbs;
        aSum += (stack.a = a2) * rbs;
        rInSum += r2;
        gInSum += g2;
        bInSum += b2;
        aInSum += a2;
        stack = stack.next;
      }
      stackIn = stackStart;
      stackOut = stackEnd;
      for (var x2 = 0; x2 < width; x2++) {
        var paInitial = aSum * mulSum >>> shgSum;
        pixels[yi + 3] = paInitial;
        if (paInitial !== 0) {
          var _a2 = 255 / paInitial;
          pixels[yi] = (rSum * mulSum >>> shgSum) * _a2;
          pixels[yi + 1] = (gSum * mulSum >>> shgSum) * _a2;
          pixels[yi + 2] = (bSum * mulSum >>> shgSum) * _a2;
        } else {
          pixels[yi] = pixels[yi + 1] = pixels[yi + 2] = 0;
        }
        rSum -= rOutSum;
        gSum -= gOutSum;
        bSum -= bOutSum;
        aSum -= aOutSum;
        rOutSum -= stackIn.r;
        gOutSum -= stackIn.g;
        bOutSum -= stackIn.b;
        aOutSum -= stackIn.a;
        var _p = x2 + radius + 1;
        _p = yw + (_p < widthMinus1 ? _p : widthMinus1) << 2;
        rInSum += stackIn.r = pixels[_p];
        gInSum += stackIn.g = pixels[_p + 1];
        bInSum += stackIn.b = pixels[_p + 2];
        aInSum += stackIn.a = pixels[_p + 3];
        rSum += rInSum;
        gSum += gInSum;
        bSum += bInSum;
        aSum += aInSum;
        stackIn = stackIn.next;
        var _stackOut = stackOut, _r = _stackOut.r, _g = _stackOut.g, _b2 = _stackOut.b, _a3 = _stackOut.a;
        rOutSum += _r;
        gOutSum += _g;
        bOutSum += _b2;
        aOutSum += _a3;
        rInSum -= _r;
        gInSum -= _g;
        bInSum -= _b2;
        aInSum -= _a3;
        stackOut = stackOut.next;
        yi += 4;
      }
      yw += width;
    }
    for (var _x = 0; _x < width; _x++) {
      yi = _x << 2;
      var _pr = pixels[yi], _pg = pixels[yi + 1], _pb = pixels[yi + 2], _pa = pixels[yi + 3], _rOutSum = radiusPlus1 * _pr, _gOutSum = radiusPlus1 * _pg, _bOutSum = radiusPlus1 * _pb, _aOutSum = radiusPlus1 * _pa, _rSum = sumFactor * _pr, _gSum = sumFactor * _pg, _bSum = sumFactor * _pb, _aSum = sumFactor * _pa;
      stack = stackStart;
      for (var _i3 = 0; _i3 < radiusPlus1; _i3++) {
        stack.r = _pr;
        stack.g = _pg;
        stack.b = _pb;
        stack.a = _pa;
        stack = stack.next;
      }
      var yp = width;
      var _gInSum = 0, _bInSum = 0, _aInSum = 0, _rInSum = 0;
      for (var _i4 = 1; _i4 <= radius; _i4++) {
        yi = yp + _x << 2;
        var _rbs = radiusPlus1 - _i4;
        _rSum += (stack.r = _pr = pixels[yi]) * _rbs;
        _gSum += (stack.g = _pg = pixels[yi + 1]) * _rbs;
        _bSum += (stack.b = _pb = pixels[yi + 2]) * _rbs;
        _aSum += (stack.a = _pa = pixels[yi + 3]) * _rbs;
        _rInSum += _pr;
        _gInSum += _pg;
        _bInSum += _pb;
        _aInSum += _pa;
        stack = stack.next;
        if (_i4 < heightMinus1) {
          yp += width;
        }
      }
      yi = _x;
      stackIn = stackStart;
      stackOut = stackEnd;
      for (var _y = 0; _y < height; _y++) {
        var _p2 = yi << 2;
        pixels[_p2 + 3] = _pa = _aSum * mulSum >>> shgSum;
        if (_pa > 0) {
          _pa = 255 / _pa;
          pixels[_p2] = (_rSum * mulSum >>> shgSum) * _pa;
          pixels[_p2 + 1] = (_gSum * mulSum >>> shgSum) * _pa;
          pixels[_p2 + 2] = (_bSum * mulSum >>> shgSum) * _pa;
        } else {
          pixels[_p2] = pixels[_p2 + 1] = pixels[_p2 + 2] = 0;
        }
        _rSum -= _rOutSum;
        _gSum -= _gOutSum;
        _bSum -= _bOutSum;
        _aSum -= _aOutSum;
        _rOutSum -= stackIn.r;
        _gOutSum -= stackIn.g;
        _bOutSum -= stackIn.b;
        _aOutSum -= stackIn.a;
        _p2 = _x + ((_p2 = _y + radiusPlus1) < heightMinus1 ? _p2 : heightMinus1) * width << 2;
        _rSum += _rInSum += stackIn.r = pixels[_p2];
        _gSum += _gInSum += stackIn.g = pixels[_p2 + 1];
        _bSum += _bInSum += stackIn.b = pixels[_p2 + 2];
        _aSum += _aInSum += stackIn.a = pixels[_p2 + 3];
        stackIn = stackIn.next;
        _rOutSum += _pr = stackOut.r;
        _gOutSum += _pg = stackOut.g;
        _bOutSum += _pb = stackOut.b;
        _aOutSum += _pa = stackOut.a;
        _rInSum -= _pr;
        _gInSum -= _pg;
        _bInSum -= _pb;
        _aInSum -= _pa;
        stackOut = stackOut.next;
        yi += width;
      }
    }
    return imageData;
  }
  var BlurStack = (
    /**
     * Set properties.
     */
    function BlurStack2() {
      _classCallCheck(this, BlurStack2);
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      this.next = null;
    }
  );
  function offscreen() {
    var {
      DOMParser: DOMParserFallback
    } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var preset = {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParserFallback,
      createCanvas(width, height) {
        return new OffscreenCanvas(width, height);
      },
      createImage(url) {
        return _asyncToGenerator(function* () {
          var response = yield fetch(url);
          var blob = yield response.blob();
          var img = yield createImageBitmap(blob);
          return img;
        })();
      }
    };
    if (typeof DOMParser !== "undefined" || typeof DOMParserFallback === "undefined") {
      Reflect.deleteProperty(preset, "DOMParser");
    }
    return preset;
  }
  function node(_ref) {
    var {
      DOMParser: DOMParser2,
      canvas,
      fetch: fetch2
    } = _ref;
    return {
      window: null,
      ignoreAnimation: true,
      ignoreMouse: true,
      DOMParser: DOMParser2,
      fetch: fetch2,
      createCanvas: canvas.createCanvas,
      createImage: canvas.loadImage
    };
  }
  var index = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    offscreen,
    node
  });
  function compressSpaces(str) {
    return str.replace(/(?!\u3000)\s+/gm, " ");
  }
  function trimLeft(str) {
    return str.replace(/^[\n \t]+/, "");
  }
  function trimRight(str) {
    return str.replace(/[\n \t]+$/, "");
  }
  function toNumbers(str) {
    var matches = (str || "").match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm) || [];
    return matches.map(parseFloat);
  }
  var allUppercase = /^[A-Z-]+$/;
  function normalizeAttributeName(name) {
    if (allUppercase.test(name)) {
      return name.toLowerCase();
    }
    return name;
  }
  function parseExternalUrl(url) {
    var urlMatch = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(url) || [];
    return urlMatch[2] || urlMatch[3] || urlMatch[4];
  }
  function normalizeColor(color2) {
    if (!color2.startsWith("rgb")) {
      return color2;
    }
    var rgbParts = 3;
    var normalizedColor = color2.replace(/\d+(\.\d+)?/g, (num, isFloat) => rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);
    return normalizedColor;
  }
  var attributeRegex = /(\[[^\]]+\])/g;
  var idRegex = /(#[^\s+>~.[:]+)/g;
  var classRegex = /(\.[^\s+>~.[:]+)/g;
  var pseudoElementRegex = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;
  var pseudoClassWithBracketsRegex = /(:[\w-]+\([^)]*\))/gi;
  var pseudoClassRegex = /(:[^\s+>~.[:]+)/g;
  var elementRegex = /([^\s+>~.[:]+)/g;
  function findSelectorMatch(selector, regex) {
    var matches = regex.exec(selector);
    if (!matches) {
      return [selector, 0];
    }
    return [selector.replace(regex, " "), matches.length];
  }
  function getSelectorSpecificity(selector) {
    var specificity = [0, 0, 0];
    var currentSelector = selector.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " ");
    var delta = 0;
    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);
    specificity[0] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);
    specificity[2] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);
    specificity[1] += delta;
    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);
    specificity[1] += delta;
    currentSelector = currentSelector.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " ");
    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex);
    specificity[2] += delta;
    return specificity.join("");
  }
  var PSEUDO_ZERO = 1e-8;
  function vectorMagnitude(v2) {
    return Math.sqrt(Math.pow(v2[0], 2) + Math.pow(v2[1], 2));
  }
  function vectorsRatio(u2, v2) {
    return (u2[0] * v2[0] + u2[1] * v2[1]) / (vectorMagnitude(u2) * vectorMagnitude(v2));
  }
  function vectorsAngle(u2, v2) {
    return (u2[0] * v2[1] < u2[1] * v2[0] ? -1 : 1) * Math.acos(vectorsRatio(u2, v2));
  }
  function CB1(t2) {
    return t2 * t2 * t2;
  }
  function CB2(t2) {
    return 3 * t2 * t2 * (1 - t2);
  }
  function CB3(t2) {
    return 3 * t2 * (1 - t2) * (1 - t2);
  }
  function CB4(t2) {
    return (1 - t2) * (1 - t2) * (1 - t2);
  }
  function QB1(t2) {
    return t2 * t2;
  }
  function QB2(t2) {
    return 2 * t2 * (1 - t2);
  }
  function QB3(t2) {
    return (1 - t2) * (1 - t2);
  }
  class Property {
    constructor(document2, name, value) {
      this.document = document2;
      this.name = name;
      this.value = value;
      this.isNormalizedColor = false;
    }
    static empty(document2) {
      return new Property(document2, "EMPTY", "");
    }
    split() {
      var separator = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
      var {
        document: document2,
        name
      } = this;
      return compressSpaces(this.getString()).trim().split(separator).map((value) => new Property(document2, name, value));
    }
    hasValue(zeroIsValue) {
      var {
        value
      } = this;
      return value !== null && value !== "" && (zeroIsValue || value !== 0) && typeof value !== "undefined";
    }
    isString(regexp) {
      var {
        value
      } = this;
      var result = typeof value === "string";
      if (!result || !regexp) {
        return result;
      }
      return regexp.test(value);
    }
    isUrlDefinition() {
      return this.isString(/^url\(/);
    }
    isPixels() {
      if (!this.hasValue()) {
        return false;
      }
      var asString2 = this.getString();
      switch (true) {
        case asString2.endsWith("px"):
        case /^[0-9]+$/.test(asString2):
          return true;
        default:
          return false;
      }
    }
    setValue(value) {
      this.value = value;
      return this;
    }
    getValue(def) {
      if (typeof def === "undefined" || this.hasValue()) {
        return this.value;
      }
      return def;
    }
    getNumber(def) {
      if (!this.hasValue()) {
        if (typeof def === "undefined") {
          return 0;
        }
        return parseFloat(def);
      }
      var {
        value
      } = this;
      var n2 = parseFloat(value);
      if (this.isString(/%$/)) {
        n2 /= 100;
      }
      return n2;
    }
    getString(def) {
      if (typeof def === "undefined" || this.hasValue()) {
        return typeof this.value === "undefined" ? "" : String(this.value);
      }
      return String(def);
    }
    getColor(def) {
      var color2 = this.getString(def);
      if (this.isNormalizedColor) {
        return color2;
      }
      this.isNormalizedColor = true;
      color2 = normalizeColor(color2);
      this.value = color2;
      return color2;
    }
    getDpi() {
      return 96;
    }
    getRem() {
      return this.document.rootEmSize;
    }
    getEm() {
      return this.document.emSize;
    }
    getUnits() {
      return this.getString().replace(/[0-9.-]/g, "");
    }
    getPixels(axisOrIsFontSize) {
      var processPercent = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!this.hasValue()) {
        return 0;
      }
      var [axis, isFontSize] = typeof axisOrIsFontSize === "boolean" ? [void 0, axisOrIsFontSize] : [axisOrIsFontSize];
      var {
        viewPort
      } = this.document.screen;
      switch (true) {
        case this.isString(/vmin$/):
          return this.getNumber() / 100 * Math.min(viewPort.computeSize("x"), viewPort.computeSize("y"));
        case this.isString(/vmax$/):
          return this.getNumber() / 100 * Math.max(viewPort.computeSize("x"), viewPort.computeSize("y"));
        case this.isString(/vw$/):
          return this.getNumber() / 100 * viewPort.computeSize("x");
        case this.isString(/vh$/):
          return this.getNumber() / 100 * viewPort.computeSize("y");
        case this.isString(/rem$/):
          return this.getNumber() * this.getRem();
        case this.isString(/em$/):
          return this.getNumber() * this.getEm();
        case this.isString(/ex$/):
          return this.getNumber() * this.getEm() / 2;
        case this.isString(/px$/):
          return this.getNumber();
        case this.isString(/pt$/):
          return this.getNumber() * this.getDpi() * (1 / 72);
        case this.isString(/pc$/):
          return this.getNumber() * 15;
        case this.isString(/cm$/):
          return this.getNumber() * this.getDpi() / 2.54;
        case this.isString(/mm$/):
          return this.getNumber() * this.getDpi() / 25.4;
        case this.isString(/in$/):
          return this.getNumber() * this.getDpi();
        case (this.isString(/%$/) && isFontSize):
          return this.getNumber() * this.getEm();
        case this.isString(/%$/):
          return this.getNumber() * viewPort.computeSize(axis);
        default: {
          var n2 = this.getNumber();
          if (processPercent && n2 < 1) {
            return n2 * viewPort.computeSize(axis);
          }
          return n2;
        }
      }
    }
    getMilliseconds() {
      if (!this.hasValue()) {
        return 0;
      }
      if (this.isString(/ms$/)) {
        return this.getNumber();
      }
      return this.getNumber() * 1e3;
    }
    getRadians() {
      if (!this.hasValue()) {
        return 0;
      }
      switch (true) {
        case this.isString(/deg$/):
          return this.getNumber() * (Math.PI / 180);
        case this.isString(/grad$/):
          return this.getNumber() * (Math.PI / 200);
        case this.isString(/rad$/):
          return this.getNumber();
        default:
          return this.getNumber() * (Math.PI / 180);
      }
    }
    getDefinition() {
      var asString2 = this.getString();
      var name = /#([^)'"]+)/.exec(asString2);
      if (name) {
        name = name[1];
      }
      if (!name) {
        name = asString2;
      }
      return this.document.definitions[name];
    }
    getFillStyleDefinition(element, opacity2) {
      var def = this.getDefinition();
      if (!def) {
        return null;
      }
      if (typeof def.createGradient === "function") {
        return def.createGradient(this.document.ctx, element, opacity2);
      }
      if (typeof def.createPattern === "function") {
        if (def.getHrefAttribute().hasValue()) {
          var patternTransform = def.getAttribute("patternTransform");
          def = def.getHrefAttribute().getDefinition();
          if (patternTransform.hasValue()) {
            def.getAttribute("patternTransform", true).setValue(patternTransform.value);
          }
        }
        return def.createPattern(this.document.ctx, element, opacity2);
      }
      return null;
    }
    getTextBaseline() {
      if (!this.hasValue()) {
        return null;
      }
      return Property.textBaselineMapping[this.getString()];
    }
    addOpacity(opacity2) {
      var value = this.getColor();
      var len = value.length;
      var commas = 0;
      for (var i2 = 0; i2 < len; i2++) {
        if (value[i2] === ",") {
          commas++;
        }
        if (commas === 3) {
          break;
        }
      }
      if (opacity2.hasValue() && this.isString() && commas !== 3) {
        var color2 = new RGBColor$1(value);
        if (color2.ok) {
          color2.alpha = opacity2.getNumber();
          value = color2.toRGBA();
        }
      }
      return new Property(this.document, this.name, value);
    }
  }
  Property.textBaselineMapping = {
    "baseline": "alphabetic",
    "before-edge": "top",
    "text-before-edge": "top",
    "middle": "middle",
    "central": "middle",
    "after-edge": "bottom",
    "text-after-edge": "bottom",
    "ideographic": "ideographic",
    "alphabetic": "alphabetic",
    "hanging": "hanging",
    "mathematical": "alphabetic"
  };
  class ViewPort {
    constructor() {
      this.viewPorts = [];
    }
    clear() {
      this.viewPorts = [];
    }
    setCurrent(width, height) {
      this.viewPorts.push({
        width,
        height
      });
    }
    removeCurrent() {
      this.viewPorts.pop();
    }
    getCurrent() {
      var {
        viewPorts
      } = this;
      return viewPorts[viewPorts.length - 1];
    }
    get width() {
      return this.getCurrent().width;
    }
    get height() {
      return this.getCurrent().height;
    }
    computeSize(d2) {
      if (typeof d2 === "number") {
        return d2;
      }
      if (d2 === "x") {
        return this.width;
      }
      if (d2 === "y") {
        return this.height;
      }
      return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
    }
  }
  class Point {
    constructor(x2, y2) {
      this.x = x2;
      this.y = y2;
    }
    static parse(point) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
      var [x2 = defaultValue, y2 = defaultValue] = toNumbers(point);
      return new Point(x2, y2);
    }
    static parseScale(scale) {
      var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      var [x2 = defaultValue, y2 = x2] = toNumbers(scale);
      return new Point(x2, y2);
    }
    static parsePath(path) {
      var points = toNumbers(path);
      var len = points.length;
      var pathPoints = [];
      for (var i2 = 0; i2 < len; i2 += 2) {
        pathPoints.push(new Point(points[i2], points[i2 + 1]));
      }
      return pathPoints;
    }
    angleTo(point) {
      return Math.atan2(point.y - this.y, point.x - this.x);
    }
    applyTransform(transform2) {
      var {
        x: x2,
        y: y2
      } = this;
      var xp = x2 * transform2[0] + y2 * transform2[2] + transform2[4];
      var yp = x2 * transform2[1] + y2 * transform2[3] + transform2[5];
      this.x = xp;
      this.y = yp;
    }
  }
  class Mouse {
    constructor(screen) {
      this.screen = screen;
      this.working = false;
      this.events = [];
      this.eventElements = [];
      this.onClick = this.onClick.bind(this);
      this.onMouseMove = this.onMouseMove.bind(this);
    }
    isWorking() {
      return this.working;
    }
    start() {
      if (this.working) {
        return;
      }
      var {
        screen,
        onClick,
        onMouseMove
      } = this;
      var canvas = screen.ctx.canvas;
      canvas.onclick = onClick;
      canvas.onmousemove = onMouseMove;
      this.working = true;
    }
    stop() {
      if (!this.working) {
        return;
      }
      var canvas = this.screen.ctx.canvas;
      this.working = false;
      canvas.onclick = null;
      canvas.onmousemove = null;
    }
    hasEvents() {
      return this.working && this.events.length > 0;
    }
    runEvents() {
      if (!this.working) {
        return;
      }
      var {
        screen: document2,
        events,
        eventElements
      } = this;
      var {
        style
      } = document2.ctx.canvas;
      if (style) {
        style.cursor = "";
      }
      events.forEach((_ref, i2) => {
        var {
          run
        } = _ref;
        var element = eventElements[i2];
        while (element) {
          run(element);
          element = element.parent;
        }
      });
      this.events = [];
      this.eventElements = [];
    }
    checkPath(element, ctx) {
      if (!this.working || !ctx) {
        return;
      }
      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref2, i2) => {
        var {
          x: x2,
          y: y2
        } = _ref2;
        if (!eventElements[i2] && ctx.isPointInPath && ctx.isPointInPath(x2, y2)) {
          eventElements[i2] = element;
        }
      });
    }
    checkBoundingBox(element, boundingBox) {
      if (!this.working || !boundingBox) {
        return;
      }
      var {
        events,
        eventElements
      } = this;
      events.forEach((_ref3, i2) => {
        var {
          x: x2,
          y: y2
        } = _ref3;
        if (!eventElements[i2] && boundingBox.isPointInBox(x2, y2)) {
          eventElements[i2] = element;
        }
      });
    }
    mapXY(x2, y2) {
      var {
        window: window2,
        ctx
      } = this.screen;
      var point = new Point(x2, y2);
      var element = ctx.canvas;
      while (element) {
        point.x -= element.offsetLeft;
        point.y -= element.offsetTop;
        element = element.offsetParent;
      }
      if (window2.scrollX) {
        point.x += window2.scrollX;
      }
      if (window2.scrollY) {
        point.y += window2.scrollY;
      }
      return point;
    }
    onClick(event) {
      var {
        x: x2,
        y: y2
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: "onclick",
        x: x2,
        y: y2,
        run(eventTarget) {
          if (eventTarget.onClick) {
            eventTarget.onClick();
          }
        }
      });
    }
    onMouseMove(event) {
      var {
        x: x2,
        y: y2
      } = this.mapXY(event.clientX, event.clientY);
      this.events.push({
        type: "onmousemove",
        x: x2,
        y: y2,
        run(eventTarget) {
          if (eventTarget.onMouseMove) {
            eventTarget.onMouseMove();
          }
        }
      });
    }
  }
  var defaultWindow = typeof window !== "undefined" ? window : null;
  var defaultFetch$1 = typeof fetch !== "undefined" ? fetch.bind(void 0) : null;
  class Screen {
    constructor(ctx) {
      var {
        fetch: fetch2 = defaultFetch$1,
        window: window2 = defaultWindow
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.ctx = ctx;
      this.FRAMERATE = 30;
      this.MAX_VIRTUAL_PIXELS = 3e4;
      this.CLIENT_WIDTH = 800;
      this.CLIENT_HEIGHT = 600;
      this.viewPort = new ViewPort();
      this.mouse = new Mouse(this);
      this.animations = [];
      this.waits = [];
      this.frameDuration = 0;
      this.isReadyLock = false;
      this.isFirstRender = true;
      this.intervalId = null;
      this.window = window2;
      this.fetch = fetch2;
    }
    wait(checker) {
      this.waits.push(checker);
    }
    ready() {
      if (!this.readyPromise) {
        return Promise.resolve();
      }
      return this.readyPromise;
    }
    isReady() {
      if (this.isReadyLock) {
        return true;
      }
      var isReadyLock = this.waits.every((_2) => _2());
      if (isReadyLock) {
        this.waits = [];
        if (this.resolveReady) {
          this.resolveReady();
        }
      }
      this.isReadyLock = isReadyLock;
      return isReadyLock;
    }
    setDefaults(ctx) {
      ctx.strokeStyle = "rgba(0,0,0,0)";
      ctx.lineCap = "butt";
      ctx.lineJoin = "miter";
      ctx.miterLimit = 4;
    }
    setViewBox(_ref) {
      var {
        document: document2,
        ctx,
        aspectRatio,
        width,
        desiredWidth,
        height,
        desiredHeight,
        minX = 0,
        minY = 0,
        refX,
        refY,
        clip = false,
        clipX = 0,
        clipY = 0
      } = _ref;
      var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\s/, "");
      var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(" ");
      var align = aspectRatioAlign || "xMidYMid";
      var meetOrSlice = aspectRatioMeetOrSlice || "meet";
      var scaleX = width / desiredWidth;
      var scaleY = height / desiredHeight;
      var scaleMin = Math.min(scaleX, scaleY);
      var scaleMax = Math.max(scaleX, scaleY);
      var finalDesiredWidth = desiredWidth;
      var finalDesiredHeight = desiredHeight;
      if (meetOrSlice === "meet") {
        finalDesiredWidth *= scaleMin;
        finalDesiredHeight *= scaleMin;
      }
      if (meetOrSlice === "slice") {
        finalDesiredWidth *= scaleMax;
        finalDesiredHeight *= scaleMax;
      }
      var refXProp = new Property(document2, "refX", refX);
      var refYProp = new Property(document2, "refY", refY);
      var hasRefs = refXProp.hasValue() && refYProp.hasValue();
      if (hasRefs) {
        ctx.translate(-scaleMin * refXProp.getPixels("x"), -scaleMin * refYProp.getPixels("y"));
      }
      if (clip) {
        var scaledClipX = scaleMin * clipX;
        var scaledClipY = scaleMin * clipY;
        ctx.beginPath();
        ctx.moveTo(scaledClipX, scaledClipY);
        ctx.lineTo(width, scaledClipY);
        ctx.lineTo(width, height);
        ctx.lineTo(scaledClipX, height);
        ctx.closePath();
        ctx.clip();
      }
      if (!hasRefs) {
        var isMeetMinY = meetOrSlice === "meet" && scaleMin === scaleY;
        var isSliceMaxY = meetOrSlice === "slice" && scaleMax === scaleY;
        var isMeetMinX = meetOrSlice === "meet" && scaleMin === scaleX;
        var isSliceMaxX = meetOrSlice === "slice" && scaleMax === scaleX;
        if (align.startsWith("xMid") && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width / 2 - finalDesiredWidth / 2, 0);
        }
        if (align.endsWith("YMid") && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height / 2 - finalDesiredHeight / 2);
        }
        if (align.startsWith("xMax") && (isMeetMinY || isSliceMaxY)) {
          ctx.translate(width - finalDesiredWidth, 0);
        }
        if (align.endsWith("YMax") && (isMeetMinX || isSliceMaxX)) {
          ctx.translate(0, height - finalDesiredHeight);
        }
      }
      switch (true) {
        case align === "none":
          ctx.scale(scaleX, scaleY);
          break;
        case meetOrSlice === "meet":
          ctx.scale(scaleMin, scaleMin);
          break;
        case meetOrSlice === "slice":
          ctx.scale(scaleMax, scaleMax);
          break;
      }
      ctx.translate(-minX, -minY);
    }
    start(element) {
      var {
        enableRedraw = false,
        ignoreMouse = false,
        ignoreAnimation = false,
        ignoreDimensions = false,
        ignoreClear = false,
        forceRedraw,
        scaleWidth,
        scaleHeight,
        offsetX,
        offsetY
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var {
        FRAMERATE,
        mouse
      } = this;
      var frameDuration = 1e3 / FRAMERATE;
      this.frameDuration = frameDuration;
      this.readyPromise = new Promise((resolve) => {
        this.resolveReady = resolve;
      });
      if (this.isReady()) {
        this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
      }
      if (!enableRedraw) {
        return;
      }
      var now = Date.now();
      var then = now;
      var delta = 0;
      var tick = () => {
        now = Date.now();
        delta = now - then;
        if (delta >= frameDuration) {
          then = now - delta % frameDuration;
          if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {
            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);
            mouse.runEvents();
          }
        }
        this.intervalId = requestAnimationFrame$1(tick);
      };
      if (!ignoreMouse) {
        mouse.start();
      }
      this.intervalId = requestAnimationFrame$1(tick);
    }
    stop() {
      if (this.intervalId) {
        requestAnimationFrame$1.cancel(this.intervalId);
        this.intervalId = null;
      }
      this.mouse.stop();
    }
    shouldUpdate(ignoreAnimation, forceRedraw) {
      if (!ignoreAnimation) {
        var {
          frameDuration
        } = this;
        var shouldUpdate = this.animations.reduce((shouldUpdate2, animation) => animation.update(frameDuration) || shouldUpdate2, false);
        if (shouldUpdate) {
          return true;
        }
      }
      if (typeof forceRedraw === "function" && forceRedraw()) {
        return true;
      }
      if (!this.isReadyLock && this.isReady()) {
        return true;
      }
      if (this.mouse.hasEvents()) {
        return true;
      }
      return false;
    }
    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {
      var {
        CLIENT_WIDTH,
        CLIENT_HEIGHT,
        viewPort,
        ctx,
        isFirstRender
      } = this;
      var canvas = ctx.canvas;
      viewPort.clear();
      if (canvas.width && canvas.height) {
        viewPort.setCurrent(canvas.width, canvas.height);
      } else {
        viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);
      }
      var widthStyle = element.getStyle("width");
      var heightStyle = element.getStyle("height");
      if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== "number" && typeof scaleHeight !== "number")) {
        if (widthStyle.hasValue()) {
          canvas.width = widthStyle.getPixels("x");
          if (canvas.style) {
            canvas.style.width = "".concat(canvas.width, "px");
          }
        }
        if (heightStyle.hasValue()) {
          canvas.height = heightStyle.getPixels("y");
          if (canvas.style) {
            canvas.style.height = "".concat(canvas.height, "px");
          }
        }
      }
      var cWidth = canvas.clientWidth || canvas.width;
      var cHeight = canvas.clientHeight || canvas.height;
      if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {
        cWidth = widthStyle.getPixels("x");
        cHeight = heightStyle.getPixels("y");
      }
      viewPort.setCurrent(cWidth, cHeight);
      if (typeof offsetX === "number") {
        element.getAttribute("x", true).setValue(offsetX);
      }
      if (typeof offsetY === "number") {
        element.getAttribute("y", true).setValue(offsetY);
      }
      if (typeof scaleWidth === "number" || typeof scaleHeight === "number") {
        var viewBox = toNumbers(element.getAttribute("viewBox").getString());
        var xRatio = 0;
        var yRatio = 0;
        if (typeof scaleWidth === "number") {
          var _widthStyle = element.getStyle("width");
          if (_widthStyle.hasValue()) {
            xRatio = _widthStyle.getPixels("x") / scaleWidth;
          } else if (!isNaN(viewBox[2])) {
            xRatio = viewBox[2] / scaleWidth;
          }
        }
        if (typeof scaleHeight === "number") {
          var _heightStyle = element.getStyle("height");
          if (_heightStyle.hasValue()) {
            yRatio = _heightStyle.getPixels("y") / scaleHeight;
          } else if (!isNaN(viewBox[3])) {
            yRatio = viewBox[3] / scaleHeight;
          }
        }
        if (!xRatio) {
          xRatio = yRatio;
        }
        if (!yRatio) {
          yRatio = xRatio;
        }
        element.getAttribute("width", true).setValue(scaleWidth);
        element.getAttribute("height", true).setValue(scaleHeight);
        var transformStyle = element.getStyle("transform", true, true);
        transformStyle.setValue("".concat(transformStyle.getString(), " scale(").concat(1 / xRatio, ", ").concat(1 / yRatio, ")"));
      }
      if (!ignoreClear) {
        ctx.clearRect(0, 0, cWidth, cHeight);
      }
      element.render(ctx);
      if (isFirstRender) {
        this.isFirstRender = false;
      }
    }
  }
  Screen.defaultWindow = defaultWindow;
  Screen.defaultFetch = defaultFetch$1;
  var {
    defaultFetch
  } = Screen;
  var DefaultDOMParser = typeof DOMParser !== "undefined" ? DOMParser : null;
  class Parser {
    constructor() {
      var {
        fetch: fetch2 = defaultFetch,
        DOMParser: DOMParser2 = DefaultDOMParser
      } = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      this.fetch = fetch2;
      this.DOMParser = DOMParser2;
    }
    parse(resource) {
      var _this = this;
      return _asyncToGenerator(function* () {
        if (resource.startsWith("<")) {
          return _this.parseFromString(resource);
        }
        return _this.load(resource);
      })();
    }
    parseFromString(xml2) {
      var parser = new this.DOMParser();
      try {
        return this.checkDocument(parser.parseFromString(xml2, "image/svg+xml"));
      } catch (err) {
        return this.checkDocument(parser.parseFromString(xml2, "text/xml"));
      }
    }
    checkDocument(document2) {
      var parserError = document2.getElementsByTagName("parsererror")[0];
      if (parserError) {
        throw new Error(parserError.textContent);
      }
      return document2;
    }
    load(url) {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        var response = yield _this2.fetch(url);
        var xml2 = yield response.text();
        return _this2.parseFromString(xml2);
      })();
    }
  }
  class Translate {
    constructor(_2, point) {
      this.type = "translate";
      this.point = null;
      this.point = Point.parse(point);
    }
    apply(ctx) {
      var {
        x: x2,
        y: y2
      } = this.point;
      ctx.translate(x2 || 0, y2 || 0);
    }
    unapply(ctx) {
      var {
        x: x2,
        y: y2
      } = this.point;
      ctx.translate(-1 * x2 || 0, -1 * y2 || 0);
    }
    applyToPoint(point) {
      var {
        x: x2,
        y: y2
      } = this.point;
      point.applyTransform([1, 0, 0, 1, x2 || 0, y2 || 0]);
    }
  }
  class Rotate {
    constructor(document2, rotate, transformOrigin2) {
      this.type = "rotate";
      this.angle = null;
      this.originX = null;
      this.originY = null;
      this.cx = 0;
      this.cy = 0;
      var numbers = toNumbers(rotate);
      this.angle = new Property(document2, "angle", numbers[0]);
      this.originX = transformOrigin2[0];
      this.originY = transformOrigin2[1];
      this.cx = numbers[1] || 0;
      this.cy = numbers[2] || 0;
    }
    apply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle: angle2
      } = this;
      var tx = cx + originX.getPixels("x");
      var ty = cy + originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.rotate(angle2.getRadians());
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        cx,
        cy,
        originX,
        originY,
        angle: angle2
      } = this;
      var tx = cx + originX.getPixels("x");
      var ty = cy + originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.rotate(-1 * angle2.getRadians());
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      var {
        cx,
        cy,
        angle: angle2
      } = this;
      var rad = angle2.getRadians();
      point.applyTransform([
        1,
        0,
        0,
        1,
        cx || 0,
        cy || 0
        // this.p.y
      ]);
      point.applyTransform([Math.cos(rad), Math.sin(rad), -Math.sin(rad), Math.cos(rad), 0, 0]);
      point.applyTransform([
        1,
        0,
        0,
        1,
        -cx || 0,
        -cy || 0
        // -this.p.y
      ]);
    }
  }
  class Scale {
    constructor(_2, scale, transformOrigin2) {
      this.type = "scale";
      this.scale = null;
      this.originX = null;
      this.originY = null;
      var scaleSize = Point.parseScale(scale);
      if (scaleSize.x === 0 || scaleSize.y === 0) {
        scaleSize.x = PSEUDO_ZERO;
        scaleSize.y = PSEUDO_ZERO;
      }
      this.scale = scaleSize;
      this.originX = transformOrigin2[0];
      this.originY = transformOrigin2[1];
    }
    apply(ctx) {
      var {
        scale: {
          x: x2,
          y: y2
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.scale(x2, y2 || x2);
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        scale: {
          x: x2,
          y: y2
        },
        originX,
        originY
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.scale(1 / x2, 1 / y2 || x2);
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      var {
        x: x2,
        y: y2
      } = this.scale;
      point.applyTransform([x2 || 0, 0, 0, y2 || 0, 0, 0]);
    }
  }
  class Matrix {
    constructor(_2, matrix2, transformOrigin2) {
      this.type = "matrix";
      this.matrix = [];
      this.originX = null;
      this.originY = null;
      this.matrix = toNumbers(matrix2);
      this.originX = transformOrigin2[0];
      this.originY = transformOrigin2[1];
    }
    apply(ctx) {
      var {
        originX,
        originY,
        matrix: matrix2
      } = this;
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.transform(matrix2[0], matrix2[1], matrix2[2], matrix2[3], matrix2[4], matrix2[5]);
      ctx.translate(-tx, -ty);
    }
    unapply(ctx) {
      var {
        originX,
        originY,
        matrix: matrix2
      } = this;
      var a2 = matrix2[0];
      var b2 = matrix2[2];
      var c2 = matrix2[4];
      var d2 = matrix2[1];
      var e2 = matrix2[3];
      var f2 = matrix2[5];
      var g2 = 0;
      var h2 = 0;
      var i2 = 1;
      var det = 1 / (a2 * (e2 * i2 - f2 * h2) - b2 * (d2 * i2 - f2 * g2) + c2 * (d2 * h2 - e2 * g2));
      var tx = originX.getPixels("x");
      var ty = originY.getPixels("y");
      ctx.translate(tx, ty);
      ctx.transform(det * (e2 * i2 - f2 * h2), det * (f2 * g2 - d2 * i2), det * (c2 * h2 - b2 * i2), det * (a2 * i2 - c2 * g2), det * (b2 * f2 - c2 * e2), det * (c2 * d2 - a2 * f2));
      ctx.translate(-tx, -ty);
    }
    applyToPoint(point) {
      point.applyTransform(this.matrix);
    }
  }
  class Skew extends Matrix {
    constructor(document2, skew, transformOrigin2) {
      super(document2, skew, transformOrigin2);
      this.type = "skew";
      this.angle = null;
      this.angle = new Property(document2, "angle", skew);
    }
  }
  class SkewX extends Skew {
    constructor(document2, skew, transformOrigin2) {
      super(document2, skew, transformOrigin2);
      this.type = "skewX";
      this.matrix = [1, 0, Math.tan(this.angle.getRadians()), 1, 0, 0];
    }
  }
  class SkewY extends Skew {
    constructor(document2, skew, transformOrigin2) {
      super(document2, skew, transformOrigin2);
      this.type = "skewY";
      this.matrix = [1, Math.tan(this.angle.getRadians()), 0, 1, 0, 0];
    }
  }
  function parseTransforms(transform2) {
    return compressSpaces(transform2).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
  }
  function parseTransform(transform2) {
    var [type, value] = transform2.split("(");
    return [type.trim(), value.trim().replace(")", "")];
  }
  class Transform {
    constructor(document2, transform2, transformOrigin2) {
      this.document = document2;
      this.transforms = [];
      var data = parseTransforms(transform2);
      data.forEach((transform3) => {
        if (transform3 === "none") {
          return;
        }
        var [type, value] = parseTransform(transform3);
        var TransformType = Transform.transformTypes[type];
        if (typeof TransformType !== "undefined") {
          this.transforms.push(new TransformType(this.document, value, transformOrigin2));
        }
      });
    }
    static fromElement(document2, element) {
      var transformStyle = element.getStyle("transform", false, true);
      var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle("transform-origin", false, true).split();
      var transformOrigin2 = [transformOriginXProperty, transformOriginYProperty];
      if (transformStyle.hasValue()) {
        return new Transform(document2, transformStyle.getString(), transformOrigin2);
      }
      return null;
    }
    apply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = 0; i2 < len; i2++) {
        transforms[i2].apply(ctx);
      }
    }
    unapply(ctx) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = len - 1; i2 >= 0; i2--) {
        transforms[i2].unapply(ctx);
      }
    }
    // TODO: applyToPoint unused ... remove?
    applyToPoint(point) {
      var {
        transforms
      } = this;
      var len = transforms.length;
      for (var i2 = 0; i2 < len; i2++) {
        transforms[i2].applyToPoint(point);
      }
    }
  }
  Transform.transformTypes = {
    translate: Translate,
    rotate: Rotate,
    scale: Scale,
    matrix: Matrix,
    skewX: SkewX,
    skewY: SkewY
  };
  class Element {
    constructor(document2, node2) {
      var captureTextNodes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.document = document2;
      this.node = node2;
      this.captureTextNodes = captureTextNodes;
      this.attributes = /* @__PURE__ */ Object.create(null);
      this.styles = /* @__PURE__ */ Object.create(null);
      this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
      this.animationFrozen = false;
      this.animationFrozenValue = "";
      this.parent = null;
      this.children = [];
      if (!node2 || node2.nodeType !== 1) {
        return;
      }
      Array.from(node2.attributes).forEach((attribute) => {
        var nodeName = normalizeAttributeName(attribute.nodeName);
        this.attributes[nodeName] = new Property(document2, nodeName, attribute.value);
      });
      this.addStylesFromStyleDefinition();
      if (this.getAttribute("style").hasValue()) {
        var styles = this.getAttribute("style").getString().split(";").map((_2) => _2.trim());
        styles.forEach((style) => {
          if (!style) {
            return;
          }
          var [name, value] = style.split(":").map((_2) => _2.trim());
          this.styles[name] = new Property(document2, name, value);
        });
      }
      var {
        definitions
      } = document2;
      var id = this.getAttribute("id");
      if (id.hasValue()) {
        if (!definitions[id.getString()]) {
          definitions[id.getString()] = this;
        }
      }
      Array.from(node2.childNodes).forEach((childNode) => {
        if (childNode.nodeType === 1) {
          this.addChild(childNode);
        } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {
          var textNode = document2.createTextNode(childNode);
          if (textNode.getText().length > 0) {
            this.addChild(textNode);
          }
        }
      });
    }
    getAttribute(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var attr = this.attributes[name];
      if (!attr && createIfNotExists) {
        var _attr = new Property(this.document, name, "");
        this.attributes[name] = _attr;
        return _attr;
      }
      return attr || Property.empty(this.document);
    }
    getHrefAttribute() {
      for (var key in this.attributes) {
        if (key === "href" || key.endsWith(":href")) {
          return this.attributes[key];
        }
      }
      return Property.empty(this.document);
    }
    getStyle(name) {
      var createIfNotExists = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var skipAncestors = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var style = this.styles[name];
      if (style) {
        return style;
      }
      var attr = this.getAttribute(name);
      if (attr !== null && attr !== void 0 && attr.hasValue()) {
        this.styles[name] = attr;
        return attr;
      }
      if (!skipAncestors) {
        var {
          parent
        } = this;
        if (parent) {
          var parentStyle = parent.getStyle(name);
          if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {
            return parentStyle;
          }
        }
      }
      if (createIfNotExists) {
        var _style = new Property(this.document, name, "");
        this.styles[name] = _style;
        return _style;
      }
      return style || Property.empty(this.document);
    }
    render(ctx) {
      if (this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden") {
        return;
      }
      ctx.save();
      if (this.getStyle("mask").hasValue()) {
        var mask = this.getStyle("mask").getDefinition();
        if (mask) {
          this.applyEffects(ctx);
          mask.apply(ctx, this);
        }
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        var filter = this.getStyle("filter").getDefinition();
        if (filter) {
          this.applyEffects(ctx);
          filter.apply(ctx, this);
        }
      } else {
        this.setContext(ctx);
        this.renderChildren(ctx);
        this.clearContext(ctx);
      }
      ctx.restore();
    }
    setContext(_2) {
    }
    applyEffects(ctx) {
      var transform2 = Transform.fromElement(this.document, this);
      if (transform2) {
        transform2.apply(ctx);
      }
      var clipPathStyleProp = this.getStyle("clip-path", false, true);
      if (clipPathStyleProp.hasValue()) {
        var clip = clipPathStyleProp.getDefinition();
        if (clip) {
          clip.apply(ctx);
        }
      }
    }
    clearContext(_2) {
    }
    renderChildren(ctx) {
      this.children.forEach((child) => {
        child.render(ctx);
      });
    }
    addChild(childNode) {
      var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);
      child.parent = this;
      if (!Element.ignoreChildTypes.includes(child.type)) {
        this.children.push(child);
      }
    }
    matchesSelector(selector) {
      var _node$getAttribute;
      var {
        node: node2
      } = this;
      if (typeof node2.matches === "function") {
        return node2.matches(selector);
      }
      var styleClasses = (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "class");
      if (!styleClasses || styleClasses === "") {
        return false;
      }
      return styleClasses.split(" ").some((styleClass) => ".".concat(styleClass) === selector);
    }
    addStylesFromStyleDefinition() {
      var {
        styles,
        stylesSpecificity
      } = this.document;
      for (var selector in styles) {
        if (!selector.startsWith("@") && this.matchesSelector(selector)) {
          var style = styles[selector];
          var specificity = stylesSpecificity[selector];
          if (style) {
            for (var name in style) {
              var existingSpecificity = this.stylesSpecificity[name];
              if (typeof existingSpecificity === "undefined") {
                existingSpecificity = "000";
              }
              if (specificity >= existingSpecificity) {
                this.styles[name] = style[name];
                this.stylesSpecificity[name] = specificity;
              }
            }
          }
        }
      }
    }
    removeStyles(element, ignoreStyles) {
      var toRestore = ignoreStyles.reduce((toRestore2, name) => {
        var styleProp = element.getStyle(name);
        if (!styleProp.hasValue()) {
          return toRestore2;
        }
        var value = styleProp.getString();
        styleProp.setValue("");
        return [...toRestore2, [name, value]];
      }, []);
      return toRestore;
    }
    restoreStyles(element, styles) {
      styles.forEach((_ref) => {
        var [name, value] = _ref;
        element.getStyle(name, true).setValue(value);
      });
    }
    isFirstChild() {
      var _this$parent;
      return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;
    }
  }
  Element.ignoreChildTypes = ["title"];
  class UnknownElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
    }
  }
  function wrapFontFamily(fontFamily2) {
    var trimmed = fontFamily2.trim();
    return /^('|")/.test(trimmed) ? trimmed : '"'.concat(trimmed, '"');
  }
  function prepareFontFamily(fontFamily2) {
    return typeof process === "undefined" ? fontFamily2 : fontFamily2.trim().split(",").map(wrapFontFamily).join(",");
  }
  function prepareFontStyle(fontStyle2) {
    if (!fontStyle2) {
      return "";
    }
    var targetFontStyle = fontStyle2.trim().toLowerCase();
    switch (targetFontStyle) {
      case "normal":
      case "italic":
      case "oblique":
      case "inherit":
      case "initial":
      case "unset":
        return targetFontStyle;
      default:
        if (/^oblique\s+(-|)\d+deg$/.test(targetFontStyle)) {
          return targetFontStyle;
        }
        return "";
    }
  }
  function prepareFontWeight(fontWeight2) {
    if (!fontWeight2) {
      return "";
    }
    var targetFontWeight = fontWeight2.trim().toLowerCase();
    switch (targetFontWeight) {
      case "normal":
      case "bold":
      case "lighter":
      case "bolder":
      case "inherit":
      case "initial":
      case "unset":
        return targetFontWeight;
      default:
        if (/^[\d.]+$/.test(targetFontWeight)) {
          return targetFontWeight;
        }
        return "";
    }
  }
  class Font {
    constructor(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit) {
      var inheritFont = inherit ? typeof inherit === "string" ? Font.parse(inherit) : inherit : {};
      this.fontFamily = fontFamily2 || inheritFont.fontFamily;
      this.fontSize = fontSize2 || inheritFont.fontSize;
      this.fontStyle = fontStyle2 || inheritFont.fontStyle;
      this.fontWeight = fontWeight2 || inheritFont.fontWeight;
      this.fontVariant = fontVariant2 || inheritFont.fontVariant;
    }
    static parse() {
      var font = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
      var inherit = arguments.length > 1 ? arguments[1] : void 0;
      var fontStyle2 = "";
      var fontVariant2 = "";
      var fontWeight2 = "";
      var fontSize2 = "";
      var fontFamily2 = "";
      var parts = compressSpaces(font).trim().split(" ");
      var set = {
        fontSize: false,
        fontStyle: false,
        fontWeight: false,
        fontVariant: false
      };
      parts.forEach((part) => {
        switch (true) {
          case (!set.fontStyle && Font.styles.includes(part)):
            if (part !== "inherit") {
              fontStyle2 = part;
            }
            set.fontStyle = true;
            break;
          case (!set.fontVariant && Font.variants.includes(part)):
            if (part !== "inherit") {
              fontVariant2 = part;
            }
            set.fontStyle = true;
            set.fontVariant = true;
            break;
          case (!set.fontWeight && Font.weights.includes(part)):
            if (part !== "inherit") {
              fontWeight2 = part;
            }
            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            break;
          case !set.fontSize:
            if (part !== "inherit") {
              [fontSize2] = part.split("/");
            }
            set.fontStyle = true;
            set.fontVariant = true;
            set.fontWeight = true;
            set.fontSize = true;
            break;
          default:
            if (part !== "inherit") {
              fontFamily2 += part;
            }
        }
      });
      return new Font(fontStyle2, fontVariant2, fontWeight2, fontSize2, fontFamily2, inherit);
    }
    toString() {
      return [
        prepareFontStyle(this.fontStyle),
        this.fontVariant,
        prepareFontWeight(this.fontWeight),
        this.fontSize,
        // Wrap fontFamily only on nodejs and only for canvas.ctx
        prepareFontFamily(this.fontFamily)
      ].join(" ").trim();
    }
  }
  Font.styles = "normal|italic|oblique|inherit";
  Font.variants = "normal|small-caps|inherit";
  Font.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
  class BoundingBox {
    constructor() {
      var x1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Number.NaN;
      var y1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Number.NaN;
      var x2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Number.NaN;
      var y2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : Number.NaN;
      this.x1 = x1;
      this.y1 = y1;
      this.x2 = x2;
      this.y2 = y2;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }
    get x() {
      return this.x1;
    }
    get y() {
      return this.y1;
    }
    get width() {
      return this.x2 - this.x1;
    }
    get height() {
      return this.y2 - this.y1;
    }
    addPoint(x2, y2) {
      if (typeof x2 !== "undefined") {
        if (isNaN(this.x1) || isNaN(this.x2)) {
          this.x1 = x2;
          this.x2 = x2;
        }
        if (x2 < this.x1) {
          this.x1 = x2;
        }
        if (x2 > this.x2) {
          this.x2 = x2;
        }
      }
      if (typeof y2 !== "undefined") {
        if (isNaN(this.y1) || isNaN(this.y2)) {
          this.y1 = y2;
          this.y2 = y2;
        }
        if (y2 < this.y1) {
          this.y1 = y2;
        }
        if (y2 > this.y2) {
          this.y2 = y2;
        }
      }
    }
    addX(x2) {
      this.addPoint(x2, null);
    }
    addY(y2) {
      this.addPoint(null, y2);
    }
    addBoundingBox(boundingBox) {
      if (!boundingBox) {
        return;
      }
      var {
        x1,
        y1,
        x2,
        y2
      } = boundingBox;
      this.addPoint(x1, y1);
      this.addPoint(x2, y2);
    }
    sumCubic(t2, p0, p1, p2, p3) {
      return Math.pow(1 - t2, 3) * p0 + 3 * Math.pow(1 - t2, 2) * t2 * p1 + 3 * (1 - t2) * Math.pow(t2, 2) * p2 + Math.pow(t2, 3) * p3;
    }
    bezierCurveAdd(forX, p0, p1, p2, p3) {
      var b2 = 6 * p0 - 12 * p1 + 6 * p2;
      var a2 = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
      var c2 = 3 * p1 - 3 * p0;
      if (a2 === 0) {
        if (b2 === 0) {
          return;
        }
        var t2 = -c2 / b2;
        if (0 < t2 && t2 < 1) {
          if (forX) {
            this.addX(this.sumCubic(t2, p0, p1, p2, p3));
          } else {
            this.addY(this.sumCubic(t2, p0, p1, p2, p3));
          }
        }
        return;
      }
      var b2ac = Math.pow(b2, 2) - 4 * c2 * a2;
      if (b2ac < 0) {
        return;
      }
      var t1 = (-b2 + Math.sqrt(b2ac)) / (2 * a2);
      if (0 < t1 && t1 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t1, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t1, p0, p1, p2, p3));
        }
      }
      var t22 = (-b2 - Math.sqrt(b2ac)) / (2 * a2);
      if (0 < t22 && t22 < 1) {
        if (forX) {
          this.addX(this.sumCubic(t22, p0, p1, p2, p3));
        } else {
          this.addY(this.sumCubic(t22, p0, p1, p2, p3));
        }
      }
    }
    // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {
      this.addPoint(p0x, p0y);
      this.addPoint(p3x, p3y);
      this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);
      this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);
    }
    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {
      var cp1x = p0x + 2 / 3 * (p1x - p0x);
      var cp1y = p0y + 2 / 3 * (p1y - p0y);
      var cp2x = cp1x + 1 / 3 * (p2x - p0x);
      var cp2y = cp1y + 1 / 3 * (p2y - p0y);
      this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);
    }
    isPointInBox(x2, y2) {
      var {
        x1,
        y1,
        x2: x22,
        y2: y22
      } = this;
      return x1 <= x2 && x2 <= x22 && y1 <= y2 && y2 <= y22;
    }
  }
  class PathParser extends _ {
    constructor(path) {
      super(path.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, ""));
      this.control = null;
      this.start = null;
      this.current = null;
      this.command = null;
      this.commands = this.commands;
      this.i = -1;
      this.previousCommand = null;
      this.points = [];
      this.angles = [];
    }
    reset() {
      this.i = -1;
      this.command = null;
      this.previousCommand = null;
      this.start = new Point(0, 0);
      this.control = new Point(0, 0);
      this.current = new Point(0, 0);
      this.points = [];
      this.angles = [];
    }
    isEnd() {
      var {
        i: i2,
        commands
      } = this;
      return i2 >= commands.length - 1;
    }
    next() {
      var command = this.commands[++this.i];
      this.previousCommand = this.command;
      this.command = command;
      return command;
    }
    getPoint() {
      var xProp = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x";
      var yProp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
      var point = new Point(this.command[xProp], this.command[yProp]);
      return this.makeAbsolute(point);
    }
    getAsControlPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.control = point;
      return point;
    }
    getAsCurrentPoint(xProp, yProp) {
      var point = this.getPoint(xProp, yProp);
      this.current = point;
      return point;
    }
    getReflectedControlPoint() {
      var previousCommand = this.previousCommand.type;
      if (previousCommand !== _.CURVE_TO && previousCommand !== _.SMOOTH_CURVE_TO && previousCommand !== _.QUAD_TO && previousCommand !== _.SMOOTH_QUAD_TO) {
        return this.current;
      }
      var {
        current: {
          x: cx,
          y: cy
        },
        control: {
          x: ox,
          y: oy
        }
      } = this;
      var point = new Point(2 * cx - ox, 2 * cy - oy);
      return point;
    }
    makeAbsolute(point) {
      if (this.command.relative) {
        var {
          x: x2,
          y: y2
        } = this.current;
        point.x += x2;
        point.y += y2;
      }
      return point;
    }
    addMarker(point, from, priorTo) {
      var {
        points,
        angles
      } = this;
      if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {
        angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);
      }
      this.addMarkerAngle(point, from ? from.angleTo(point) : null);
    }
    addMarkerAngle(point, angle2) {
      this.points.push(point);
      this.angles.push(angle2);
    }
    getMarkerPoints() {
      return this.points;
    }
    getMarkerAngles() {
      var {
        angles
      } = this;
      var len = angles.length;
      for (var i2 = 0; i2 < len; i2++) {
        if (!angles[i2]) {
          for (var j2 = i2 + 1; j2 < len; j2++) {
            if (angles[j2]) {
              angles[i2] = angles[j2];
              break;
            }
          }
        }
      }
      return angles;
    }
  }
  class RenderedElement extends Element {
    constructor() {
      super(...arguments);
      this.modifiedEmSizeStack = false;
    }
    calculateOpacity() {
      var opacity2 = 1;
      var element = this;
      while (element) {
        var opacityStyle = element.getStyle("opacity", false, true);
        if (opacityStyle.hasValue(true)) {
          opacity2 *= opacityStyle.getNumber();
        }
        element = element.parent;
      }
      return opacity2;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      if (!fromMeasure) {
        var fillStyleProp = this.getStyle("fill");
        var fillOpacityStyleProp = this.getStyle("fill-opacity");
        var strokeStyleProp = this.getStyle("stroke");
        var strokeOpacityProp = this.getStyle("stroke-opacity");
        if (fillStyleProp.isUrlDefinition()) {
          var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);
          if (fillStyle) {
            ctx.fillStyle = fillStyle;
          }
        } else if (fillStyleProp.hasValue()) {
          if (fillStyleProp.getString() === "currentColor") {
            fillStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _fillStyle = fillStyleProp.getColor();
          if (_fillStyle !== "inherit") {
            ctx.fillStyle = _fillStyle === "none" ? "rgba(0,0,0,0)" : _fillStyle;
          }
        }
        if (fillOpacityStyleProp.hasValue()) {
          var _fillStyle2 = new Property(this.document, "fill", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();
          ctx.fillStyle = _fillStyle2;
        }
        if (strokeStyleProp.isUrlDefinition()) {
          var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);
          if (strokeStyle) {
            ctx.strokeStyle = strokeStyle;
          }
        } else if (strokeStyleProp.hasValue()) {
          if (strokeStyleProp.getString() === "currentColor") {
            strokeStyleProp.setValue(this.getStyle("color").getColor());
          }
          var _strokeStyle = strokeStyleProp.getString();
          if (_strokeStyle !== "inherit") {
            ctx.strokeStyle = _strokeStyle === "none" ? "rgba(0,0,0,0)" : _strokeStyle;
          }
        }
        if (strokeOpacityProp.hasValue()) {
          var _strokeStyle2 = new Property(this.document, "stroke", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();
          ctx.strokeStyle = _strokeStyle2;
        }
        var strokeWidthStyleProp = this.getStyle("stroke-width");
        if (strokeWidthStyleProp.hasValue()) {
          var newLineWidth = strokeWidthStyleProp.getPixels();
          ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO : newLineWidth;
        }
        var strokeLinecapStyleProp = this.getStyle("stroke-linecap");
        var strokeLinejoinStyleProp = this.getStyle("stroke-linejoin");
        var strokeMiterlimitProp = this.getStyle("stroke-miterlimit");
        var strokeDasharrayStyleProp = this.getStyle("stroke-dasharray");
        var strokeDashoffsetProp = this.getStyle("stroke-dashoffset");
        if (strokeLinecapStyleProp.hasValue()) {
          ctx.lineCap = strokeLinecapStyleProp.getString();
        }
        if (strokeLinejoinStyleProp.hasValue()) {
          ctx.lineJoin = strokeLinejoinStyleProp.getString();
        }
        if (strokeMiterlimitProp.hasValue()) {
          ctx.miterLimit = strokeMiterlimitProp.getNumber();
        }
        if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== "none") {
          var gaps = toNumbers(strokeDasharrayStyleProp.getString());
          if (typeof ctx.setLineDash !== "undefined") {
            ctx.setLineDash(gaps);
          } else if (typeof ctx.webkitLineDash !== "undefined") {
            ctx.webkitLineDash = gaps;
          } else if (typeof ctx.mozDash !== "undefined" && !(gaps.length === 1 && gaps[0] === 0)) {
            ctx.mozDash = gaps;
          }
          var offset = strokeDashoffsetProp.getPixels();
          if (typeof ctx.lineDashOffset !== "undefined") {
            ctx.lineDashOffset = offset;
          } else if (typeof ctx.webkitLineDashOffset !== "undefined") {
            ctx.webkitLineDashOffset = offset;
          } else if (typeof ctx.mozDashOffset !== "undefined") {
            ctx.mozDashOffset = offset;
          }
        }
      }
      this.modifiedEmSizeStack = false;
      if (typeof ctx.font !== "undefined") {
        var fontStyleProp = this.getStyle("font");
        var fontStyleStyleProp = this.getStyle("font-style");
        var fontVariantStyleProp = this.getStyle("font-variant");
        var fontWeightStyleProp = this.getStyle("font-weight");
        var fontSizeStyleProp = this.getStyle("font-size");
        var fontFamilyStyleProp = this.getStyle("font-family");
        var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? "".concat(fontSizeStyleProp.getPixels(true), "px") : "", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));
        fontStyleStyleProp.setValue(font.fontStyle);
        fontVariantStyleProp.setValue(font.fontVariant);
        fontWeightStyleProp.setValue(font.fontWeight);
        fontSizeStyleProp.setValue(font.fontSize);
        fontFamilyStyleProp.setValue(font.fontFamily);
        ctx.font = font.toString();
        if (fontSizeStyleProp.isPixels()) {
          this.document.emSize = fontSizeStyleProp.getPixels();
          this.modifiedEmSizeStack = true;
        }
      }
      if (!fromMeasure) {
        this.applyEffects(ctx);
        ctx.globalAlpha = this.calculateOpacity();
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      if (this.modifiedEmSizeStack) {
        this.document.popEmSize();
      }
    }
  }
  class PathElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "path";
      this.pathParser = null;
      this.pathParser = new PathParser(this.getAttribute("d").getString());
    }
    path(ctx) {
      var {
        pathParser
      } = this;
      var boundingBox = new BoundingBox();
      pathParser.reset();
      if (ctx) {
        ctx.beginPath();
      }
      while (!pathParser.isEnd()) {
        switch (pathParser.next().type) {
          case PathParser.MOVE_TO:
            this.pathM(ctx, boundingBox);
            break;
          case PathParser.LINE_TO:
            this.pathL(ctx, boundingBox);
            break;
          case PathParser.HORIZ_LINE_TO:
            this.pathH(ctx, boundingBox);
            break;
          case PathParser.VERT_LINE_TO:
            this.pathV(ctx, boundingBox);
            break;
          case PathParser.CURVE_TO:
            this.pathC(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            this.pathS(ctx, boundingBox);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(ctx, boundingBox);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            this.pathT(ctx, boundingBox);
            break;
          case PathParser.ARC:
            this.pathA(ctx, boundingBox);
            break;
          case PathParser.CLOSE_PATH:
            this.pathZ(ctx, boundingBox);
            break;
        }
      }
      return boundingBox;
    }
    getBoundingBox(_2) {
      return this.path();
    }
    getMarkers() {
      var {
        pathParser
      } = this;
      var points = pathParser.getMarkerPoints();
      var angles = pathParser.getMarkerAngles();
      var markers = points.map((point, i2) => [point, angles[i2]]);
      return markers;
    }
    renderChildren(ctx) {
      this.path(ctx);
      this.document.screen.mouse.checkPath(this, ctx);
      var fillRuleStyleProp = this.getStyle("fill-rule");
      if (ctx.fillStyle !== "") {
        if (fillRuleStyleProp.getString("inherit") !== "inherit") {
          ctx.fill(fillRuleStyleProp.getString());
        } else {
          ctx.fill();
        }
      }
      if (ctx.strokeStyle !== "") {
        if (this.getAttribute("vector-effect").getString() === "non-scaling-stroke") {
          ctx.save();
          ctx.setTransform(1, 0, 0, 1, 0, 0);
          ctx.stroke();
          ctx.restore();
        } else {
          ctx.stroke();
        }
      }
      var markers = this.getMarkers();
      if (markers) {
        var markersLastIndex = markers.length - 1;
        var markerStartStyleProp = this.getStyle("marker-start");
        var markerMidStyleProp = this.getStyle("marker-mid");
        var markerEndStyleProp = this.getStyle("marker-end");
        if (markerStartStyleProp.isUrlDefinition()) {
          var marker = markerStartStyleProp.getDefinition();
          var [point, angle2] = markers[0];
          marker.render(ctx, point, angle2);
        }
        if (markerMidStyleProp.isUrlDefinition()) {
          var _marker = markerMidStyleProp.getDefinition();
          for (var i2 = 1; i2 < markersLastIndex; i2++) {
            var [_point, _angle] = markers[i2];
            _marker.render(ctx, _point, _angle);
          }
        }
        if (markerEndStyleProp.isUrlDefinition()) {
          var _marker2 = markerEndStyleProp.getDefinition();
          var [_point2, _angle2] = markers[markersLastIndex];
          _marker2.render(ctx, _point2, _angle2);
        }
      }
    }
    static pathM(pathParser) {
      var point = pathParser.getAsCurrentPoint();
      pathParser.start = pathParser.current;
      return {
        point
      };
    }
    pathM(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        point
      } = PathElement.pathM(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.moveTo(x2, y2);
      }
    }
    static pathL(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getAsCurrentPoint();
      return {
        current,
        point
      };
    }
    pathL(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathL(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathH(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point((command.relative ? current.x : 0) + command.x, current.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathH(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathH(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathV(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);
      pathParser.current = point;
      return {
        current,
        point
      };
    }
    pathV(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point
      } = PathElement.pathV(pathParser);
      var {
        x: x2,
        y: y2
      } = point;
      pathParser.addMarker(point, current);
      boundingBox.addPoint(x2, y2);
      if (ctx) {
        ctx.lineTo(x2, y2);
      }
    }
    static pathC(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getPoint("x1", "y1");
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathC(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathS(pathParser) {
      var {
        current
      } = pathParser;
      var point = pathParser.getReflectedControlPoint();
      var controlPoint = pathParser.getAsControlPoint("x2", "y2");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        point,
        controlPoint,
        currentPoint
      };
    }
    pathS(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, point);
      boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathQ(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getAsControlPoint("x1", "y1");
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathQ(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathT(pathParser) {
      var {
        current
      } = pathParser;
      var controlPoint = pathParser.getReflectedControlPoint();
      pathParser.control = controlPoint;
      var currentPoint = pathParser.getAsCurrentPoint();
      return {
        current,
        controlPoint,
        currentPoint
      };
    }
    pathT(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        current,
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      pathParser.addMarker(currentPoint, controlPoint, controlPoint);
      boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      if (ctx) {
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      }
    }
    static pathA(pathParser) {
      var {
        current,
        command
      } = pathParser;
      var {
        rX,
        rY,
        xRot,
        lArcFlag,
        sweepFlag
      } = command;
      var xAxisRotation = xRot * (Math.PI / 180);
      var currentPoint = pathParser.getAsCurrentPoint();
      var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2);
      var l2 = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);
      if (l2 > 1) {
        rX *= Math.sqrt(l2);
        rY *= Math.sqrt(l2);
      }
      var s2 = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));
      if (isNaN(s2)) {
        s2 = 0;
      }
      var cpp = new Point(s2 * rX * currp.y / rY, s2 * -rY * currp.x / rX);
      var centp = new Point((current.x + currentPoint.x) / 2 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
      var a1 = vectorsAngle([1, 0], [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY]);
      var u2 = [(currp.x - cpp.x) / rX, (currp.y - cpp.y) / rY];
      var v2 = [(-currp.x - cpp.x) / rX, (-currp.y - cpp.y) / rY];
      var ad = vectorsAngle(u2, v2);
      if (vectorsRatio(u2, v2) <= -1) {
        ad = Math.PI;
      }
      if (vectorsRatio(u2, v2) >= 1) {
        ad = 0;
      }
      return {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      };
    }
    pathA(ctx, boundingBox) {
      var {
        pathParser
      } = this;
      var {
        currentPoint,
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);
      var dir = 1 - sweepFlag ? 1 : -1;
      var ah = a1 + dir * (ad / 2);
      var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));
      pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);
      pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);
      boundingBox.addPoint(currentPoint.x, currentPoint.y);
      if (ctx && !isNaN(a1) && !isNaN(ad)) {
        var r2 = rX > rY ? rX : rY;
        var sx = rX > rY ? 1 : rX / rY;
        var sy = rX > rY ? rY / rX : 1;
        ctx.translate(centp.x, centp.y);
        ctx.rotate(xAxisRotation);
        ctx.scale(sx, sy);
        ctx.arc(0, 0, r2, a1, a1 + ad, Boolean(1 - sweepFlag));
        ctx.scale(1 / sx, 1 / sy);
        ctx.rotate(-xAxisRotation);
        ctx.translate(-centp.x, -centp.y);
      }
    }
    static pathZ(pathParser) {
      pathParser.current = pathParser.start;
    }
    pathZ(ctx, boundingBox) {
      PathElement.pathZ(this.pathParser);
      if (ctx) {
        if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {
          ctx.closePath();
        }
      }
    }
  }
  class GlyphElement extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "glyph";
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      this.unicode = this.getAttribute("unicode").getString();
      this.arabicForm = this.getAttribute("arabic-form").getString();
    }
  }
  class TextElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === TextElement ? true : captureTextNodes);
      this.type = "text";
      this.x = 0;
      this.y = 0;
      this.measureCache = -1;
    }
    setContext(ctx) {
      var fromMeasure = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      super.setContext(ctx, fromMeasure);
      var textBaseline = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
      if (textBaseline) {
        ctx.textBaseline = textBaseline;
      }
    }
    initializeCoordinates() {
      this.x = 0;
      this.y = 0;
      this.leafTexts = [];
      this.textChunkStart = 0;
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
    }
    getBoundingBox(ctx) {
      if (this.type !== "text") {
        return this.getTElementBoundingBox(ctx);
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      var boundingBox = null;
      this.children.forEach((_2, i2) => {
        var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i2);
        if (!boundingBox) {
          boundingBox = childBoundingBox;
        } else {
          boundingBox.addBoundingBox(childBoundingBox);
        }
      });
      return boundingBox;
    }
    getFontSize() {
      var {
        document: document2,
        parent
      } = this;
      var inheritFontSize = Font.parse(document2.ctx.font).fontSize;
      var fontSize2 = parent.getStyle("font-size").getNumber(inheritFontSize);
      return fontSize2;
    }
    getTElementBoundingBox(ctx) {
      var fontSize2 = this.getFontSize();
      return new BoundingBox(this.x, this.y - fontSize2, this.x + this.measureText(ctx), this.y);
    }
    getGlyph(font, text2, i2) {
      var char = text2[i2];
      var glyph = null;
      if (font.isArabic) {
        var len = text2.length;
        var prevChar = text2[i2 - 1];
        var nextChar = text2[i2 + 1];
        var arabicForm = "isolated";
        if ((i2 === 0 || prevChar === " ") && i2 < len - 1 && nextChar !== " ") {
          arabicForm = "terminal";
        }
        if (i2 > 0 && prevChar !== " " && i2 < len - 1 && nextChar !== " ") {
          arabicForm = "medial";
        }
        if (i2 > 0 && prevChar !== " " && (i2 === len - 1 || nextChar === " ")) {
          arabicForm = "initial";
        }
        if (typeof font.glyphs[char] !== "undefined") {
          var maybeGlyph = font.glyphs[char];
          glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];
        }
      } else {
        glyph = font.glyphs[char];
      }
      if (!glyph) {
        glyph = font.missingGlyph;
      }
      return glyph;
    }
    getText() {
      return "";
    }
    getTextFromNode(node2) {
      var textNode = node2 || this.node;
      var childNodes = Array.from(textNode.parentNode.childNodes);
      var index2 = childNodes.indexOf(textNode);
      var lastIndex = childNodes.length - 1;
      var text2 = compressSpaces(
        // textNode.value
        // || textNode.text
        textNode.textContent || ""
      );
      if (index2 === 0) {
        text2 = trimLeft(text2);
      }
      if (index2 === lastIndex) {
        text2 = trimRight(text2);
      }
      return text2;
    }
    renderChildren(ctx) {
      if (this.type !== "text") {
        this.renderTElementChildren(ctx);
        return;
      }
      this.initializeCoordinates();
      this.adjustChildCoordinatesRecursive(ctx);
      this.children.forEach((_2, i2) => {
        this.renderChild(ctx, this, this, i2);
      });
      var {
        mouse
      } = this.document.screen;
      if (mouse.isWorking()) {
        mouse.checkBoundingBox(this, this.getBoundingBox(ctx));
      }
    }
    renderTElementChildren(ctx) {
      var {
        document: document2,
        parent
      } = this;
      var renderText2 = this.getText();
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var {
          unitsPerEm
        } = customFont.fontFace;
        var ctxFont = Font.parse(document2.ctx.font);
        var fontSize2 = parent.getStyle("font-size").getNumber(ctxFont.fontSize);
        var fontStyle2 = parent.getStyle("font-style").getString(ctxFont.fontStyle);
        var scale = fontSize2 / unitsPerEm;
        var text2 = customFont.isRTL ? renderText2.split("").reverse().join("") : renderText2;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text2.length;
        for (var i2 = 0; i2 < len; i2++) {
          var glyph = this.getGlyph(customFont, text2, i2);
          ctx.translate(this.x, this.y);
          ctx.scale(scale, -scale);
          var lw = ctx.lineWidth;
          ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize2;
          if (fontStyle2 === "italic") {
            ctx.transform(1, 0, 0.4, 1, 0, 0);
          }
          glyph.render(ctx);
          if (fontStyle2 === "italic") {
            ctx.transform(1, 0, -0.4, 1, 0, 0);
          }
          ctx.lineWidth = lw;
          ctx.scale(1 / scale, -1 / scale);
          ctx.translate(-this.x, -this.y);
          this.x += fontSize2 * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;
          if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
            this.x += dx[i2];
          }
        }
        return;
      }
      var {
        x: x2,
        y: y2
      } = this;
      if (ctx.fillStyle) {
        ctx.fillText(renderText2, x2, y2);
      }
      if (ctx.strokeStyle) {
        ctx.strokeText(renderText2, x2, y2);
      }
    }
    applyAnchoring() {
      if (this.textChunkStart >= this.leafTexts.length) {
        return;
      }
      var firstElement = this.leafTexts[this.textChunkStart];
      var textAnchor = firstElement.getStyle("text-anchor").getString("start");
      var isRTL = false;
      var shift = 0;
      if (textAnchor === "start" && !isRTL || textAnchor === "end" && isRTL) {
        shift = firstElement.x - this.minX;
      } else if (textAnchor === "end" && !isRTL || textAnchor === "start" && isRTL) {
        shift = firstElement.x - this.maxX;
      } else {
        shift = firstElement.x - (this.minX + this.maxX) / 2;
      }
      for (var i2 = this.textChunkStart; i2 < this.leafTexts.length; i2++) {
        this.leafTexts[i2].x += shift;
      }
      this.minX = Number.POSITIVE_INFINITY;
      this.maxX = Number.NEGATIVE_INFINITY;
      this.textChunkStart = this.leafTexts.length;
    }
    adjustChildCoordinatesRecursive(ctx) {
      this.children.forEach((_2, i2) => {
        this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i2);
      });
      this.applyAnchoring();
    }
    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (child.children.length > 0) {
        child.children.forEach((_2, i3) => {
          textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i3);
        });
      } else {
        this.adjustChildCoordinates(ctx, textParent, parent, i2);
      }
    }
    adjustChildCoordinates(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (typeof child.measureText !== "function") {
        return child;
      }
      ctx.save();
      child.setContext(ctx, true);
      var xAttr = child.getAttribute("x");
      var yAttr = child.getAttribute("y");
      var dxAttr = child.getAttribute("dx");
      var dyAttr = child.getAttribute("dy");
      var customFont = child.getStyle("font-family").getDefinition();
      var isRTL = Boolean(customFont) && customFont.isRTL;
      if (i2 === 0) {
        if (!xAttr.hasValue()) {
          xAttr.setValue(child.getInheritedAttribute("x"));
        }
        if (!yAttr.hasValue()) {
          yAttr.setValue(child.getInheritedAttribute("y"));
        }
        if (!dxAttr.hasValue()) {
          dxAttr.setValue(child.getInheritedAttribute("dx"));
        }
        if (!dyAttr.hasValue()) {
          dyAttr.setValue(child.getInheritedAttribute("dy"));
        }
      }
      var width = child.measureText(ctx);
      if (isRTL) {
        textParent.x -= width;
      }
      if (xAttr.hasValue()) {
        textParent.applyAnchoring();
        child.x = xAttr.getPixels("x");
        if (dxAttr.hasValue()) {
          child.x += dxAttr.getPixels("x");
        }
      } else {
        if (dxAttr.hasValue()) {
          textParent.x += dxAttr.getPixels("x");
        }
        child.x = textParent.x;
      }
      textParent.x = child.x;
      if (!isRTL) {
        textParent.x += width;
      }
      if (yAttr.hasValue()) {
        child.y = yAttr.getPixels("y");
        if (dyAttr.hasValue()) {
          child.y += dyAttr.getPixels("y");
        }
      } else {
        if (dyAttr.hasValue()) {
          textParent.y += dyAttr.getPixels("y");
        }
        child.y = textParent.y;
      }
      textParent.y = child.y;
      textParent.leafTexts.push(child);
      textParent.minX = Math.min(textParent.minX, child.x, child.x + width);
      textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);
      child.clearContext(ctx);
      ctx.restore();
      return child;
    }
    getChildBoundingBox(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      if (typeof child.getBoundingBox !== "function") {
        return null;
      }
      var boundingBox = child.getBoundingBox(ctx);
      if (!boundingBox) {
        return null;
      }
      child.children.forEach((_2, i3) => {
        var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i3);
        boundingBox.addBoundingBox(childBoundingBox);
      });
      return boundingBox;
    }
    renderChild(ctx, textParent, parent, i2) {
      var child = parent.children[i2];
      child.render(ctx);
      child.children.forEach((_2, i3) => {
        textParent.renderChild(ctx, textParent, child, i3);
      });
    }
    measureText(ctx) {
      var {
        measureCache
      } = this;
      if (~measureCache) {
        return measureCache;
      }
      var renderText2 = this.getText();
      var measure = this.measureTargetText(ctx, renderText2);
      this.measureCache = measure;
      return measure;
    }
    measureTargetText(ctx, targetText) {
      if (!targetText.length) {
        return 0;
      }
      var {
        parent
      } = this;
      var customFont = parent.getStyle("font-family").getDefinition();
      if (customFont) {
        var fontSize2 = this.getFontSize();
        var text2 = customFont.isRTL ? targetText.split("").reverse().join("") : targetText;
        var dx = toNumbers(parent.getAttribute("dx").getString());
        var len = text2.length;
        var _measure = 0;
        for (var i2 = 0; i2 < len; i2++) {
          var glyph = this.getGlyph(customFont, text2, i2);
          _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize2 / customFont.fontFace.unitsPerEm;
          if (typeof dx[i2] !== "undefined" && !isNaN(dx[i2])) {
            _measure += dx[i2];
          }
        }
        return _measure;
      }
      if (!ctx.measureText) {
        return targetText.length * 10;
      }
      ctx.save();
      this.setContext(ctx, true);
      var {
        width: measure
      } = ctx.measureText(targetText);
      this.clearContext(ctx);
      ctx.restore();
      return measure;
    }
    /**
     * Inherits positional attributes from {@link TextElement} parent(s). Attributes
     * are only inherited from a parent to its first child.
     * @param name - The attribute name.
     * @returns The attribute value or null.
     */
    getInheritedAttribute(name) {
      var current = this;
      while (current instanceof TextElement && current.isFirstChild()) {
        var parentAttr = current.parent.getAttribute(name);
        if (parentAttr.hasValue(true)) {
          return parentAttr.getValue("0");
        }
        current = current.parent;
      }
      return null;
    }
  }
  class TSpanElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, new.target === TSpanElement ? true : captureTextNodes);
      this.type = "tspan";
      this.text = this.children.length > 0 ? "" : this.getTextFromNode();
    }
    getText() {
      return this.text;
    }
  }
  class TextNode extends TSpanElement {
    constructor() {
      super(...arguments);
      this.type = "textNode";
    }
  }
  class SVGElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "svg";
      this.root = false;
    }
    setContext(ctx) {
      var _this$node$parentNode;
      var {
        document: document2
      } = this;
      var {
        screen,
        window: window2
      } = document2;
      var canvas = ctx.canvas;
      screen.setDefaults(ctx);
      if (canvas.style && typeof ctx.font !== "undefined" && window2 && typeof window2.getComputedStyle !== "undefined") {
        ctx.font = window2.getComputedStyle(canvas).getPropertyValue("font");
        var fontSizeProp = new Property(document2, "fontSize", Font.parse(ctx.font).fontSize);
        if (fontSizeProp.hasValue()) {
          document2.rootEmSize = fontSizeProp.getPixels("y");
          document2.emSize = document2.rootEmSize;
        }
      }
      if (!this.getAttribute("x").hasValue()) {
        this.getAttribute("x", true).setValue(0);
      }
      if (!this.getAttribute("y").hasValue()) {
        this.getAttribute("y", true).setValue(0);
      }
      var {
        width,
        height
      } = screen.viewPort;
      if (!this.getStyle("width").hasValue()) {
        this.getStyle("width", true).setValue("100%");
      }
      if (!this.getStyle("height").hasValue()) {
        this.getStyle("height", true).setValue("100%");
      }
      if (!this.getStyle("color").hasValue()) {
        this.getStyle("color", true).setValue("black");
      }
      var refXAttr = this.getAttribute("refX");
      var refYAttr = this.getAttribute("refY");
      var viewBoxAttr = this.getAttribute("viewBox");
      var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;
      var clip = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
      var minX = 0;
      var minY = 0;
      var clipX = 0;
      var clipY = 0;
      if (viewBox) {
        minX = viewBox[0];
        minY = viewBox[1];
      }
      if (!this.root) {
        width = this.getStyle("width").getPixels("x");
        height = this.getStyle("height").getPixels("y");
        if (this.type === "marker") {
          clipX = minX;
          clipY = minY;
          minX = 0;
          minY = 0;
        }
      }
      screen.viewPort.setCurrent(width, height);
      if (this.node && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === "foreignObject") && this.getStyle("transform", false, true).hasValue() && !this.getStyle("transform-origin", false, true).hasValue()) {
        this.getStyle("transform-origin", true, true).setValue("50% 50%");
      }
      super.setContext(ctx);
      ctx.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y"));
      if (viewBox) {
        width = viewBox[2];
        height = viewBox[3];
      }
      document2.setViewBox({
        ctx,
        aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
        width: screen.viewPort.width,
        desiredWidth: width,
        height: screen.viewPort.height,
        desiredHeight: height,
        minX,
        minY,
        refX: refXAttr.getValue(),
        refY: refYAttr.getValue(),
        clip,
        clipX,
        clipY
      });
      if (viewBox) {
        screen.viewPort.removeCurrent();
        screen.viewPort.setCurrent(width, height);
      }
    }
    clearContext(ctx) {
      super.clearContext(ctx);
      this.document.screen.viewPort.removeCurrent();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */
    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var widthAttr = this.getAttribute("width", true);
      var heightAttr = this.getAttribute("height", true);
      var viewBoxAttr = this.getAttribute("viewBox");
      var styleAttr = this.getAttribute("style");
      var originWidth = widthAttr.getNumber(0);
      var originHeight = heightAttr.getNumber(0);
      if (preserveAspectRatio) {
        if (typeof preserveAspectRatio === "string") {
          this.getAttribute("preserveAspectRatio", true).setValue(preserveAspectRatio);
        } else {
          var preserveAspectRatioAttr = this.getAttribute("preserveAspectRatio");
          if (preserveAspectRatioAttr.hasValue()) {
            preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
          }
        }
      }
      widthAttr.setValue(width);
      heightAttr.setValue(height);
      if (!viewBoxAttr.hasValue()) {
        viewBoxAttr.setValue("0 0 ".concat(originWidth || width, " ").concat(originHeight || height));
      }
      if (styleAttr.hasValue()) {
        var widthStyle = this.getStyle("width");
        var heightStyle = this.getStyle("height");
        if (widthStyle.hasValue()) {
          widthStyle.setValue("".concat(width, "px"));
        }
        if (heightStyle.hasValue()) {
          heightStyle.setValue("".concat(height, "px"));
        }
      }
    }
  }
  class RectElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "rect";
    }
    path(ctx) {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width", false, true).getPixels("x");
      var height = this.getStyle("height", false, true).getPixels("y");
      var rxAttr = this.getAttribute("rx");
      var ryAttr = this.getAttribute("ry");
      var rx = rxAttr.getPixels("x");
      var ry = ryAttr.getPixels("y");
      if (rxAttr.hasValue() && !ryAttr.hasValue()) {
        ry = rx;
      }
      if (ryAttr.hasValue() && !rxAttr.hasValue()) {
        rx = ry;
      }
      rx = Math.min(rx, width / 2);
      ry = Math.min(ry, height / 2);
      if (ctx) {
        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
        ctx.beginPath();
        if (height > 0 && width > 0) {
          ctx.moveTo(x2 + rx, y2);
          ctx.lineTo(x2 + width - rx, y2);
          ctx.bezierCurveTo(x2 + width - rx + KAPPA * rx, y2, x2 + width, y2 + ry - KAPPA * ry, x2 + width, y2 + ry);
          ctx.lineTo(x2 + width, y2 + height - ry);
          ctx.bezierCurveTo(x2 + width, y2 + height - ry + KAPPA * ry, x2 + width - rx + KAPPA * rx, y2 + height, x2 + width - rx, y2 + height);
          ctx.lineTo(x2 + rx, y2 + height);
          ctx.bezierCurveTo(x2 + rx - KAPPA * rx, y2 + height, x2, y2 + height - ry + KAPPA * ry, x2, y2 + height - ry);
          ctx.lineTo(x2, y2 + ry);
          ctx.bezierCurveTo(x2, y2 + ry - KAPPA * ry, x2 + rx - KAPPA * rx, y2, x2 + rx, y2);
          ctx.closePath();
        }
      }
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
    getMarkers() {
      return null;
    }
  }
  class CircleElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "circle";
    }
    path(ctx) {
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      var r2 = this.getAttribute("r").getPixels();
      if (ctx && r2 > 0) {
        ctx.beginPath();
        ctx.arc(cx, cy, r2, 0, Math.PI * 2, false);
        ctx.closePath();
      }
      return new BoundingBox(cx - r2, cy - r2, cx + r2, cy + r2);
    }
    getMarkers() {
      return null;
    }
  }
  class EllipseElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "ellipse";
    }
    path(ctx) {
      var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
      var rx = this.getAttribute("rx").getPixels("x");
      var ry = this.getAttribute("ry").getPixels("y");
      var cx = this.getAttribute("cx").getPixels("x");
      var cy = this.getAttribute("cy").getPixels("y");
      if (ctx && rx > 0 && ry > 0) {
        ctx.beginPath();
        ctx.moveTo(cx + rx, cy);
        ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);
        ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);
        ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);
        ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);
        ctx.closePath();
      }
      return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);
    }
    getMarkers() {
      return null;
    }
  }
  class LineElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "line";
    }
    getPoints() {
      return [new Point(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")), new Point(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))];
    }
    path(ctx) {
      var [{
        x: x0,
        y: y0
      }, {
        x: x1,
        y: y1
      }] = this.getPoints();
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
      }
      return new BoundingBox(x0, y0, x1, y1);
    }
    getMarkers() {
      var [p0, p1] = this.getPoints();
      var a2 = p0.angleTo(p1);
      return [[p0, a2], [p1, a2]];
    }
  }
  class PolylineElement extends PathElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "polyline";
      this.points = [];
      this.points = Point.parsePath(this.getAttribute("points").getString());
    }
    path(ctx) {
      var {
        points
      } = this;
      var [{
        x: x0,
        y: y0
      }] = points;
      var boundingBox = new BoundingBox(x0, y0);
      if (ctx) {
        ctx.beginPath();
        ctx.moveTo(x0, y0);
      }
      points.forEach((_ref) => {
        var {
          x: x2,
          y: y2
        } = _ref;
        boundingBox.addPoint(x2, y2);
        if (ctx) {
          ctx.lineTo(x2, y2);
        }
      });
      return boundingBox;
    }
    getMarkers() {
      var {
        points
      } = this;
      var lastIndex = points.length - 1;
      var markers = [];
      points.forEach((point, i2) => {
        if (i2 === lastIndex) {
          return;
        }
        markers.push([point, point.angleTo(points[i2 + 1])]);
      });
      if (markers.length > 0) {
        markers.push([points[points.length - 1], markers[markers.length - 1][1]]);
      }
      return markers;
    }
  }
  class PolygonElement extends PolylineElement {
    constructor() {
      super(...arguments);
      this.type = "polygon";
    }
    path(ctx) {
      var boundingBox = super.path(ctx);
      var [{
        x: x2,
        y: y2
      }] = this.points;
      if (ctx) {
        ctx.lineTo(x2, y2);
        ctx.closePath();
      }
      return boundingBox;
    }
  }
  class PatternElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "pattern";
    }
    createPattern(ctx, _2, parentOpacityProp) {
      var width = this.getStyle("width").getPixels("x", true);
      var height = this.getStyle("height").getPixels("y", true);
      var patternSvg = new SVGElement(this.document, null);
      patternSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      patternSvg.attributes.width = new Property(this.document, "width", "".concat(width, "px"));
      patternSvg.attributes.height = new Property(this.document, "height", "".concat(height, "px"));
      patternSvg.attributes.transform = new Property(this.document, "transform", this.getAttribute("patternTransform").getValue());
      patternSvg.children = this.children;
      var patternCanvas = this.document.createCanvas(width, height);
      var patternCtx = patternCanvas.getContext("2d");
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue() && yAttr.hasValue()) {
        patternCtx.translate(xAttr.getPixels("x", true), yAttr.getPixels("y", true));
      }
      if (parentOpacityProp.hasValue()) {
        this.styles["fill-opacity"] = parentOpacityProp;
      } else {
        Reflect.deleteProperty(this.styles, "fill-opacity");
      }
      for (var x2 = -1; x2 <= 1; x2++) {
        for (var y2 = -1; y2 <= 1; y2++) {
          patternCtx.save();
          patternSvg.attributes.x = new Property(this.document, "x", x2 * patternCanvas.width);
          patternSvg.attributes.y = new Property(this.document, "y", y2 * patternCanvas.height);
          patternSvg.render(patternCtx);
          patternCtx.restore();
        }
      }
      var pattern = ctx.createPattern(patternCanvas, "repeat");
      return pattern;
    }
  }
  class MarkerElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "marker";
    }
    render(ctx, point, angle2) {
      if (!point) {
        return;
      }
      var {
        x: x2,
        y: y2
      } = point;
      var orient = this.getAttribute("orient").getString("auto");
      var markerUnits = this.getAttribute("markerUnits").getString("strokeWidth");
      ctx.translate(x2, y2);
      if (orient === "auto") {
        ctx.rotate(angle2);
      }
      if (markerUnits === "strokeWidth") {
        ctx.scale(ctx.lineWidth, ctx.lineWidth);
      }
      ctx.save();
      var markerSvg = new SVGElement(this.document, null);
      markerSvg.type = this.type;
      markerSvg.attributes.viewBox = new Property(this.document, "viewBox", this.getAttribute("viewBox").getValue());
      markerSvg.attributes.refX = new Property(this.document, "refX", this.getAttribute("refX").getValue());
      markerSvg.attributes.refY = new Property(this.document, "refY", this.getAttribute("refY").getValue());
      markerSvg.attributes.width = new Property(this.document, "width", this.getAttribute("markerWidth").getValue());
      markerSvg.attributes.height = new Property(this.document, "height", this.getAttribute("markerHeight").getValue());
      markerSvg.attributes.overflow = new Property(this.document, "overflow", this.getAttribute("overflow").getValue());
      markerSvg.attributes.fill = new Property(this.document, "fill", this.getAttribute("fill").getColor("black"));
      markerSvg.attributes.stroke = new Property(this.document, "stroke", this.getAttribute("stroke").getValue("none"));
      markerSvg.children = this.children;
      markerSvg.render(ctx);
      ctx.restore();
      if (markerUnits === "strokeWidth") {
        ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
      }
      if (orient === "auto") {
        ctx.rotate(-angle2);
      }
      ctx.translate(-x2, -y2);
    }
  }
  class DefsElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "defs";
    }
    render() {
    }
  }
  class GElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "g";
    }
    getBoundingBox(ctx) {
      var boundingBox = new BoundingBox();
      this.children.forEach((child) => {
        boundingBox.addBoundingBox(child.getBoundingBox(ctx));
      });
      return boundingBox;
    }
  }
  class GradientElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.attributesToInherit = ["gradientUnits"];
      this.stops = [];
      var {
        stops,
        children
      } = this;
      children.forEach((child) => {
        if (child.type === "stop") {
          stops.push(child);
        }
      });
    }
    getGradientUnits() {
      return this.getAttribute("gradientUnits").getString("objectBoundingBox");
    }
    createGradient(ctx, element, parentOpacityProp) {
      var stopsContainer = this;
      if (this.getHrefAttribute().hasValue()) {
        stopsContainer = this.getHrefAttribute().getDefinition();
        this.inheritStopContainer(stopsContainer);
      }
      var {
        stops
      } = stopsContainer;
      var gradient = this.getGradient(ctx, element);
      if (!gradient) {
        return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);
      }
      stops.forEach((stop) => {
        gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));
      });
      if (this.getAttribute("gradientTransform").hasValue()) {
        var {
          document: document2
        } = this;
        var {
          MAX_VIRTUAL_PIXELS,
          viewPort
        } = document2.screen;
        var [rootView] = viewPort.viewPorts;
        var rect = new RectElement(document2, null);
        rect.attributes.x = new Property(document2, "x", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.y = new Property(document2, "y", -MAX_VIRTUAL_PIXELS / 3);
        rect.attributes.width = new Property(document2, "width", MAX_VIRTUAL_PIXELS);
        rect.attributes.height = new Property(document2, "height", MAX_VIRTUAL_PIXELS);
        var group = new GElement(document2, null);
        group.attributes.transform = new Property(document2, "transform", this.getAttribute("gradientTransform").getValue());
        group.children = [rect];
        var patternSvg = new SVGElement(document2, null);
        patternSvg.attributes.x = new Property(document2, "x", 0);
        patternSvg.attributes.y = new Property(document2, "y", 0);
        patternSvg.attributes.width = new Property(document2, "width", rootView.width);
        patternSvg.attributes.height = new Property(document2, "height", rootView.height);
        patternSvg.children = [group];
        var patternCanvas = document2.createCanvas(rootView.width, rootView.height);
        var patternCtx = patternCanvas.getContext("2d");
        patternCtx.fillStyle = gradient;
        patternSvg.render(patternCtx);
        return patternCtx.createPattern(patternCanvas, "no-repeat");
      }
      return gradient;
    }
    inheritStopContainer(stopsContainer) {
      this.attributesToInherit.forEach((attributeToInherit) => {
        if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {
          this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());
        }
      });
    }
    addParentOpacity(parentOpacityProp, color2) {
      if (parentOpacityProp.hasValue()) {
        var colorProp = new Property(this.document, "color", color2);
        return colorProp.addOpacity(parentOpacityProp).getColor();
      }
      return color2;
    }
  }
  class LinearGradientElement extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "linearGradient";
      this.attributesToInherit.push("x1", "y1", "x2", "y2");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue()) {
        this.getAttribute("x1", true).setValue(0);
        this.getAttribute("y1", true).setValue(0);
        this.getAttribute("x2", true).setValue(1);
        this.getAttribute("y2", true).setValue(0);
      }
      var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x");
      var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y");
      var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x");
      var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
      if (x1 === x2 && y1 === y2) {
        return null;
      }
      return ctx.createLinearGradient(x1, y1, x2, y2);
    }
  }
  class RadialGradientElement extends GradientElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "radialGradient";
      this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
    }
    getGradient(ctx, element) {
      var isBoundingBoxUnits = this.getGradientUnits() === "objectBoundingBox";
      var boundingBox = element.getBoundingBox(ctx);
      if (isBoundingBoxUnits && !boundingBox) {
        return null;
      }
      if (!this.getAttribute("cx").hasValue()) {
        this.getAttribute("cx", true).setValue("50%");
      }
      if (!this.getAttribute("cy").hasValue()) {
        this.getAttribute("cy", true).setValue("50%");
      }
      if (!this.getAttribute("r").hasValue()) {
        this.getAttribute("r", true).setValue("50%");
      }
      var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x");
      var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
      var fx = cx;
      var fy = cy;
      if (this.getAttribute("fx").hasValue()) {
        fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x");
      }
      if (this.getAttribute("fy").hasValue()) {
        fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y");
      }
      var r2 = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels();
      var fr = this.getAttribute("fr").getPixels();
      return ctx.createRadialGradient(fx, fy, fr, cx, cy, r2);
    }
  }
  class StopElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "stop";
      var offset = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber()));
      var stopOpacity = this.getStyle("stop-opacity");
      var stopColor = this.getStyle("stop-color", true);
      if (stopColor.getString() === "") {
        stopColor.setValue("#000");
      }
      if (stopOpacity.hasValue()) {
        stopColor = stopColor.addOpacity(stopOpacity);
      }
      this.offset = offset;
      this.color = stopColor.getColor();
    }
  }
  class AnimateElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "animate";
      this.duration = 0;
      this.initialValue = null;
      this.initialUnits = "";
      this.removed = false;
      this.frozen = false;
      document2.screen.animations.push(this);
      this.begin = this.getAttribute("begin").getMilliseconds();
      this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds();
      this.from = this.getAttribute("from");
      this.to = this.getAttribute("to");
      this.values = new Property(document2, "values", null);
      var valuesAttr = this.getAttribute("values");
      if (valuesAttr.hasValue()) {
        this.values.setValue(valuesAttr.getString().split(";"));
      }
    }
    getProperty() {
      var attributeType = this.getAttribute("attributeType").getString();
      var attributeName = this.getAttribute("attributeName").getString();
      if (attributeType === "CSS") {
        return this.parent.getStyle(attributeName, true);
      }
      return this.parent.getAttribute(attributeName, true);
    }
    calcValue() {
      var {
        initialUnits
      } = this;
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;
      if (initialUnits === "%") {
        newValue *= 100;
      }
      return "".concat(newValue).concat(initialUnits);
    }
    update(delta) {
      var {
        parent
      } = this;
      var prop = this.getProperty();
      if (!this.initialValue) {
        this.initialValue = prop.getString();
        this.initialUnits = prop.getUnits();
      }
      if (this.duration > this.maxDuration) {
        var fill = this.getAttribute("fill").getString("remove");
        if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite") {
          this.duration = 0;
        } else if (fill === "freeze" && !this.frozen) {
          this.frozen = true;
          parent.animationFrozen = true;
          parent.animationFrozenValue = prop.getString();
        } else if (fill === "remove" && !this.removed) {
          this.removed = true;
          prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);
          return true;
        }
        return false;
      }
      this.duration += delta;
      var updated = false;
      if (this.begin < this.duration) {
        var newValue = this.calcValue();
        var typeAttr = this.getAttribute("type");
        if (typeAttr.hasValue()) {
          var type = typeAttr.getString();
          newValue = "".concat(type, "(").concat(newValue, ")");
        }
        prop.setValue(newValue);
        updated = true;
      }
      return updated;
    }
    getProgress() {
      var {
        document: document2,
        values
      } = this;
      var result = {
        progress: (this.duration - this.begin) / (this.maxDuration - this.begin)
      };
      if (values.hasValue()) {
        var p2 = result.progress * (values.getValue().length - 1);
        var lb = Math.floor(p2);
        var ub = Math.ceil(p2);
        result.from = new Property(document2, "from", parseFloat(values.getValue()[lb]));
        result.to = new Property(document2, "to", parseFloat(values.getValue()[ub]));
        result.progress = (p2 - lb) / (ub - lb);
      } else {
        result.from = this.from;
        result.to = this.to;
      }
      return result;
    }
  }
  class AnimateColorElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateColor";
    }
    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var colorFrom = new RGBColor$1(from.getColor());
      var colorTo = new RGBColor$1(to.getColor());
      if (colorFrom.ok && colorTo.ok) {
        var r2 = colorFrom.r + (colorTo.r - colorFrom.r) * progress;
        var g2 = colorFrom.g + (colorTo.g - colorFrom.g) * progress;
        var b2 = colorFrom.b + (colorTo.b - colorFrom.b) * progress;
        return "rgb(".concat(Math.floor(r2), ", ").concat(Math.floor(g2), ", ").concat(Math.floor(b2), ")");
      }
      return this.getAttribute("from").getColor();
    }
  }
  class AnimateTransformElement extends AnimateElement {
    constructor() {
      super(...arguments);
      this.type = "animateTransform";
    }
    calcValue() {
      var {
        progress,
        from,
        to
      } = this.getProgress();
      var transformFrom = toNumbers(from.getString());
      var transformTo = toNumbers(to.getString());
      var newValue = transformFrom.map((from2, i2) => {
        var to2 = transformTo[i2];
        return from2 + (to2 - from2) * progress;
      }).join(" ");
      return newValue;
    }
  }
  class FontElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font";
      this.glyphs = /* @__PURE__ */ Object.create(null);
      this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
      var {
        definitions
      } = document2;
      var {
        children
      } = this;
      for (var child of children) {
        switch (child.type) {
          case "font-face": {
            this.fontFace = child;
            var fontFamilyStyle = child.getStyle("font-family");
            if (fontFamilyStyle.hasValue()) {
              definitions[fontFamilyStyle.getString()] = this;
            }
            break;
          }
          case "missing-glyph":
            this.missingGlyph = child;
            break;
          case "glyph": {
            var glyph = child;
            if (glyph.arabicForm) {
              this.isRTL = true;
              this.isArabic = true;
              if (typeof this.glyphs[glyph.unicode] === "undefined") {
                this.glyphs[glyph.unicode] = /* @__PURE__ */ Object.create(null);
              }
              this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;
            } else {
              this.glyphs[glyph.unicode] = glyph;
            }
            break;
          }
        }
      }
    }
    render() {
    }
  }
  class FontFaceElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "font-face";
      this.ascent = this.getAttribute("ascent").getNumber();
      this.descent = this.getAttribute("descent").getNumber();
      this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
    }
  }
  class MissingGlyphElement extends PathElement {
    constructor() {
      super(...arguments);
      this.type = "missing-glyph";
      this.horizAdvX = 0;
    }
  }
  class TRefElement extends TextElement {
    constructor() {
      super(...arguments);
      this.type = "tref";
    }
    getText() {
      var element = this.getHrefAttribute().getDefinition();
      if (element) {
        var firstChild = element.children[0];
        if (firstChild) {
          return firstChild.getText();
        }
      }
      return "";
    }
  }
  class AElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "a";
      var {
        childNodes
      } = node2;
      var firstChild = childNodes[0];
      var hasText = childNodes.length > 0 && Array.from(childNodes).every((node3) => node3.nodeType === 3);
      this.hasText = hasText;
      this.text = hasText ? this.getTextFromNode(firstChild) : "";
    }
    getText() {
      return this.text;
    }
    renderChildren(ctx) {
      if (this.hasText) {
        super.renderChildren(ctx);
        var {
          document: document2,
          x: x2,
          y: y2
        } = this;
        var {
          mouse
        } = document2.screen;
        var fontSize2 = new Property(document2, "fontSize", Font.parse(document2.ctx.font).fontSize);
        if (mouse.isWorking()) {
          mouse.checkBoundingBox(this, new BoundingBox(x2, y2 - fontSize2.getPixels("y"), x2 + this.measureText(ctx), y2));
        }
      } else if (this.children.length > 0) {
        var g2 = new GElement(this.document, null);
        g2.children = this.children;
        g2.parent = this;
        g2.render(ctx);
      }
    }
    onClick() {
      var {
        window: window2
      } = this.document;
      if (window2) {
        window2.open(this.getHrefAttribute().getString());
      }
    }
    onMouseMove() {
      var ctx = this.document.ctx;
      ctx.canvas.style.cursor = "pointer";
    }
  }
  function ownKeys$2(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$2(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys$2(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$2(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  class TextPathElement extends TextElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "textPath";
      this.textWidth = 0;
      this.textHeight = 0;
      this.pathLength = -1;
      this.glyphInfo = null;
      this.letterSpacingCache = [];
      this.measuresCache = /* @__PURE__ */ new Map([["", 0]]);
      var pathElement = this.getHrefAttribute().getDefinition();
      this.text = this.getTextFromNode();
      this.dataArray = this.parsePathData(pathElement);
    }
    getText() {
      return this.text;
    }
    path(ctx) {
      var {
        dataArray
      } = this;
      if (ctx) {
        ctx.beginPath();
      }
      dataArray.forEach((_ref) => {
        var {
          type,
          points
        } = _ref;
        switch (type) {
          case PathParser.LINE_TO:
            if (ctx) {
              ctx.lineTo(points[0], points[1]);
            }
            break;
          case PathParser.MOVE_TO:
            if (ctx) {
              ctx.moveTo(points[0], points[1]);
            }
            break;
          case PathParser.CURVE_TO:
            if (ctx) {
              ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);
            }
            break;
          case PathParser.QUAD_TO:
            if (ctx) {
              ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);
            }
            break;
          case PathParser.ARC: {
            var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;
            var r2 = rx > ry ? rx : ry;
            var scaleX = rx > ry ? 1 : rx / ry;
            var scaleY = rx > ry ? ry / rx : 1;
            if (ctx) {
              ctx.translate(cx, cy);
              ctx.rotate(psi);
              ctx.scale(scaleX, scaleY);
              ctx.arc(0, 0, r2, theta, theta + dTheta, Boolean(1 - fs));
              ctx.scale(1 / scaleX, 1 / scaleY);
              ctx.rotate(-psi);
              ctx.translate(-cx, -cy);
            }
            break;
          }
          case PathParser.CLOSE_PATH:
            if (ctx) {
              ctx.closePath();
            }
            break;
        }
      });
    }
    renderChildren(ctx) {
      this.setTextData(ctx);
      ctx.save();
      var textDecoration = this.parent.getStyle("text-decoration").getString();
      var fontSize2 = this.getFontSize();
      var {
        glyphInfo
      } = this;
      var fill = ctx.fillStyle;
      if (textDecoration === "underline") {
        ctx.beginPath();
      }
      glyphInfo.forEach((glyph, i2) => {
        var {
          p0,
          p1,
          rotation,
          text: partialText
        } = glyph;
        ctx.save();
        ctx.translate(p0.x, p0.y);
        ctx.rotate(rotation);
        if (ctx.fillStyle) {
          ctx.fillText(partialText, 0, 0);
        }
        if (ctx.strokeStyle) {
          ctx.strokeText(partialText, 0, 0);
        }
        ctx.restore();
        if (textDecoration === "underline") {
          if (i2 === 0) {
            ctx.moveTo(p0.x, p0.y + fontSize2 / 8);
          }
          ctx.lineTo(p1.x, p1.y + fontSize2 / 5);
        }
      });
      if (textDecoration === "underline") {
        ctx.lineWidth = fontSize2 / 20;
        ctx.strokeStyle = fill;
        ctx.stroke();
        ctx.closePath();
      }
      ctx.restore();
    }
    getLetterSpacingAt() {
      var idx = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
      return this.letterSpacingCache[idx] || 0;
    }
    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c2, charI) {
      var offset = inputOffset;
      var glyphWidth = this.measureText(ctx, c2);
      if (c2 === " " && anchor === "justify" && textFullWidth < fullPathWidth) {
        glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;
      }
      if (charI > -1) {
        offset += this.getLetterSpacingAt(charI);
      }
      var splineStep = this.textHeight / 20;
      var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);
      var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);
      var segment = {
        p0,
        p1
      };
      var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;
      if (dy) {
        var dyX = Math.cos(Math.PI / 2 + rotation) * dy;
        var dyY = Math.cos(-rotation) * dy;
        segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {
          x: p0.x + dyX,
          y: p0.y + dyY
        });
        segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {
          x: p1.x + dyX,
          y: p1.y + dyY
        });
      }
      offset += glyphWidth;
      return {
        offset,
        segment,
        rotation
      };
    }
    measureText(ctx, text2) {
      var {
        measuresCache
      } = this;
      var targetText = text2 || this.getText();
      if (measuresCache.has(targetText)) {
        return measuresCache.get(targetText);
      }
      var measure = this.measureTargetText(ctx, targetText);
      measuresCache.set(targetText, measure);
      return measure;
    }
    // This method supposes what all custom fonts already loaded.
    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
    // You need to call this method manually to update glyphs cache.
    setTextData(ctx) {
      if (this.glyphInfo) {
        return;
      }
      var renderText2 = this.getText();
      var chars2 = renderText2.split("");
      var spacesNumber = renderText2.split(" ").length - 1;
      var dx = this.parent.getAttribute("dx").split().map((_2) => _2.getPixels("x"));
      var dy = this.parent.getAttribute("dy").getPixels("y");
      var anchor = this.parent.getStyle("text-anchor").getString("start");
      var thisSpacing = this.getStyle("letter-spacing");
      var parentSpacing = this.parent.getStyle("letter-spacing");
      var letterSpacing2 = 0;
      if (!thisSpacing.hasValue() || thisSpacing.getValue() === "inherit") {
        letterSpacing2 = parentSpacing.getPixels();
      } else if (thisSpacing.hasValue()) {
        if (thisSpacing.getValue() !== "initial" && thisSpacing.getValue() !== "unset") {
          letterSpacing2 = thisSpacing.getPixels();
        }
      }
      var letterSpacingCache = [];
      var textLen = renderText2.length;
      this.letterSpacingCache = letterSpacingCache;
      for (var i2 = 0; i2 < textLen; i2++) {
        letterSpacingCache.push(typeof dx[i2] !== "undefined" ? dx[i2] : letterSpacing2);
      }
      var dxSum = letterSpacingCache.reduce((acc, cur, i3) => i3 === 0 ? 0 : acc + cur || 0, 0);
      var textWidth = this.measureText(ctx);
      var textFullWidth = Math.max(textWidth + dxSum, 0);
      this.textWidth = textWidth;
      this.textHeight = this.getFontSize();
      this.glyphInfo = [];
      var fullPathWidth = this.getPathLength();
      var startOffset = this.getStyle("startOffset").getNumber(0) * fullPathWidth;
      var offset = 0;
      if (anchor === "middle" || anchor === "center") {
        offset = -textFullWidth / 2;
      }
      if (anchor === "end" || anchor === "right") {
        offset = -textFullWidth;
      }
      offset += startOffset;
      chars2.forEach((char, i3) => {
        var {
          offset: nextOffset,
          segment,
          rotation
        } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i3);
        offset = nextOffset;
        if (!segment.p0 || !segment.p1) {
          return;
        }
        this.glyphInfo.push({
          // transposeX: midpoint.x,
          // transposeY: midpoint.y,
          text: chars2[i3],
          p0: segment.p0,
          p1: segment.p1,
          rotation
        });
      });
    }
    parsePathData(path) {
      this.pathLength = -1;
      if (!path) {
        return [];
      }
      var pathCommands = [];
      var {
        pathParser
      } = path;
      pathParser.reset();
      while (!pathParser.isEnd()) {
        var {
          current
        } = pathParser;
        var startX = current ? current.x : 0;
        var startY = current ? current.y : 0;
        var command = pathParser.next();
        var nextCommandType = command.type;
        var points = [];
        switch (command.type) {
          case PathParser.MOVE_TO:
            this.pathM(pathParser, points);
            break;
          case PathParser.LINE_TO:
            nextCommandType = this.pathL(pathParser, points);
            break;
          case PathParser.HORIZ_LINE_TO:
            nextCommandType = this.pathH(pathParser, points);
            break;
          case PathParser.VERT_LINE_TO:
            nextCommandType = this.pathV(pathParser, points);
            break;
          case PathParser.CURVE_TO:
            this.pathC(pathParser, points);
            break;
          case PathParser.SMOOTH_CURVE_TO:
            nextCommandType = this.pathS(pathParser, points);
            break;
          case PathParser.QUAD_TO:
            this.pathQ(pathParser, points);
            break;
          case PathParser.SMOOTH_QUAD_TO:
            nextCommandType = this.pathT(pathParser, points);
            break;
          case PathParser.ARC:
            points = this.pathA(pathParser);
            break;
          case PathParser.CLOSE_PATH:
            PathElement.pathZ(pathParser);
            break;
        }
        if (command.type !== PathParser.CLOSE_PATH) {
          pathCommands.push({
            type: nextCommandType,
            points,
            start: {
              x: startX,
              y: startY
            },
            pathLength: this.calcLength(startX, startY, nextCommandType, points)
          });
        } else {
          pathCommands.push({
            type: PathParser.CLOSE_PATH,
            points: [],
            pathLength: 0
          });
        }
      }
      return pathCommands;
    }
    pathM(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathM(pathParser).point;
      points.push(x2, y2);
    }
    pathL(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathL(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathH(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathH(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathV(pathParser, points) {
      var {
        x: x2,
        y: y2
      } = PathElement.pathV(pathParser).point;
      points.push(x2, y2);
      return PathParser.LINE_TO;
    }
    pathC(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathC(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathS(pathParser, points) {
      var {
        point,
        controlPoint,
        currentPoint
      } = PathElement.pathS(pathParser);
      points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.CURVE_TO;
    }
    pathQ(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathQ(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
    }
    pathT(pathParser, points) {
      var {
        controlPoint,
        currentPoint
      } = PathElement.pathT(pathParser);
      points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);
      return PathParser.QUAD_TO;
    }
    pathA(pathParser) {
      var {
        rX,
        rY,
        sweepFlag,
        xAxisRotation,
        centp,
        a1,
        ad
      } = PathElement.pathA(pathParser);
      if (sweepFlag === 0 && ad > 0) {
        ad -= 2 * Math.PI;
      }
      if (sweepFlag === 1 && ad < 0) {
        ad += 2 * Math.PI;
      }
      return [centp.x, centp.y, rX, rY, a1, ad, xAxisRotation, sweepFlag];
    }
    calcLength(x2, y2, commandType, points) {
      var len = 0;
      var p1 = null;
      var p2 = null;
      var t2 = 0;
      switch (commandType) {
        case PathParser.LINE_TO:
          return this.getLineLength(x2, y2, points[0], points[1]);
        case PathParser.CURVE_TO:
          len = 0;
          p1 = this.getPointOnCubicBezier(0, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
          for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
            p2 = this.getPointOnCubicBezier(t2, x2, y2, points[0], points[1], points[2], points[3], points[4], points[5]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.QUAD_TO:
          len = 0;
          p1 = this.getPointOnQuadraticBezier(0, x2, y2, points[0], points[1], points[2], points[3]);
          for (t2 = 0.01; t2 <= 1; t2 += 0.01) {
            p2 = this.getPointOnQuadraticBezier(t2, x2, y2, points[0], points[1], points[2], points[3]);
            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
            p1 = p2;
          }
          return len;
        case PathParser.ARC: {
          len = 0;
          var start = points[4];
          var dTheta = points[5];
          var end = points[4] + dTheta;
          var inc = Math.PI / 180;
          if (Math.abs(start - end) < inc) {
            inc = Math.abs(start - end);
          }
          p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);
          if (dTheta < 0) {
            for (t2 = start - inc; t2 > end; t2 -= inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          } else {
            for (t2 = start + inc; t2 < end; t2 += inc) {
              p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t2, 0);
              len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
              p1 = p2;
            }
          }
          p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);
          len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);
          return len;
        }
      }
      return 0;
    }
    getPointOnLine(dist, p1x, p1y, p2x, p2y) {
      var fromX = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : p1x;
      var fromY = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : p1y;
      var m2 = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);
      var run = Math.sqrt(dist * dist / (1 + m2 * m2));
      if (p2x < p1x) {
        run *= -1;
      }
      var rise = m2 * run;
      var pt2 = null;
      if (p2x === p1x) {
        pt2 = {
          x: fromX,
          y: fromY + rise
        };
      } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m2) {
        pt2 = {
          x: fromX + run,
          y: fromY + rise
        };
      } else {
        var ix = 0;
        var iy = 0;
        var len = this.getLineLength(p1x, p1y, p2x, p2y);
        if (len < PSEUDO_ZERO) {
          return null;
        }
        var u2 = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);
        u2 /= len * len;
        ix = p1x + u2 * (p2x - p1x);
        iy = p1y + u2 * (p2y - p1y);
        var pRise = this.getLineLength(fromX, fromY, ix, iy);
        var pRun = Math.sqrt(dist * dist - pRise * pRise);
        run = Math.sqrt(pRun * pRun / (1 + m2 * m2));
        if (p2x < p1x) {
          run *= -1;
        }
        rise = m2 * run;
        pt2 = {
          x: ix + run,
          y: iy + rise
        };
      }
      return pt2;
    }
    getPointOnPath(distance2) {
      var fullLen = this.getPathLength();
      var cumulativePathLength = 0;
      var p2 = null;
      if (distance2 < -5e-5 || distance2 - 5e-5 > fullLen) {
        return null;
      }
      var {
        dataArray
      } = this;
      for (var command of dataArray) {
        if (command && (command.pathLength < 5e-5 || cumulativePathLength + command.pathLength + 5e-5 < distance2)) {
          cumulativePathLength += command.pathLength;
          continue;
        }
        var delta = distance2 - cumulativePathLength;
        var currentT = 0;
        switch (command.type) {
          case PathParser.LINE_TO:
            p2 = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);
            break;
          case PathParser.ARC: {
            var start = command.points[4];
            var dTheta = command.points[5];
            var end = command.points[4] + dTheta;
            currentT = start + delta / command.pathLength * dTheta;
            if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {
              break;
            }
            p2 = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);
            break;
          }
          case PathParser.CURVE_TO:
            currentT = delta / command.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);
            break;
          case PathParser.QUAD_TO:
            currentT = delta / command.pathLength;
            if (currentT > 1) {
              currentT = 1;
            }
            p2 = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);
            break;
        }
        if (p2) {
          return p2;
        }
        break;
      }
      return null;
    }
    getLineLength(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    getPathLength() {
      if (this.pathLength === -1) {
        this.pathLength = this.dataArray.reduce((length, command) => command.pathLength > 0 ? length + command.pathLength : length, 0);
      }
      return this.pathLength;
    }
    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
      var x2 = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);
      var y2 = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {
      var x2 = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);
      var y2 = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);
      return {
        x: x2,
        y: y2
      };
    }
    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {
      var cosPsi = Math.cos(psi);
      var sinPsi = Math.sin(psi);
      var pt2 = {
        x: rx * Math.cos(theta),
        y: ry * Math.sin(theta)
      };
      return {
        x: cx + (pt2.x * cosPsi - pt2.y * sinPsi),
        y: cy + (pt2.x * sinPsi + pt2.y * cosPsi)
      };
    }
    // TODO need some optimisations. possibly build cache only for curved segments?
    buildEquidistantCache(inputStep, inputPrecision) {
      var fullLen = this.getPathLength();
      var precision = inputPrecision || 0.25;
      var step = inputStep || fullLen / 100;
      if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {
        this.equidistantCache = {
          step,
          precision,
          points: []
        };
        var s2 = 0;
        for (var l2 = 0; l2 <= fullLen; l2 += precision) {
          var p0 = this.getPointOnPath(l2);
          var p1 = this.getPointOnPath(l2 + precision);
          if (!p0 || !p1) {
            continue;
          }
          s2 += this.getLineLength(p0.x, p0.y, p1.x, p1.y);
          if (s2 >= step) {
            this.equidistantCache.points.push({
              x: p0.x,
              y: p0.y,
              distance: l2
            });
            s2 -= step;
          }
        }
      }
    }
    getEquidistantPointOnPath(targetDistance, step, precision) {
      this.buildEquidistantCache(step, precision);
      if (targetDistance < 0 || targetDistance - this.getPathLength() > 5e-5) {
        return null;
      }
      var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));
      return this.equidistantCache.points[idx] || null;
    }
  }
  var dataUriRegex = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
  class ImageElement extends RenderedElement {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "image";
      this.loaded = false;
      var href = this.getHrefAttribute().getString();
      if (!href) {
        return;
      }
      var isSvg = href.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(href);
      document2.images.push(this);
      if (!isSvg) {
        void this.loadImage(href);
      } else {
        void this.loadSvg(href);
      }
      this.isSvg = isSvg;
    }
    loadImage(href) {
      var _this = this;
      return _asyncToGenerator(function* () {
        try {
          var image2 = yield _this.document.createImage(href);
          _this.image = image2;
        } catch (err) {
          console.error('Error while loading image "'.concat(href, '":'), err);
        }
        _this.loaded = true;
      })();
    }
    loadSvg(href) {
      var _this2 = this;
      return _asyncToGenerator(function* () {
        var match = dataUriRegex.exec(href);
        if (match) {
          var data = match[5];
          if (match[4] === "base64") {
            _this2.image = atob(data);
          } else {
            _this2.image = decodeURIComponent(data);
          }
        } else {
          try {
            var response = yield _this2.document.fetch(href);
            var svg2 = yield response.text();
            _this2.image = svg2;
          } catch (err) {
            console.error('Error while loading image "'.concat(href, '":'), err);
          }
        }
        _this2.loaded = true;
      })();
    }
    renderChildren(ctx) {
      var {
        document: document2,
        image: image2,
        loaded
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!loaded || !image2 || !width || !height) {
        return;
      }
      ctx.save();
      ctx.translate(x2, y2);
      if (this.isSvg) {
        var subDocument = document2.canvg.forkString(ctx, this.image, {
          ignoreMouse: true,
          ignoreAnimation: true,
          ignoreDimensions: true,
          ignoreClear: true,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: width,
          scaleHeight: height
        });
        subDocument.document.documentElement.parent = this;
        void subDocument.render();
      } else {
        var _image = this.image;
        document2.setViewBox({
          ctx,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width,
          desiredWidth: _image.width,
          height,
          desiredHeight: _image.height
        });
        if (this.loaded) {
          if (typeof _image.complete === "undefined" || _image.complete) {
            ctx.drawImage(_image, 0, 0);
          }
        }
      }
      ctx.restore();
    }
    getBoundingBox() {
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      return new BoundingBox(x2, y2, x2 + width, y2 + height);
    }
  }
  class SymbolElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "symbol";
    }
    render(_2) {
    }
  }
  class SVGFontLoader {
    constructor(document2) {
      this.document = document2;
      this.loaded = false;
      document2.fonts.push(this);
    }
    load(fontFamily2, url) {
      var _this = this;
      return _asyncToGenerator(function* () {
        try {
          var {
            document: document2
          } = _this;
          var svgDocument = yield document2.canvg.parser.load(url);
          var fonts = svgDocument.getElementsByTagName("font");
          Array.from(fonts).forEach((fontNode) => {
            var font = document2.createElement(fontNode);
            document2.definitions[fontFamily2] = font;
          });
        } catch (err) {
          console.error('Error while loading font "'.concat(url, '":'), err);
        }
        _this.loaded = true;
      })();
    }
  }
  class StyleElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "style";
      var css = compressSpaces(
        Array.from(node2.childNodes).map((_2) => _2.textContent).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
        // remove imports
      );
      var cssDefs = css.split("}");
      cssDefs.forEach((_2) => {
        var def = _2.trim();
        if (!def) {
          return;
        }
        var cssParts = def.split("{");
        var cssClasses = cssParts[0].split(",");
        var cssProps = cssParts[1].split(";");
        cssClasses.forEach((_3) => {
          var cssClass = _3.trim();
          if (!cssClass) {
            return;
          }
          var props = document2.styles[cssClass] || {};
          cssProps.forEach((cssProp) => {
            var prop = cssProp.indexOf(":");
            var name = cssProp.substr(0, prop).trim();
            var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();
            if (name && value) {
              props[name] = new Property(document2, name, value);
            }
          });
          document2.styles[cssClass] = props;
          document2.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);
          if (cssClass === "@font-face") {
            var fontFamily2 = props["font-family"].getString().replace(/"|'/g, "");
            var srcs = props.src.getString().split(",");
            srcs.forEach((src) => {
              if (src.indexOf('format("svg")') > 0) {
                var url = parseExternalUrl(src);
                if (url) {
                  void new SVGFontLoader(document2).load(fontFamily2, url);
                }
              }
            });
          }
        });
      });
    }
  }
  StyleElement.parseExternalUrl = parseExternalUrl;
  class UseElement extends RenderedElement {
    constructor() {
      super(...arguments);
      this.type = "use";
    }
    setContext(ctx) {
      super.setContext(ctx);
      var xAttr = this.getAttribute("x");
      var yAttr = this.getAttribute("y");
      if (xAttr.hasValue()) {
        ctx.translate(xAttr.getPixels("x"), 0);
      }
      if (yAttr.hasValue()) {
        ctx.translate(0, yAttr.getPixels("y"));
      }
    }
    path(ctx) {
      var {
        element
      } = this;
      if (element) {
        element.path(ctx);
      }
    }
    renderChildren(ctx) {
      var {
        document: document2,
        element
      } = this;
      if (element) {
        var tempSvg = element;
        if (element.type === "symbol") {
          tempSvg = new SVGElement(document2, null);
          tempSvg.attributes.viewBox = new Property(document2, "viewBox", element.getAttribute("viewBox").getString());
          tempSvg.attributes.preserveAspectRatio = new Property(document2, "preserveAspectRatio", element.getAttribute("preserveAspectRatio").getString());
          tempSvg.attributes.overflow = new Property(document2, "overflow", element.getAttribute("overflow").getString());
          tempSvg.children = element.children;
          element.styles.opacity = new Property(document2, "opacity", this.calculateOpacity());
        }
        if (tempSvg.type === "svg") {
          var widthStyle = this.getStyle("width", false, true);
          var heightStyle = this.getStyle("height", false, true);
          if (widthStyle.hasValue()) {
            tempSvg.attributes.width = new Property(document2, "width", widthStyle.getString());
          }
          if (heightStyle.hasValue()) {
            tempSvg.attributes.height = new Property(document2, "height", heightStyle.getString());
          }
        }
        var oldParent = tempSvg.parent;
        tempSvg.parent = this;
        tempSvg.render(ctx);
        tempSvg.parent = oldParent;
      }
    }
    getBoundingBox(ctx) {
      var {
        element
      } = this;
      if (element) {
        return element.getBoundingBox(ctx);
      }
      return null;
    }
    elementTransform() {
      var {
        document: document2,
        element
      } = this;
      return Transform.fromElement(document2, element);
    }
    get element() {
      if (!this.cachedElement) {
        this.cachedElement = this.getHrefAttribute().getDefinition();
      }
      return this.cachedElement;
    }
  }
  function imGet(img, x2, y2, width, _height, rgba) {
    return img[y2 * width * 4 + x2 * 4 + rgba];
  }
  function imSet(img, x2, y2, width, _height, rgba, val) {
    img[y2 * width * 4 + x2 * 4 + rgba] = val;
  }
  function m(matrix2, i2, v2) {
    var mi = matrix2[i2];
    return mi * v2;
  }
  function c(a2, m1, m2, m3) {
    return m1 + Math.cos(a2) * m2 + Math.sin(a2) * m3;
  }
  class FeColorMatrixElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feColorMatrix";
      var matrix2 = toNumbers(this.getAttribute("values").getString());
      switch (this.getAttribute("type").getString("matrix")) {
        // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement
        case "saturate": {
          var s2 = matrix2[0];
          matrix2 = [0.213 + 0.787 * s2, 0.715 - 0.715 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 + 0.285 * s2, 0.072 - 0.072 * s2, 0, 0, 0.213 - 0.213 * s2, 0.715 - 0.715 * s2, 0.072 + 0.928 * s2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "hueRotate": {
          var a2 = matrix2[0] * Math.PI / 180;
          matrix2 = [c(a2, 0.213, 0.787, -0.213), c(a2, 0.715, -0.715, -0.715), c(a2, 0.072, -0.072, 0.928), 0, 0, c(a2, 0.213, -0.213, 0.143), c(a2, 0.715, 0.285, 0.14), c(a2, 0.072, -0.072, -0.283), 0, 0, c(a2, 0.213, -0.213, -0.787), c(a2, 0.715, -0.715, 0.715), c(a2, 0.072, 0.928, 0.072), 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1];
          break;
        }
        case "luminanceToAlpha":
          matrix2 = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.2125, 0.7154, 0.0721, 0, 0, 0, 0, 0, 0, 1];
          break;
      }
      this.matrix = matrix2;
      this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
    }
    apply(ctx, _x, _y, width, height) {
      var {
        includeOpacity,
        matrix: matrix2
      } = this;
      var srcData = ctx.getImageData(0, 0, width, height);
      for (var y2 = 0; y2 < height; y2++) {
        for (var x2 = 0; x2 < width; x2++) {
          var r2 = imGet(srcData.data, x2, y2, width, height, 0);
          var g2 = imGet(srcData.data, x2, y2, width, height, 1);
          var b2 = imGet(srcData.data, x2, y2, width, height, 2);
          var a2 = imGet(srcData.data, x2, y2, width, height, 3);
          var nr = m(matrix2, 0, r2) + m(matrix2, 1, g2) + m(matrix2, 2, b2) + m(matrix2, 3, a2) + m(matrix2, 4, 1);
          var ng = m(matrix2, 5, r2) + m(matrix2, 6, g2) + m(matrix2, 7, b2) + m(matrix2, 8, a2) + m(matrix2, 9, 1);
          var nb = m(matrix2, 10, r2) + m(matrix2, 11, g2) + m(matrix2, 12, b2) + m(matrix2, 13, a2) + m(matrix2, 14, 1);
          var na = m(matrix2, 15, r2) + m(matrix2, 16, g2) + m(matrix2, 17, b2) + m(matrix2, 18, a2) + m(matrix2, 19, 1);
          if (includeOpacity) {
            nr = 0;
            ng = 0;
            nb = 0;
            na *= a2 / 255;
          }
          imSet(srcData.data, x2, y2, width, height, 0, nr);
          imSet(srcData.data, x2, y2, width, height, 1, ng);
          imSet(srcData.data, x2, y2, width, height, 2, nb);
          imSet(srcData.data, x2, y2, width, height, 3, na);
        }
      }
      ctx.clearRect(0, 0, width, height);
      ctx.putImageData(srcData, 0, 0);
    }
  }
  class MaskElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "mask";
    }
    apply(ctx, element) {
      var {
        document: document2
      } = this;
      var x2 = this.getAttribute("x").getPixels("x");
      var y2 = this.getAttribute("y").getPixels("y");
      var width = this.getStyle("width").getPixels("x");
      var height = this.getStyle("height").getPixels("y");
      if (!width && !height) {
        var boundingBox = new BoundingBox();
        this.children.forEach((child) => {
          boundingBox.addBoundingBox(child.getBoundingBox(ctx));
        });
        x2 = Math.floor(boundingBox.x1);
        y2 = Math.floor(boundingBox.y1);
        width = Math.floor(boundingBox.width);
        height = Math.floor(boundingBox.height);
      }
      var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);
      var maskCanvas = document2.createCanvas(x2 + width, y2 + height);
      var maskCtx = maskCanvas.getContext("2d");
      document2.screen.setDefaults(maskCtx);
      this.renderChildren(maskCtx);
      new FeColorMatrixElement(document2, {
        nodeType: 1,
        childNodes: [],
        attributes: [{
          nodeName: "type",
          value: "luminanceToAlpha"
        }, {
          nodeName: "includeOpacity",
          value: "true"
        }]
      }).apply(maskCtx, 0, 0, x2 + width, y2 + height);
      var tmpCanvas = document2.createCanvas(x2 + width, y2 + height);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      element.render(tmpCtx);
      tmpCtx.globalCompositeOperation = "destination-in";
      tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, "no-repeat");
      tmpCtx.fillRect(0, 0, x2 + width, y2 + height);
      ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, "no-repeat");
      ctx.fillRect(0, 0, x2 + width, y2 + height);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {
    }
  }
  MaskElement.ignoreStyles = ["mask", "transform", "clip-path"];
  var noop = () => {
  };
  class ClipPathElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "clipPath";
    }
    apply(ctx) {
      var {
        document: document2
      } = this;
      var contextProto = Reflect.getPrototypeOf(ctx);
      var {
        beginPath,
        closePath
      } = ctx;
      if (contextProto) {
        contextProto.beginPath = noop;
        contextProto.closePath = noop;
      }
      Reflect.apply(beginPath, ctx, []);
      this.children.forEach((child) => {
        if (typeof child.path === "undefined") {
          return;
        }
        var transform2 = typeof child.elementTransform !== "undefined" ? child.elementTransform() : null;
        if (!transform2) {
          transform2 = Transform.fromElement(document2, child);
        }
        if (transform2) {
          transform2.apply(ctx);
        }
        child.path(ctx);
        if (contextProto) {
          contextProto.closePath = closePath;
        }
        if (transform2) {
          transform2.unapply(ctx);
        }
      });
      Reflect.apply(closePath, ctx, []);
      ctx.clip();
      if (contextProto) {
        contextProto.beginPath = beginPath;
        contextProto.closePath = closePath;
      }
    }
    render(_2) {
    }
  }
  class FilterElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "filter";
    }
    apply(ctx, element) {
      var {
        document: document2,
        children
      } = this;
      var boundingBox = element.getBoundingBox(ctx);
      if (!boundingBox) {
        return;
      }
      var px = 0;
      var py = 0;
      children.forEach((child) => {
        var efd = child.extraFilterDistance || 0;
        px = Math.max(px, efd);
        py = Math.max(py, efd);
      });
      var width = Math.floor(boundingBox.width);
      var height = Math.floor(boundingBox.height);
      var tmpCanvasWidth = width + 2 * px;
      var tmpCanvasHeight = height + 2 * py;
      if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {
        return;
      }
      var x2 = Math.floor(boundingBox.x);
      var y2 = Math.floor(boundingBox.y);
      var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);
      var tmpCanvas = document2.createCanvas(tmpCanvasWidth, tmpCanvasHeight);
      var tmpCtx = tmpCanvas.getContext("2d");
      document2.screen.setDefaults(tmpCtx);
      tmpCtx.translate(-x2 + px, -y2 + py);
      element.render(tmpCtx);
      children.forEach((child) => {
        if (typeof child.apply === "function") {
          child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);
        }
      });
      ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x2 - px, y2 - py, tmpCanvasWidth, tmpCanvasHeight);
      this.restoreStyles(element, ignoredStyles);
    }
    render(_2) {
    }
  }
  FilterElement.ignoreStyles = ["filter", "transform", "clip-path"];
  class FeDropShadowElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feDropShadow";
      this.addStylesFromStyleDefinition();
    }
    apply(_2, _x, _y, _width, _height) {
    }
  }
  class FeMorphologyElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "feMorphology";
    }
    apply(_2, _x, _y, _width, _height) {
    }
  }
  class FeCompositeElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "feComposite";
    }
    apply(_2, _x, _y, _width, _height) {
    }
  }
  class FeGaussianBlurElement extends Element {
    constructor(document2, node2, captureTextNodes) {
      super(document2, node2, captureTextNodes);
      this.type = "feGaussianBlur";
      this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber());
      this.extraFilterDistance = this.blurRadius;
    }
    apply(ctx, x2, y2, width, height) {
      var {
        document: document2,
        blurRadius
      } = this;
      var body = document2.window ? document2.window.document.body : null;
      var canvas = ctx.canvas;
      canvas.id = document2.getUniqueId();
      if (body) {
        canvas.style.display = "none";
        body.appendChild(canvas);
      }
      processCanvasRGBA(canvas, x2, y2, width, height, blurRadius);
      if (body) {
        body.removeChild(canvas);
      }
    }
  }
  class TitleElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "title";
    }
  }
  class DescElement extends Element {
    constructor() {
      super(...arguments);
      this.type = "desc";
    }
  }
  var elements = {
    "svg": SVGElement,
    "rect": RectElement,
    "circle": CircleElement,
    "ellipse": EllipseElement,
    "line": LineElement,
    "polyline": PolylineElement,
    "polygon": PolygonElement,
    "path": PathElement,
    "pattern": PatternElement,
    "marker": MarkerElement,
    "defs": DefsElement,
    "linearGradient": LinearGradientElement,
    "radialGradient": RadialGradientElement,
    "stop": StopElement,
    "animate": AnimateElement,
    "animateColor": AnimateColorElement,
    "animateTransform": AnimateTransformElement,
    "font": FontElement,
    "font-face": FontFaceElement,
    "missing-glyph": MissingGlyphElement,
    "glyph": GlyphElement,
    "text": TextElement,
    "tspan": TSpanElement,
    "tref": TRefElement,
    "a": AElement,
    "textPath": TextPathElement,
    "image": ImageElement,
    "g": GElement,
    "symbol": SymbolElement,
    "style": StyleElement,
    "use": UseElement,
    "mask": MaskElement,
    "clipPath": ClipPathElement,
    "filter": FilterElement,
    "feDropShadow": FeDropShadowElement,
    "feMorphology": FeMorphologyElement,
    "feComposite": FeCompositeElement,
    "feColorMatrix": FeColorMatrixElement,
    "feGaussianBlur": FeGaussianBlurElement,
    "title": TitleElement,
    "desc": DescElement
  };
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys$1(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys$1(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function createCanvas(width, height) {
    var canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    return canvas;
  }
  function createImage(_x) {
    return _createImage.apply(this, arguments);
  }
  function _createImage() {
    _createImage = _asyncToGenerator(function* (src) {
      var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
      var image2 = document.createElement("img");
      if (anonymousCrossOrigin) {
        image2.crossOrigin = "Anonymous";
      }
      return new Promise((resolve, reject) => {
        image2.onload = () => {
          resolve(image2);
        };
        image2.onerror = (_event, _source, _lineno, _colno, error) => {
          reject(error);
        };
        image2.src = src;
      });
    });
    return _createImage.apply(this, arguments);
  }
  class Document {
    constructor(canvg) {
      var {
        rootEmSize = 12,
        emSize = 12,
        createCanvas: createCanvas2 = Document.createCanvas,
        createImage: createImage2 = Document.createImage,
        anonymousCrossOrigin
      } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.canvg = canvg;
      this.definitions = /* @__PURE__ */ Object.create(null);
      this.styles = /* @__PURE__ */ Object.create(null);
      this.stylesSpecificity = /* @__PURE__ */ Object.create(null);
      this.images = [];
      this.fonts = [];
      this.emSizeStack = [];
      this.uniqueId = 0;
      this.screen = canvg.screen;
      this.rootEmSize = rootEmSize;
      this.emSize = emSize;
      this.createCanvas = createCanvas2;
      this.createImage = this.bindCreateImage(createImage2, anonymousCrossOrigin);
      this.screen.wait(this.isImagesLoaded.bind(this));
      this.screen.wait(this.isFontsLoaded.bind(this));
    }
    bindCreateImage(createImage2, anonymousCrossOrigin) {
      if (typeof anonymousCrossOrigin === "boolean") {
        return (source, forceAnonymousCrossOrigin) => createImage2(source, typeof forceAnonymousCrossOrigin === "boolean" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);
      }
      return createImage2;
    }
    get window() {
      return this.screen.window;
    }
    get fetch() {
      return this.screen.fetch;
    }
    get ctx() {
      return this.screen.ctx;
    }
    get emSize() {
      var {
        emSizeStack
      } = this;
      return emSizeStack[emSizeStack.length - 1];
    }
    set emSize(value) {
      var {
        emSizeStack
      } = this;
      emSizeStack.push(value);
    }
    popEmSize() {
      var {
        emSizeStack
      } = this;
      emSizeStack.pop();
    }
    getUniqueId() {
      return "canvg".concat(++this.uniqueId);
    }
    isImagesLoaded() {
      return this.images.every((_2) => _2.loaded);
    }
    isFontsLoaded() {
      return this.fonts.every((_2) => _2.loaded);
    }
    createDocumentElement(document2) {
      var documentElement = this.createElement(document2.documentElement);
      documentElement.root = true;
      documentElement.addStylesFromStyleDefinition();
      this.documentElement = documentElement;
      return documentElement;
    }
    createElement(node2) {
      var elementType = node2.nodeName.replace(/^[^:]+:/, "");
      var ElementType = Document.elementTypes[elementType];
      if (typeof ElementType !== "undefined") {
        return new ElementType(this, node2);
      }
      return new UnknownElement(this, node2);
    }
    createTextNode(node2) {
      return new TextNode(this, node2);
    }
    setViewBox(config) {
      this.screen.setViewBox(_objectSpread$1({
        document: this
      }, config));
    }
  }
  Document.createCanvas = createCanvas;
  Document.createImage = createImage;
  Document.elementTypes = elements;
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) {
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      }
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i2 = 1; i2 < arguments.length; i2++) {
      var source = arguments[i2] != null ? arguments[i2] : {};
      if (i2 % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  class Canvg {
    /**
     * Main constructor.
     * @param ctx - Rendering context.
     * @param svg - SVG Document.
     * @param options - Rendering options.
     */
    constructor(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.parser = new Parser(options);
      this.screen = new Screen(ctx, options);
      this.options = options;
      var document2 = new Document(this, options);
      var documentElement = document2.createDocumentElement(svg2);
      this.document = document2;
      this.documentElement = documentElement;
    }
    /**
     * Create Canvg instance from SVG source string or URL.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    static from(ctx, svg2) {
      var _arguments = arguments;
      return _asyncToGenerator(function* () {
        var options = _arguments.length > 2 && _arguments[2] !== void 0 ? _arguments[2] : {};
        var parser = new Parser(options);
        var svgDocument = yield parser.parse(svg2);
        return new Canvg(ctx, svgDocument, options);
      })();
    }
    /**
     * Create Canvg instance from SVG source string.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    static fromString(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var parser = new Parser(options);
      var svgDocument = parser.parseFromString(svg2);
      return new Canvg(ctx, svgDocument, options);
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string or URL.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    fork(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return Canvg.from(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Create new Canvg instance with inherited options.
     * @param ctx - Rendering context.
     * @param svg - SVG source string.
     * @param options - Rendering options.
     * @returns Canvg instance.
     */
    forkString(ctx, svg2) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      return Canvg.fromString(ctx, svg2, _objectSpread(_objectSpread({}, this.options), options));
    }
    /**
     * Document is ready promise.
     * @returns Ready promise.
     */
    ready() {
      return this.screen.ready();
    }
    /**
     * Document is ready value.
     * @returns Is ready or not.
     */
    isReady() {
      return this.screen.isReady();
    }
    /**
     * Render only first frame, ignoring animations and mouse.
     * @param options - Rendering options.
     */
    render() {
      var _arguments2 = arguments, _this = this;
      return _asyncToGenerator(function* () {
        var options = _arguments2.length > 0 && _arguments2[0] !== void 0 ? _arguments2[0] : {};
        _this.start(_objectSpread({
          enableRedraw: true,
          ignoreAnimation: true,
          ignoreMouse: true
        }, options));
        yield _this.ready();
        _this.stop();
      })();
    }
    /**
     * Start rendering.
     * @param options - Render options.
     */
    start() {
      var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var {
        documentElement,
        screen,
        options: baseOptions
      } = this;
      screen.start(documentElement, _objectSpread(_objectSpread({
        enableRedraw: true
      }, baseOptions), options));
    }
    /**
     * Stop rendering.
     */
    stop() {
      this.screen.stop();
    }
    /**
     * Resize SVG to fit in given size.
     * @param width
     * @param height
     * @param preserveAspectRatio
     */
    resize(width) {
      var height = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : width;
      var preserveAspectRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      this.documentElement.resize(width, height, preserveAspectRatio);
    }
  }
  const index_es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    AElement,
    AnimateColorElement,
    AnimateElement,
    AnimateTransformElement,
    BoundingBox,
    CB1,
    CB2,
    CB3,
    CB4,
    Canvg,
    CircleElement,
    ClipPathElement,
    DefsElement,
    DescElement,
    Document,
    Element,
    EllipseElement,
    FeColorMatrixElement,
    FeCompositeElement,
    FeDropShadowElement,
    FeGaussianBlurElement,
    FeMorphologyElement,
    FilterElement,
    Font,
    FontElement,
    FontFaceElement,
    GElement,
    GlyphElement,
    GradientElement,
    ImageElement,
    LineElement,
    LinearGradientElement,
    MarkerElement,
    MaskElement,
    Matrix,
    MissingGlyphElement,
    Mouse,
    PSEUDO_ZERO,
    Parser,
    PathElement,
    PathParser,
    PatternElement,
    Point,
    PolygonElement,
    PolylineElement,
    Property,
    QB1,
    QB2,
    QB3,
    RadialGradientElement,
    RectElement,
    RenderedElement,
    Rotate,
    SVGElement,
    SVGFontLoader,
    Scale,
    Screen,
    Skew,
    SkewX,
    SkewY,
    StopElement,
    StyleElement,
    SymbolElement,
    TRefElement,
    TSpanElement,
    TextElement,
    TextPathElement,
    TitleElement,
    Transform,
    Translate,
    UnknownElement,
    UseElement,
    ViewPort,
    compressSpaces,
    default: Canvg,
    getSelectorSpecificity,
    normalizeAttributeName,
    normalizeColor,
    parseExternalUrl,
    presets: index,
    toNumbers,
    trimLeft,
    trimRight,
    vectorMagnitude,
    vectorsAngle,
    vectorsRatio
  }, Symbol.toStringTag, { value: "Module" }));
  exports2.default = pdfGenerator;
  exports2.destroy = destroy;
  exports2.exportPdf = exportPdf;
  exports2.generatePdf = generatePdf;
  exports2.init = init;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
}));
